<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/11/25/meeting23.11.25/"/>
      <url>/2023/11/25/meeting23.11.25/</url>
      
        <content type="html"><![CDATA[<h1 id="事件提取作为问题生成和回答"><a href="#事件提取作为问题生成和回答" class="headerlink" title="事件提取作为问题生成和回答"></a>事件提取作为问题生成和回答</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>最近有关事件提取的工作已将该任务重新定义为问答（QA），并取得了有希望的结果。这种方法的优点在于，<span style="background-color: #2ea8e580">它通过直接预测事件参数而不先提取候选者来解决传统基于标记的分类方法中发现的错误传播问题</span>。然而，<span style="background-color: #5fb23680">这些问题通常基于固定模板，很少利用相关论点等上下文信息</span>。此外，<span style="background-color: #5fb23680">先前基于 QA 的方法很难处理同一角色有多个参数的情况</span>。在本文中，我们提出了 QGA-EE，<span style="background-color: #ff666680">它使问题生成（QG）模型能够生成包含丰富上下文信息的问题，而不是使用固定模板</span>。我们还提出了<span style="background-color: #ff666680">动态模板来辅助 QG 模型的训练</span>。实验表明，QGA-EE 在 ACE05 英语数据集上优于所有先前基于单任务的模型。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p><span style="background-color: #2ea8e580">事件提取（EE）旨在从文本中提取核心信息元素（例如人物、事件、地点、时间），是自然语言处理（NLP）中非常重要的任务</span>。它为下游应用程序提供输入，例如摘要（Filatova 和 Hatzivassiloglou，2004 年）、知识库填充（Ji 和 Grishman，2011 年）和推荐（Lu 等人，2016 年）。之前的工作（Li et al., 2013; Nguyen et al., 2016; Sha et al., 2018）通常<span style="background-color: #2ea8e580">基于管道方法，该方法首先识别事件触发词&#x2F;短语和参数候选，然后应用分类器根据成对特征对候选人的角色进行分类</span>。<span style="background-color: #5fb23680">不幸的是，错误往往会沿着管道传播。</span>最近，一些方法<span style="background-color: #2ea8e580">制定了EE作为问答 (QA) 问题（Du 和 Cardie，2020；Li 等人，2020；Lyu 等人，2021）来缓解该问题，其中每个论证角色的问题都是由模板手动定义的</span>。例如，<span style="background-color: #2ea8e580">从 Conflict.Attack 事件中提取“那是因为联军战斗机袭击了查姆查马尔上方山上的伊拉克阵地，伊拉克军队仓促撤退”这句话中的 Attack 参数，被重新构造为回答“谁是那个人”这个问题</span>。<span style="background-color: #2ea8e580">这些方法已经显示出有希望的结果，但基于模板的问题是有限的：由于模板是手动构建的，因此它们是固定的，并且很少包含上下文信息（即特定于输入的信息），除了某些工作中的触发词之外（杜和卡迪，2020）</span>。然而，事实证明，<span style="background-color: #5fb23680">提出好的问题可以提高标准 QA 任务的性能</span>（Rajpurkar 等人，2018）。<span style="background-color: #ff666680">对于基于 QA 的 EE，包含更丰富的上下文信息（例如其他事件参数）的问题可能会产生更好的结果（例如，图 1 中的“谁在山上的袭击中使用了喷气式飞机？”）</span>。</p><p><img src="/attachments/B4PIWFJE.png" class="lazyload placeholder" data-srcset="/attachments/B4PIWFJE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;B4PIWFJE&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22IV5VC27S%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B296.786%2C430.461%2C530.893%2C631.354%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%221%22%7D%7D&quot; width=&quot;390&quot; height=&quot;335&quot; src=&quot;attachments/B4PIWFJE.png&quot; ztype=&quot;zimage&quot;&gt;"><br>在本文中，我们提出了 QGA-EE，它由 1）<span style="background-color: #ff666680">一个用于生成以目标参数 arXiv:2307.05567v1 [cs.CL] 10 Jul 202 角色为条件的上下文感知问题的 QG 模型和 2）一个用于回答用于提取事件参数的上下文感知问题</span>。我们还<span style="background-color: #ff666680">设计了动态模板来生成 QG 模型训练的黄金上下文感知问题</span>。</p><p>     据我们所知，这是第一个基于 QA 的 EE 工作，<span style="background-color: #ff666680">它利用动态模板并专注于生成上下文感知问题</span>。李等人。 （2020）<span style="background-color: #ff666680">还提出了一个模型来生成包含事件触发器和参数的上下文信息的问题</span>。然而，我们的工作有两个主要优点。首先，在李等人中。 （2020）该问题仅包含本体层面的上下文信息（例如论证角色、事件类型）。在我们的工作中，<span style="background-color: #ff666680">生成的问题包含事件提及级别的上下文信息。例如，我们的模型生成的问题包括真实事件论证而不仅仅是论证角色（例如“山丘”与“地点”）。其次，他们工作中的问题是通过填写模板生成的，但我们的模板是动态的，用于训练 QG 模型，该模型可以在给定特定事件提及和相关论点角色的情况下自动生成最佳问题</span>。</p><p>     实验结果表明，QGA-EE 在自动内容提取 (ACE) 2005 英语数据集（Doddington 等人，2004）上优于所有基于单任务的模型，甚至与最先进的联合模型实现了竞争性能IE 模型。</p><h2 id="2-Model"><a href="#2-Model" class="headerlink" title="2 Model"></a>2 Model</h2><p>图1展示了QGA-EE的总体框架。它仅专注于事件参数提取 (EAE)，但可以与任何事件触发标记器配对以执行端到端 EE。在第 4 节中，我们将其与标准序列标记触发标记器配对，以评估其端到端 EE 性能。</p><h2 id="2-1-Question-Generation-Model"><a href="#2-1-Question-Generation-Model" class="headerlink" title="2.1 Question Generation Model"></a>2.1 Question Generation Model</h2><p>之前基于 QA 的 EE 工作（Du 和 Cardie，2020）<span style="background-color: #2ea8e580">使用触发信息填充预先设计的模板，以生成 QA 模型的输入问题</span>。然而，<span style="background-color: #2ea8e580">问题中缺少上下文信息是 QA 模型性能的瓶颈</span>。</p><p>    <span style="background-color: #ff666680">QGA-EE 使用 QG 模型根据输入句子和目标角色生成上下文感知问题，该问题基于序列到序列架构（例如 BART（Lewis et al., 2020）、T5（Raffel et al., 2020） ）。为了训练QG模型，我们为ACE本体中的每个角色设计了动态模板</span>。2我们为每个角色设计了多个模板，每个模板都包含其他参数角色的不同组合。</p><p><img src="/attachments/3RIUDJ3H.png" class="lazyload placeholder" data-srcset="/attachments/3RIUDJ3H.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;3RIUDJ3H&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22E5HNGP4A%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%222%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B302.647%2C567.478%2C527.647%2C700.714%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%222%22%7D%7D&quot; width=&quot;375&quot; height=&quot;222&quot; src=&quot;attachments/3RIUDJ3H.png&quot; ztype=&quot;zimage&quot;&gt;"><br>     例如，<span style="background-color: #2ea8e580">ACE 中的 Conflict.Attack 事件有四个预定义的参数角色：攻击者、目标、工具和地点</span>。3 对于攻击者角色，我们使用问题中包含的其他角色的所有可能组合详尽地设计了八个模板（表格1）。<span style="background-color: #5fb23680">当模型填充给定特定事件提及的模板时，事件提及中通常不存在某些预定义的参数角色。因此，该模型仅保留包含事件提及中出现的参数角色槽的模板</span>。对于图 1 中的示例，<span style="background-color: #ff666680">未提及 Target 角色。因此，我们忽略所有包含 [Target] 槽的模板，并获得攻击者角色的四个候选问题，并填写相应的参数： (1)谁是攻击者？ (2) 谁在袭击中使用了喷气式飞机？ (3) 谁在山上发动袭击？ (4) 谁在山地袭击中使用了喷气式飞机？</span></p><p>     为了训练 QG 模型来生成涵盖尽可能多的上下文信息的问题，我们使用<span style="background-color: #ff666680">包含最多上下文参数的问题作为基本事实</span>。对于图 1 中的示例，我们选择问题“谁在山上袭击中使用了喷气机？”，因为它包含两个参数：“喷气机”和“山丘”，上面列出的其他三个候选问题包含一个或零个参数。如果多个候选问题包含最多的上下文参数，我们就会选择第一个。 QG模型的输入输出示例如下：</p><p><img src="/attachments/72QYSGI8.png" class="lazyload placeholder" data-srcset="/attachments/72QYSGI8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;72QYSGI8&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22UYMF4D67%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B66.346%2C695.928%2C304.038%2C773.813%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;396&quot; height=&quot;130&quot; src=&quot;attachments/72QYSGI8.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h2 id="2-2-Question-Answering-Model"><a href="#2-2-Question-Answering-Model" class="headerlink" title="2.2 Question Answering Model"></a>2.2 Question Answering Model</h2><p><span style="background-color: #2ea8e580">与之前基于 QA 的 EE 工作不同，后者采用仅编码器架构并预测事件参数的偏移量</span>（Chen 等人，2019；Du 和 Cardie，2020；Li 等人，2020；Liu 等人，2020） ; Feng et al., 2020; Lyu et al., 2021; Zhou et al., 2021），<span style="background-color: #2ea8e580">我们的 QA 模型基于序列到序列架构（例如 BART、T5），并直接生成答案字符串。这使得能够预测与同一角色关联的多个事件参数</span>。李等人。 (2021)也采用了生成模型，但输入模板是固定的。输入输出示例如下：</p><p><img src="/attachments/YH68ECKJ.png" class="lazyload placeholder" data-srcset="/attachments/YH68ECKJ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;YH68ECKJ&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22AHLQWG3Q%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B66.136%2C427.345%2C303.409%2C516.663%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;395&quot; height=&quot;149&quot; src=&quot;attachments/YH68ECKJ.png&quot; ztype=&quot;zimage&quot;&gt;"><br><strong>后处理<span style="background-color: #ff666680">：</span></strong><span style="background-color: #ff666680">我们将输出分成候选列表（通过“;”），并通过与原始句子精确匹配来检索带有偏移量的参数</span>。我们<span style="background-color: #ff666680">动态更改搜索的起始位置以保留检索到的事件参数的顺序</span>。<span style="background-color: #ff666680">如果参数候选者无法与原始句子匹配，我们将丢弃它</span>。<span style="background-color: #ff666680">与 QG 模型不同，我们在训练期间使用所有可能的问题作为输入，以实现数据增强目的，并且训练数据的大小从 15,426 增加到 20,681</span>。但<span style="background-color: #ff666680">在测试阶段，我们对每个论证角色使用 QG 模型生成的单个问题</span>。</p><h2 id="3-Experimental-Setup"><a href="#3-Experimental-Setup" class="headerlink" title="3 Experimental Setup"></a>3 Experimental Setup</h2><h3 id="3-1-Dataset-and-Evalution-Metrics"><a href="#3-1-Dataset-and-Evalution-Metrics" class="headerlink" title="3.1 Dataset and Evalution Metrics"></a>3.1 Dataset and Evalution Metrics</h3><p>我们在ACE 2005英语语料库上进行了实验，该语料库有33个事件类型和22个论元角色。它包含从新闻专线、博客、广播对话和广播新闻收集的 599 份文档。更具体地说，我们遵循 Wadden 等人中的预处理步骤。 (2019),4 并在生成的 ACE05-E 数据集上评估我们的模型。</p><p>     对于评估，我们使用与先前工作相同的标准（Li et al., 2013）：<span style="background-color: #2ea8e580">如果事件触发器的偏移量与参考完全匹配，则事件触发器被正确识别。如果它的偏移量和事件类型都与参考匹配，则它被正确分类。如果事件参数的偏移量和事件类型与基本事实中的引用匹配，则事件参数被正确识别（Arg-I）。如果它的所有偏移量、事件类型和参数角色都与引用匹配，则它被正确分类 (Arg-C)</span>。</p><h3 id="3-2-Compared-Baselines"><a href="#3-2-Compared-Baselines" class="headerlink" title="3.2 Compared Baselines"></a>3.2 Compared Baselines</h3><p><strong>模型变体</strong>。为了评估我们方法的普遍性，我们评估了两个 QGA-EE 变体：QGA-EE<sub>BART</sub> 和 QGA-EE<sub>T5</sub>，它们分别使用 BART 和 T5 作为主干。</p><p>      我们将所提出的模型与 SOTA EE 模型进行比较。 <span style="background-color: #2ea8e580">BERT QA（Du 和 Cardie，2020）使用 BERT 作为编码器，并通过角色驱动的问题直接预测论点的位置</span>。 <span style="background-color: #2ea8e580">TANL（Paolini et al., 2021）将输入句子转换为增强自然语言句子以进行结构化预测</span>。 <span style="background-color: #2ea8e580">TEXT2EVENT（Lu 等人，2021）是一种用于事件提取的序列到结构网络</span>。5 <span style="background-color: #2ea8e580">Ma 等人。 （2020）利用依赖解析作为附加功能</span>。 <span style="background-color: #2ea8e580">BART-Gen（Li et al., 2021）是一种基于 BART 的生成模型，旨在用于文档级事件提取</span>。我们还与<span style="background-color: #2ea8e580">在所有 ACE 注释（包括实体、关系和事件）上训练的联合 IE 模型进行比较</span>。它们<span style="background-color: #2ea8e580">受益于其他任务的附加信息，并且通常比在单个任务上训练的模型获得更好的性能</span>。直接将我们的模型与联合模型进行比较是不公平的，因为它们包含了标准 EE 训练集之外的更多信息，但我们仍然列出它们的分数作为参考。 <span style="background-color: #2ea8e580">DYGIE++（Wadden 等人，2019）是一种基于 BERT 的模型，可对句子内和跨句子上下文的跨度表示进行建模</span>。 <span style="background-color: #2ea8e580">ONEIE（Lin et al., 2020）利用了全局特征。 FourIE (Nguyen et al., 2021) 和 GraphIE (Van Nguyen et al., 2022) 是基于图卷积网络的模型，AMRIE (Zhang and Ji, 2021) 使用 AMR (Banarescu et al., 2013) 解析器</span>。</p><h3 id="3-3-Implementation-Details"><a href="#3-3-Implementation-Details" class="headerlink" title="3.3 Implementation Details"></a>3.3 Implementation Details</h3><p>我们在单个 V100 GPU 上进行所有实验。为了进行微调，我们使用 Adafactor（Shazeer 和 Stern，2018）优化器以及学习率为 1 * 10−4，权重衰减为 1 * 10−5，剪辑阈值为 1.0。我们训练模型 20 个 epoch。模型训练和评估的超参数和数据统计等更多详细信息参见附录 C。</p><h2 id="4-Result"><a href="#4-Result" class="headerlink" title="4 Result"></a>4 Result</h2><h3 id="4-1-Event-Argument-Extraction-Performance"><a href="#4-1-Event-Argument-Extraction-Performance" class="headerlink" title="4.1 Event Argument Extraction Performance"></a>4.1 Event Argument Extraction Performance</h3><p><img src="/attachments/DQ3BNJ7Z.png" class="lazyload placeholder" data-srcset="/attachments/DQ3BNJ7Z.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;DQ3BNJ7Z&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22EQ985JR5%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B68.077%2C473.236%2C293.077%2C645.736%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;375&quot; height=&quot;288&quot; src=&quot;attachments/DQ3BNJ7Z.png&quot; ztype=&quot;zimage&quot;&gt;"><br>表 2 显示了 QGA-EE 模型在具有黄金触发器的 ACE05-E 测试集上的性能。<span style="background-color: #ff666680">6 两种 QGA-EE 变体均优于所有其他方法，并且使用 T5 作为骨干比 BART 提高了 2.5%</span>。相对于之前基于 QA 的模型 BERT_QA 的改进表明，<span style="background-color: #ff666680">对于 EE，基于代的 QA 模型比基于位置的 QA 模型更有效</span>。 QGA-EE<sub>BART</sub> 优于基于 BART 的基线 BART-Gen，QGA-EE<sub>T5</sub> 优于基于 T5 的基线 TANL，这证明了<span style="background-color: #ff666680">我们具有不同骨干的模型的有效性</span>。我们的模型<span style="background-color: #ff666680">甚至优于联合 IE 模型 DYGIE++ 和 ONEIE</span>，它们利用了来自实体和关系的附加信息。</p><h3 id="4-2-Event-Extraction-Performance"><a href="#4-2-Event-Extraction-Performance" class="headerlink" title="4.2 Event Extraction Performance"></a>4.2 Event Extraction Performance</h3><p>我们还以更“真实世界”的方式评估我们在 ACE05-E 上的模型，<span style="background-color: #2ea8e580">并使用基于 ALBERT（Lan 等人，2019）的序列标记模型提取的预测触发因素（表 3）</span>。7 与黄金上的表现类似触发器方面，QGA-EE 在预测触发器上从 T5 主干网中受益更多。两种 QGA-EE 变体在 Arg-C 上均优于所有以 EE 任务为中心的基线 1% 以上。</p><p><img src="/attachments/GAXELCRL.png" class="lazyload placeholder" data-srcset="/attachments/GAXELCRL.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;GAXELCRL&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22GGB6TK7K%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B304.038%2C574.775%2C529.615%2C779.582%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;376&quot; height=&quot;341&quot; src=&quot;attachments/GAXELCRL.png&quot; ztype=&quot;zimage&quot;&gt;"><br>我们还包括 SOTA 联合 IE 模型、DYGIE++、ONEIE、FourIE、AMR-IE 和 GraphIE 的分数作为参考。但是，如前所述，直接将我们的模型与它们进行比较是不公平的，因为它们受益于使用来自实体、关系和事件的所有注释进行训练。还应该指出的是，<span style="background-color: #5fb23680">他们的触发标记模型具有更复杂的架构，因此比我们使用的基于序列标记的标记器表现更好（F1 75.4% 来自 FourIE，F1 74.7% 来自 OneIE）。这进一步提高了端到端的 EE 性能。</span></p><h3 id="4-3-Ablation-Study"><a href="#4-3-Ablation-Study" class="headerlink" title="4.3 Ablation Study"></a>4.3 Ablation Study</h3><p>表 4 显示了 QGAEE<sub>T5</sub> 模型在带有金触发器的 ACE05 测试装置上的消融研究。<span style="background-color: #ff666680">通过用简单的上下文感知模板替换 QG 模型，F1 分数降低了 1.65%</span>。它表明我们的 QG 组件生成的上下文感知问题增强了端到端事件参数提取性能。此外，<span style="background-color: #ff666680">基于生成的 QA 模型可以更好地处理多参数情况，并提高了 4.24%</span>。</p><p><img src="/attachments/ECP9H55H.png" class="lazyload placeholder" data-srcset="/attachments/ECP9H55H.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;ECP9H55H&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22IKLTA7G9%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B301.154%2C147.852%2C535.385%2C226.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;390&quot; height=&quot;132&quot; src=&quot;attachments/ECP9H55H.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="4-4-Impact-of-Data-Augmentation"><a href="#4-4-Impact-of-Data-Augmentation" class="headerlink" title="4.4 Impact of Data Augmentation"></a>4.4 Impact of Data Augmentation</h3><p>正如我们在第 2.2 节中提到的，<span style="background-color: #5fb23680">由于我们提出的动态模板的好处，训练数据的大小从 15,426 增加到 20,681</span>。为了评估数据增强的贡献，<span style="background-color: #ff666680">我们使用部分训练数据（带有黄金触发器）评估了 QGA-EE 在 ACE05 测试数据上的性能。数据增强后有 40% 的训练样例 (8,272)，QGA-EE 在具有黄金触发器的 ACE05-E 测试集上实现了 71.42% 的 F1 分数</span>。它优于表 2 中的所有基线，这证明了我们提出的模型的有效性。</p><h3 id="4-5-Analysis-and-Discussion"><a href="#4-5-Analysis-and-Discussion" class="headerlink" title="4.5 Analysis and Discussion"></a>4.5 Analysis and Discussion</h3><p><img src="/attachments/B9LBNQ5P.png" class="lazyload placeholder" data-srcset="/attachments/B9LBNQ5P.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;B9LBNQ5P&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22L2A689RQ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%225%22%2C%22position%22%3A%7B%22pageIndex%22%3A4%2C%22rects%22%3A%5B%5B66.346%2C356.121%2C291.923%2C485.928%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%225%22%7D%7D&quot; width=&quot;376&quot; height=&quot;216&quot; src=&quot;attachments/B9LBNQ5P.png&quot; ztype=&quot;zimage&quot;&gt;">\ <span style="background-color: #ff666680">QGA-EE</span><sub>T 5</sub><span style="background-color: #ff666680"> 生成的问题的平均长度为 10.5 个标记，而 Du 和 Cardie (2020) 中的问题平均长度为 6.7 个</span>。它们包含更多上下文。例如，QGA-EE 为“印度东北部特里普拉邦的一个家庭的至少三名成员被部落暴民 [hackedConflict.Attack] 杀害，据称是因为警方周四表示，“他们练习巫术。”它包含攻击者（“暴民”）和地点（“国家”）信息。我们将错误分为四组：</p><ol><li><strong>QG 模型生成的错误问题</strong>。例如，QGA-EE 生成<em>“国家在 * 出售 * 事件中购买了什么？”</em>，用于“*……斯大林主义国家已开发核武器并暗示可能会出售或使用核武器，具体取决于美国的行动”<em>中的神器角色。 ‘。它应该是“</em>国家在 * 出售 * 事件中出售了什么？*”，这会给 QA 模型带来错误。</li><li><strong>由于 QA 输出结果不匹配而导致的错误</strong>。如果目标候选与原始句子中的多个文本字符串匹配，QGA-EE 可能会检索到错误的偏移量。例如，QGA-EE 将候选人“Welch”与“他还想传唤 Shearman 在 Jane Beasley Welch 人事档案中维护的所有文件”中首次提及的内容进行匹配； Sterling 是一家著名的公司律师事务所，她在 [marriedLife.Marry] Welch 之前曾在此工作过。’，其中第二个提及的是正确的。</li><li><strong>由于缺少实体会议而导致的错误</strong>。例如，QGA-EE 将“Jacques Chirac”识别为 Contact.Phone-Write 事件的实体，“法国总统雅克·希拉克（Jacques Chirac）在周二试图通过向布什拨打电话来修补关系时只收到了保留的回应。”。但“他”是事实真相，指的是“雅克·希拉克”。</li><li><strong>未明确提及的预测</strong>。例如，在“美国负责东亚和太平洋事务的助理国务卿凯利周五从北京抵达首尔，向外交部长尹先生通报情况”中，QGA-EE 将“首尔”推断为“接触.会面”活动的地点，但上下文中没有明确提及，因此没有被黄金注释覆盖。</li></ol><p>     我们手动分析了测试集中的错误子集（50 个示例），并在图 2 中显示了每个类别错误的部分。</p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>在本文中，我们提出了 QGA-EE，<span style="background-color: #ff666680">一种新颖的基于序列到序列的 EE 框架，它利用 QG 模型生成上下文感知问题作为 EAE QA 模型的输入</span>。我们的<span style="background-color: #ff666680">模型自然支持多个事件参数在特定事件提及中扮演相同角色的情况</span>。我们在 ACE05-E 数据集上进行了实验，<span style="background-color: #ff666680">所提出的模型优于所有基于单任务的模型，并与最先进的联合 IE 模型取得了竞争结果</span>。未来，我们计划利用 QA 框架的可扩展性来整合来自<span style="background-color: #5fb23680">半结构化事件相关数据（例如维基百科信息框）的知识。我们还计划将我们的方法扩展到多语言 EE 和联合 IE</span>。</p><h2 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h2><p>动态模板的设计需要事件本体的知识并且非常耗时。该论文的作者花了 30 个小时设计了专属模板，涵盖了 ACE 本体中每个论证角色的所有可能的论证组合。对于更复杂的本体，需要更多的时间。</p><p>     我们方法的另一个限制是偏移检索方法。<span style="background-color: #5fb23680">如果一个句子包含多次提及相同的实体，甚至多个文本字符串具有相同的拼写但引用不同的实体，则 QGA-EE 模型始终会检索该提及在句子中第一次出现的位置作为偏移量提取的目标</span>。可以通过<span style="background-color: #5fb23680">要求模型生成上下文文本作为位置参考来改进它。</span></p><h2 id="A-ACE05-E-Data-Preprocessing"><a href="#A-ACE05-E-Data-Preprocessing" class="headerlink" title="A ACE05-E Data Preprocessing"></a>A ACE05-E Data Preprocessing</h2><p>我们遵循 Wadden 等人中的预处理步骤。 (2019) 预处理 ACE2005 语料库。更具体地说，我们使用 https:&#x2F;&#x2F;github.com&#x2F;dwadden&#x2F;dygiepp 上的预处理脚本。<span style="background-color: #ff666680">此外，我们还检索事件触发器和参数的字符位置，因为 T5 使用 SentencePiece 分词器</span>。表6显示了ACE05-E数据集的统计数据。</p><p><img src="/attachments/3GNR5HNG.png" class="lazyload placeholder" data-srcset="/attachments/3GNR5HNG.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;3GNR5HNG&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%222K972WM9%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B75%2C653.236%2C282.692%2C741.505%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;346&quot; height=&quot;147&quot; src=&quot;attachments/3GNR5HNG.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h2 id="B-Complete-Dynamic-Templates-for-ACE-ontology"><a href="#B-Complete-Dynamic-Templates-for-ACE-ontology" class="headerlink" title="B Complete Dynamic Templates for ACE ontology"></a>B Complete Dynamic Templates for ACE ontology</h2><p>表 12 显示了每个 ACE 事件参数角色的已知参数角色的不同组合的模板的完整列表。</p><h2 id="C-Implementation-Details"><a href="#C-Implementation-Details" class="headerlink" title="C Implementation Details"></a>C Implementation Details</h2><p>我们使用 Huggingface Transformers 库（Wolf 等人，2020）来加载模型检查点。</p><h3 id="C-1-Event-Trigger-Labeling-Model"><a href="#C-1-Event-Trigger-Labeling-Model" class="headerlink" title="C.1 Event Trigger Labeling Model"></a>C.1 Event Trigger Labeling Model</h3><p><img src="/attachments/A5UNJV4V.png" class="lazyload placeholder" data-srcset="/attachments/A5UNJV4V.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;A5UNJV4V&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22BVKNK76E%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B63.5%2C339.39%2C297%2C470.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;389&quot; height=&quot;218&quot; src=&quot;attachments/A5UNJV4V.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>我们实现了基于 ALBERT 的序列标记模型，用于事件触发检测。我们简单地在 ALBERT 编码器之上应用 Softmax 来预测基于 BIO 模式的事件标签。我们在训练期间对 Huggingface 提供的 albert-xxlarge-v2 检查点进行了微调。 8. 我们使用 Adam 优化器，剪辑阈值为 1.0，预热比例为 0.1。表 7 显示了训练事件触发标签模型的超参数。</p><h3 id="C-2-QG-model"><a href="#C-2-QG-model" class="headerlink" title="C.2 QG model"></a>C.2 QG model</h3><p>在生成 QG 模型训练的基本事实时，如果事件提及中不存在目标事件角色，我们将使用基本模板（例如“谁是攻击者？”），而不包含任何参数。我们不限制 QG 模型生成仅出现</p><p><img src="/attachments/SDT7EJRF.png" class="lazyload placeholder" data-srcset="/attachments/SDT7EJRF.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;SDT7EJRF&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22NS25ZWAZ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B314.423%2C632.467%2C518.077%2C777.275%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;339&quot; height=&quot;241&quot; src=&quot;attachments/SDT7EJRF.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>在模板。它们被保留用于训练 QA 模型。我们在训练期间对 Huggingface 提供的 T5-large 检查点进行了微调。 9 使用 Adafactor 优化器，剪辑阈值为 1.0，预热比例为 0.1。表 8 显示了训练 QG 模型的超参数。表 9 显示了用于训练和评估 QG 模型的示例数量。</p><p><img src="/attachments/LHML5GB3.png" class="lazyload placeholder" data-srcset="/attachments/LHML5GB3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;LHML5GB3&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%222GUCTDDW%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B301.731%2C399.39%2C527.308%2C492.275%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;376&quot; height=&quot;155&quot; src=&quot;attachments/LHML5GB3.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="C-3-QA-model"><a href="#C-3-QA-model" class="headerlink" title="C.3 QA model"></a>C.3 QA model</h3><p><img src="/attachments/CKTQ2VJY.png" class="lazyload placeholder" data-srcset="/attachments/CKTQ2VJY.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;CKTQ2VJY&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22KFY2X7XY%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B303.462%2C214.775%2C526.154%2C365.928%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;371&quot; height=&quot;252&quot; src=&quot;attachments/CKTQ2VJY.png&quot; ztype=&quot;zimage&quot;&gt;"><br>对于 QA 模型训练，我们使用 Adafactor 优化器，学习率为 2e-4，权重衰减为 1e-5，剪辑阈值为 1.0。我们将所有relative_step、scale_parameter 和warmup_init 参数设置为False。对于优化器调度程序，我们将预热比例设置为 0.1。如果参数角色没有事件参数，则输出为空，如下例所示。我们将它们用于训练 QA 模型。表9显示用于训练和评估 QA 模型的示例数量。</p><p><img src="/attachments/EZ7RG4XY.png" class="lazyload placeholder" data-srcset="/attachments/EZ7RG4XY.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;EZ7RG4XY&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%224N7REFAZ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%229%22%2C%22position%22%3A%7B%22pageIndex%22%3A8%2C%22rects%22%3A%5B%5B68.077%2C642.275%2C294.231%2C745.544%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%229%22%7D%7D&quot; width=&quot;377&quot; height=&quot;172&quot; src=&quot;attachments/EZ7RG4XY.png&quot; ztype=&quot;zimage&quot;&gt;"><br>在后处理中，我们动态更改搜索的起始位置以保持检索到的事件参数的顺序。</p><h2 id="D-Experiment-Details"><a href="#D-Experiment-Details" class="headerlink" title="D Experiment Details"></a>D Experiment Details</h2><p>对于本文中报告的所有分数，这些数字均基于使用固定随机种子 42 的单次运行。</p><h3 id="D-1-Event-Trigger-Labeling-Model"><a href="#D-1-Event-Trigger-Labeling-Model" class="headerlink" title="D.1 Event Trigger Labeling Model"></a>D.1 Event Trigger Labeling Model</h3><p>表 11 显示了事件触发标签模型在 ACE05-E 测试集上的性能。</p><p><img src="/attachments/EV3VXP6Z.png" class="lazyload placeholder" data-srcset="/attachments/EV3VXP6Z.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;EV3VXP6Z&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FZX576GM4%22%2C%22annotationKey%22%3A%22UYI2SIDA%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%229%22%2C%22position%22%3A%7B%22pageIndex%22%3A8%2C%22rects%22%3A%5B%5B66.346%2C389.005%2C294.231%2C477.852%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FY8PMKXZP%22%5D%2C%22locator%22%3A%229%22%7D%7D&quot; width=&quot;380&quot; height=&quot;148&quot; src=&quot;attachments/EV3VXP6Z.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="D-2-QG-model"><a href="#D-2-QG-model" class="headerlink" title="D.2 QG model"></a>D.2 QG model</h3><p>我们使用Rouge（Lin，2004）得分（ROUGE-1）作为QG模型训练的评估指标，在ACE05-E测试集上的得分为0.892。</p><h1 id="1-实验设置"><a href="#1-实验设置" class="headerlink" title="1.实验设置"></a>1.实验设置</h1><p><img src="/attachments/KL4J4BKL.png" class="lazyload placeholder" data-srcset="/attachments/KL4J4BKL.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;KL4J4BKL&quot; width=&quot;1073&quot; height=&quot;840&quot; src=&quot;attachments/KL4J4BKL.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h1 id="2-已完成实验"><a href="#2-已完成实验" class="headerlink" title="2.已完成实验"></a>2.已完成实验</h1><p>t5-large</p><p>异常情况：预处理ACE05-en数据集的时候，有些句子长度超过1030tokens，截断处理</p><h1 id="3-训练过程记录与指标"><a href="#3-训练过程记录与指标" class="headerlink" title="3.训练过程记录与指标"></a>3.训练过程记录与指标</h1><p><strong>train_trigger_detect_output：</strong></p><p>Epoch: 3, Step: 3354 &#x2F; 3378, used_time &#x3D; 8018.48s, loss &#x3D; 0.024840</p><p>!!! Best dev f1_c (lr&#x3D;2.6682445759368836e-05, epoch&#x3D;3): dev: p_i: 80.02, r_i: 77.39, f1_i: 78.68, p_c: 77.19, r_c: 74.64, f1_c: 75.89, test: p_i: 76.20, r_i: 77.77, f1_i: 76.98 p_c: 73.52, r_c: 75.03, f1_c: 74.27</p><p>Epoch: 8, Step: 1076 &#x2F; 3378, used_time &#x3D; 16318.63s, loss &#x3D; 0.012551</p><p>!!! Best dev f1_c (lr&#x3D;1.947731755424063e-05, epoch&#x3D;8): dev: p_i: 81.41, r_i: 77.39, <strong>f1_i: 79.35</strong>, p_c: 78.75, r_c: 74.86, f1_c: 76.76, test: p_i: 77.37, r_i: 77.19, f1_i: 77.28 p_c: 74.86, r_c: 74.69, <strong>f1_c: 74.77</strong></p><p>Epoch: 16, Step: 3276 &#x2F; 3378, used_time &#x3D; 32568.55s, loss &#x3D; 0.006763</p><p>!!! Best dev f1_c (lr&#x3D;5.0670611439842204e-06, epoch&#x3D;16): dev: p_i: 82.89, r_i: 75.52, f1_i: 79.04, p_c: 80.72, r_c: 73.55, f1_c: 76.97, test: p_i: 78.64, r_i: 73.89, f1_i: 76.19 p_c: 76.58, r_c: 71.95, f1_c: 74.19</p><p><strong>t5_train_question_generation_output</strong></p><p>Epoch: 0, Step: 3200 &#x2F; 6154, used_time &#x3D; 1439.74s, loss &#x3D; 0.077903, dev rouge score &#x3D; 0.713, dev bleu score &#x3D; 0.582, test rouge score &#x3D; 0.709, test bleu score &#x3D; 0.554</p><p>Epoch: 1, Step: 246 &#x2F; 6154, used_time &#x3D; 2931.31s, loss &#x3D; 0.048461, dev rouge score &#x3D; 0.813, dev bleu score &#x3D; 0.721, test rouge score &#x3D; 0.816, test bleu score &#x3D; 0.715</p><p>Epoch: 1, Step: 3446 &#x2F; 6154, used_time &#x3D; 4474.92s, loss &#x3D; 0.035675, dev rouge score &#x3D; 0.847, dev bleu score &#x3D; 0.766, test rouge score &#x3D; 0.849, test bleu score &#x3D; 0.765</p><p>Epoch: 2, Step: 3692 &#x2F; 6154, used_time &#x3D; 7112.13s, loss &#x3D; 0.023807, dev rouge score &#x3D; 0.871, dev bleu score &#x3D; 0.798, test rouge score &#x3D; 0.878, test bleu score &#x3D; 0.806</p><p>Epoch: 3, Step: 738 &#x2F; 6154, used_time &#x3D; 8687.71s, loss &#x3D; 0.020602, dev rouge score &#x3D; 0.873, dev bleu score &#x3D; 0.795, test rouge score &#x3D; 0.877, test bleu score &#x3D; 0.803</p><p>Epoch: 3, Step: 3938 &#x2F; 6154, used_time &#x3D; 10308.56s, loss &#x3D; 0.018197, dev rouge score &#x3D; 0.883, dev bleu score &#x3D; 0.807, test rouge score &#x3D; 0.882, test bleu score &#x3D; 0.803</p><p>Epoch: 4, Step: 984 &#x2F; 6154, used_time &#x3D; 11907.69s, loss &#x3D; 0.016330, dev rouge score &#x3D; 0.885, dev bleu score &#x3D; 0.810, test rouge score &#x3D; 0.888, test bleu score &#x3D; 0.812</p><p>Epoch: 5, Step: 1230 &#x2F; 6154, used_time &#x3D; 14574.76s, loss &#x3D; 0.013600, dev rouge score &#x3D; 0.890, dev bleu score &#x3D; 0.822, test rouge score &#x3D; 0.895, test bleu score &#x3D; 0.822</p><p>Epoch: 6, Step: 1476 &#x2F; 6154, used_time &#x3D; 17217.12s, loss &#x3D; 0.011679, dev rouge score &#x3D; 0.898, dev bleu score &#x3D; 0.830, test rouge score &#x3D; 0.904, test bleu score &#x3D; 0.833</p><p>Epoch: 7, Step: 1722 &#x2F; 6154, used_time &#x3D; 19865.61s, loss &#x3D; 0.010258, dev rouge score &#x3D; 0.900, dev bleu score &#x3D; 0.837, test rouge score &#x3D; 0.905, test bleu score &#x3D; 0.839</p><p>Epoch: 8, Step: 1968 &#x2F; 6154, used_time &#x3D; 22485.64s, loss &#x3D; 0.009141, dev rouge score &#x3D; 0.901, dev bleu score &#x3D; 0.834, test rouge score &#x3D; 0.907, test bleu score &#x3D; 0.840</p><p>Epoch: 9, Step: 5414 &#x2F; 6154, used_time &#x3D; 26139.36s, loss &#x3D; 0.007860, dev rouge score &#x3D; 0.904, dev bleu score &#x3D; 0.840, test rouge score &#x3D; 0.908, test bleu score &#x3D; 0.843</p><p>Epoch: 12, Step: 2952 &#x2F; 6154, used_time &#x3D; 31883.89s, loss &#x3D; 0.006368, dev rouge score &#x3D; 0.906, dev bleu score &#x3D; 0.842, test rouge score &#x3D; 0.910, test bleu score &#x3D; 0.844</p><p>Epoch: 15, Step: 490 &#x2F; 6154, used_time &#x3D; 37482.23s, loss &#x3D; 0.005356, dev rouge score &#x3D; 0.907, dev bleu score &#x3D; 0.845, test rouge score &#x3D; 0.908, test bleu score &#x3D; 0.841</p><p>Epoch: 17, Step: 982 &#x2F; 6154, used_time &#x3D; 42367.79s, loss &#x3D; 0.004752, dev rouge score &#x3D; 0.908, dev bleu score &#x3D; 0.844, test rouge score &#x3D; 0.906, test bleu score &#x3D; 0.838</p><p><strong>t5_train_argument_extraction_output</strong></p><p>Epoch: 0&#x2F;20, Step: 3200 &#x2F; 8034, used_time &#x3D; 931.82s, loss &#x3D; 0.052471</p><p>!!! Best dev f1_c (lr&#x3D;0.00003968, epoch&#x3D;0): p_c: 70.03, r_c: 37.12, f1_c: 48.52, p_i: 77.08, r_i: 38.64, f1_i: 51.48, test: p_c: 69.01, r_c: 32.54, f1_c: 44.22, p_i: 76.06, r_i: 34.43, f1_i: 47.40</p><p>Epoch: 0&#x2F;20, Step: 6400 &#x2F; 8034, used_time &#x3D; 1904.85s, loss &#x3D; 0.033544</p><p>!!! Best dev f1_c (lr&#x3D;0.00007937, epoch&#x3D;0): p_c: 72.97, r_c: 49.28, f1_c: 58.83, p_i: 77.10, r_i: 50.63, f1_i: 61.12, test: p_c: 72.74, r_c: 46.37, f1_c: 56.63, p_i: 77.56, r_i: 48.46, f1_i: 59.65</p><p>Epoch: 1&#x2F;20, Step: 1566 &#x2F; 8034, used_time &#x3D; 2916.74s, loss &#x3D; 0.025784</p><p>!!! Best dev f1_c (lr&#x3D;0.00011905, epoch&#x3D;1): p_c: 71.03, r_c: 57.60, f1_c: 63.62, p_i: 75.44, r_i: 59.75, f1_i: 66.68, test: p_c: 72.04, r_c: 56.02, f1_c: 63.03, p_i: 75.99, r_i: 58.21, f1_i: 65.92</p><p>Epoch: 1&#x2F;20, Step: 4766 &#x2F; 8034, used_time &#x3D; 3901.02s, loss &#x3D; 0.021521</p><p>!!! Best dev f1_c (lr&#x3D;0.00015873, epoch&#x3D;1): p_c: 77.91, r_c: 57.07, f1_c: 65.88, p_i: 81.32, r_i: 58.32, f1_i: 67.92, test: p_c: 74.65, r_c: 51.84, f1_c: 61.19, p_i: 79.58, r_i: 54.53, f1_i: 64.71</p><p>Epoch: 2&#x2F;20, Step: 3132 &#x2F; 8034, used_time &#x3D; 5639.74s, loss &#x3D; 0.016539</p><p>!!! Best dev f1_c (lr&#x3D;0.00019577, epoch&#x3D;2): p_c: 75.36, r_c: 58.94, f1_c: 66.15, p_i: 77.89, r_i: 60.55, f1_i: 68.14, test: p_c: 75.13, r_c: 55.62, f1_c: 63.92, p_i: 78.27, r_i: 58.21, f1_i: 66.77</p><p>Epoch: 3&#x2F;20, Step: 1498 &#x2F; 8034, used_time &#x3D; 7398.84s, loss &#x3D; 0.013610</p><p>!!! Best dev f1_c (lr&#x3D;0.00018695, epoch&#x3D;3): p_c: 74.27, r_c: 66.28, f1_c: 70.05, p_i: 77.95, r_i: 68.16, f1_i: 72.73, test: p_c: 71.27, r_c: 61.69, f1_c: 66.13, p_i: 75.08, r_i: 64.18, f1_i: 69.20</p><p>Epoch: 4&#x2F;20, Step: 6264 &#x2F; 8034, used_time &#x3D; 10693.42s, loss &#x3D; 0.010128</p><p>!!! Best dev f1_c (lr&#x3D;0.00016931, epoch&#x3D;4): p_c: 73.11, r_c: 70.66, f1_c: 71.86, p_i: 78.01, r_i: 72.54, f1_i: 75.17, test: p_c: 72.47, r_c: 64.98, f1_c: 68.52, p_i: 76.24, r_i: 67.36, f1_i: 71.53</p><p>Epoch: 5&#x2F;20, Step: 1430 &#x2F; 8034, used_time &#x3D; 11767.19s, loss &#x3D; 0.009508</p><p>!!! Best dev f1_c (lr&#x3D;0.00016490, epoch&#x3D;5): p_c: 77.20, r_c: 69.68, f1_c: 73.25, p_i: 80.75, r_i: 71.56, f1_i: 75.87, test: p_c: 74.22, r_c: 63.38, f1_c: 68.38, p_i: 77.91, r_i: 66.17, f1_i: 71.56</p><p>Epoch: 6&#x2F;20, Step: 2996 &#x2F; 8034, used_time &#x3D; 14269.70s, loss &#x3D; 0.008048</p><p>!!! Best dev f1_c (lr&#x3D;0.00015168, epoch&#x3D;6): p_c: 74.51, r_c: 72.36, f1_c: 73.42, p_i: 78.04, r_i: 74.15, f1_i: 76.05, test: p_c: 73.30, r_c: 65.97, f1_c: 69.44, p_i: 76.86, r_i: 69.15, f1_i: 72.80</p><p>Epoch: 7&#x2F;20, Step: 1362 &#x2F; 8034, used_time &#x3D; 15932.42s, loss &#x3D; 0.007287</p><p>!!! Best dev f1_c (lr&#x3D;0.00014286, epoch&#x3D;7): p_c: 75.63, r_c: 72.54, f1_c: 74.05, p_i: 79.03, r_i: 74.69, f1_i: 76.80, test: p_c: 73.84, r_c: 66.87, f1_c: 70.18, p_i: 77.93, r_i: 69.95, f1_i: 73.73</p><p>Epoch: 7&#x2F;20, Step: 4562 &#x2F; 8034, used_time &#x3D; 16886.39s, loss &#x3D; 0.006963</p><p>!!! Best dev f1_c (lr&#x3D;0.00013845, epoch&#x3D;7): p_c: 78.64, r_c: 71.11, f1_c: 74.69, p_i: 81.32, r_i: 72.63, f1_i: 76.73, test: p_c: 75.03, r_c: 65.27, f1_c: 69.81, p_i: 78.39, r_i: 68.46, f1_i: 73.09</p><p>Epoch: 10&#x2F;20, Step: 6060 &#x2F; 8034, used_time &#x3D; 23062.37s, loss &#x3D; 0.005113</p><p>!!! Best dev f1_c (lr&#x3D;0.00010317, epoch&#x3D;10): p_c: 76.57, r_c: 72.99, f1_c: 74.74, p_i: 79.95, r_i: 75.04, f1_i: 77.42, test: p_c: 73.03, r_c: 68.66, f1_c: 70.78, p_i: 76.60, r_i: 71.94, f1_i: 74.20</p><p>Epoch: 11&#x2F;20, Step: 7626 &#x2F; 8034, used_time &#x3D; 25554.76s, loss &#x3D; 0.004643</p><p>!!! Best dev f1_c (lr&#x3D;0.00008995, epoch&#x3D;11): p_c: 77.87, r_c: 72.00, f1_c: 74.82, p_i: 80.95, r_i: 73.70, f1_i: 77.16, test: p_c: 74.50, r_c: 66.27, f1_c: 70.14, p_i: 77.83, r_i: 69.55, f1_i: 73.46</p><p>Epoch: 12&#x2F;20, Step: 2792 &#x2F; 8034, used_time &#x3D; 26513.86s, loss &#x3D; 0.004505</p><p>!!! Best dev f1_c (lr&#x3D;0.00008554, epoch&#x3D;12): p_c: 77.11, r_c: 73.08, f1_c: 75.04, p_i: 80.77, r_i: 74.78, f<strong>1_i: 77.66</strong>, test: p_c: 73.76, r_c: 67.86, f1_c: 70.69, p_i: 77.53, r_i: 71.14, <strong>f1_i: 74.20</strong></p><p>Epoch: 13&#x2F;20, Step: 4358 &#x2F; 8034, used_time &#x3D; 28986.51s, loss &#x3D; 0.004139</p><p>!!! Best dev f1_c (lr&#x3D;0.00007231, epoch&#x3D;13): p_c: 77.37, r_c: 73.88, f1_c: 75.59, p_i: 80.75, r_i: 75.85, f1_i: 78.22, test: p_c: 73.51, r_c: 68.06, f1_c: 70.68, p_i: 77.02, r_i: 71.14, f1_i: 73.97</p><h1 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4.实验结果"></a>4.实验结果</h1><h2 id="4-1-trigger-predictions"><a href="#4-1-trigger-predictions" class="headerlink" title="4.1 trigger_predictions"></a>4.1 trigger_predictions</h2><h2 id="4-2-t5-generated-questions"><a href="#4-2-t5-generated-questions" class="headerlink" title="4.2 t5_generated_questions"></a>4.2 t5_generated_questions</h2><p><span style="background-color: #ff666680">Text: role: entity context: A political public service * message * brought to you by Clear Channel.”</span></p><p><span style="background-color: #ff666680">Generated Question: Who communicated with others?</span></p><p><span style="background-color: #ff666680">文本：角色：实体上下文：Clear Channel 为您带来的政治公共服务*消息*。”</span></p><p><span style="background-color: #ff666680">生成的问题：谁与他人交流？（什么与他人交流？）</span></p><p><span style="background-color: #5fb23680">Text: role: destination context: the pentagon tonight said coalition troops have * reached * baghdad international airport.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where was troops transported to?</span></p><p><span style="background-color: #5fb23680">文字：角色：目的地背景：五角大楼今晚表示，联军部队已*抵达*巴格达国际机场。</span></p><p><span style="background-color: #5fb23680">生成的问题：部队被运送到哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: tonight, a series of large * explosions * rocking central baghdad, as we’ve been reporting to you over the course of this hour.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：仪器背景：今晚，一系列大型*爆炸*震撼了巴格达市中心，正如我们在这一小时内向您报告的那样。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: prosecutor context: prosecutors * charge * lindsey ryan with stealing firearms from her parents’ home. police caught up with the two in california.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who executed the indictment?</span></p><p><span style="background-color: #5fb23680">文本：角色：检察官背景：检察官*指控*林赛·瑞恩从她父母家偷窃枪支。 警方在加利福尼亚抓获了这两人。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁执行了起诉书？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: Some of the 40,000 British troops are kicking up a lot of dust in the Iraqi desert making sure that nothing is left behind them that could * hurt * them.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who enacted the harm?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：40,000 名英国军队中的一些人正在伊拉克沙漠中扬起大量灰尘，以确保没有留下任何可能<em>伤害</em>他们的东西。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁造成了伤害？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: two f-14 tomcats struck the targets, the same area was a site of heavy * bombing * yesterday.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：两架 F-14 雄猫袭击了目标，同一地区昨天曾遭受猛烈<em>轰炸</em>。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ffd40080">Text: role: origin context: WOODRUFF And, as we listened to John King’s report, we can tell you that President Bush has just – his plane has just * landed * at Andrews Air Force Base, just close to the Washington area, the president having flown back to the United States from that meeting in Northern Ireland in Belfast with the British prime minister, Tony Blair.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where was Bush transported from with plane?</span></p><p><span style="background-color: #ffd40080">文本：角色：起源背景：WOODRUFF 而且，当我们听取约翰·金的报告时，我们可以告诉您布什总统刚刚——他的飞机刚刚*降落*在安德鲁斯空军基地，靠近华盛顿地区 总统在北爱尔兰贝尔法斯特与英国首相托尼·布莱尔会面后飞回美国。</span></p><p><span style="background-color: #ffd40080">生成的问题：布什是从哪里被飞机运来的？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: They primarily talked about the * war * in Iraq, the aftermath of Iraq. But they also discussed the Middle East and, as well, getting the Northern Ireland peace process started up again.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文字： 角色： 目标背景： 他们主要谈论了伊拉克*战争*的后果。 但他们也讨论了中东问题，以及重新启动北爱尔兰和平进程的问题。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: What was to follow was a horrific education in terror and torture: in the smoking basement of the * bombed * building, a warren of cells.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #ffd40080">文本：角色：地点背景：接下来是一场有关恐怖和酷刑的可怕教育：在被炸毁的大楼冒着烟的地下室里，牢房密布。</span></p><p><span style="background-color: #ffd40080">生成的问题：攻击发生在哪里？ （用bombed更好）</span></p><p><span style="background-color: #5fb23680">Text: role: place context: UNIDENTIFIED MALE People died, people in prison without court, without * trial *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the trial take place?</span></p><p><span style="background-color: #5fb23680">文本： 角色： 地点 背景： 身份不明的男性 人们死了，人们在没有法庭的监狱里，没有*审判*。</span></p><p><span style="background-color: #5fb23680">生成的问题： 审判在哪里进行？</span></p><p><span style="background-color: #ffd40080">Text: role: victim context: The hook in the ceiling is for one purpose only, another hook in a different cell and a different form of * torture *.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was harmed?</span></p><p><span style="background-color: #ffd40080">文本：角色：受害者背景：天花板上的钩子仅用于一个目的，另一个钩子在不同的牢房中以及不同形式的*酷刑*。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁受到伤害？（用原词torture 更好？）</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Hamid Fatil (ph) may look like he’s acting, but he was tortured here, along with his two brothers, who were * executed *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the execution take place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：Hamid Fatil（ph）可能看起来像是在演戏，但他和他的两个兄弟在这里受到了酷刑，他们被*处决*。</span></p><p><span style="background-color: #5fb23680">生成的问题： 执行是在哪里进行的？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: He was hanged there, * hanged *.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who executed person for crime?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工上下文：他被绞死在那里，* 被绞死*。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁因犯罪而处决了人？（生硬，逻辑）</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: Journalists * killed * in the line of duty in Baghdad – how neutral are reporters in a war supposed to be?</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文本：角色：特工背景：记者在巴格达执行任务时*杀害*——记者在战争中应该保持怎样的中立？</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Anwar will be taken to the * appeal * court early Friday for a bail application pending his appeal to the country’s highest Federal Court againt his sodomy conviction, counsel Sankara Nair said.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the appeal take place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点 背景：律师桑卡拉·奈尔 (Sankara Nair) 表示，安瓦尔将于周五早些时候被带到上诉法院申请保释，等待他就鸡奸定罪向该国最高联邦法院提出上诉。</span></p><p><span style="background-color: #5fb23680">生成的问题： 上诉在哪里进行？</span></p><p><span style="background-color: #ffd40080">Text: role: artifact context: But * this * is also conditional on police approval.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was transported?</span></p><p><span style="background-color: #ffd40080">文本：角色：神器上下文：但是*这个*也是以警方批准为条件的。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁被运送了？</span></p><p><span style="background-color: #5fb23680">Text: role: defendant context: He completed four years in prison on a corruption charge last month and is now serving a nine-year sodomy * sentence *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was sentenced for crime?</span></p><p><span style="background-color: #5fb23680">文本：角色：被告背景：他上个月因腐败指控入狱四年，目前正在服刑九年*刑期*。</span></p><p><span style="background-color: #5fb23680">生成的问题： 谁因犯罪被判刑？</span></p><p><span style="background-color: #ff666680">Text: role: entity context: Maurice R. “Hank” Greenberg, who turns 80 in May, groomed two sons to be successors, but both have since * left * AIG.Greenberg Sr. then created an office of the chairman in 2002, which includes co-COOs Martin J. Sullivan and Donald P. Kanak.</span></p><p><span style="background-color: #ff666680">Generated Question: Who fired employee?</span></p><p><span style="background-color: #ff666680">文本：角色：实体背景：莫里斯·R·“汉克”·格林伯格 (Maurice R. “Hank” Greenberg) 今年 5 月就年满 80 岁了，他培养了两个儿子作为继任者，但后来两人都离开了 * AIG.Greenberg Sr. 随后在 2002 年，其中包括联合首席运营官 Martin J. Sullivan 和 Donald P. Kanak。</span></p><p><span style="background-color: #ff666680">生成的问题：谁解雇了员工？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: 2005-01-06T13:10:00 Feminists have a reason to celebrate today as an * appeals * court just threw out the convictions of their martyr, Andrea Yates, by ruling that one of the prosecutor’s expert witnesses gave false testimony at her trial.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the appeal take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点 上下文：2005-01-06T13:10:00 女权主义者今天有理由庆祝，因为*上诉*法院刚刚驳回了对烈士安德里亚·耶茨（Andrea Yates）的定罪，裁定检察官之一 专家证人在对她的审判中作了虚假证词。</span></p><p><span style="background-color: #5fb23680">生成的问题： 上诉在哪里进行？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: No such ceremonies were held for her five * dead * children.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文本：角色：特工背景：没有为她的五个*死去的*孩子举行这样的仪式。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #5fb23680">Text: role: adjudicator context: She was not tried in the deaths of the other two. Today the 1st Court of Appeals overturned the * convictions * and ordered a new trial.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who convicted defendant for crime?</span></p><p><span style="background-color: #5fb23680">文字：角色：审判员背景：她在另外两人的死亡中没有受到审判。 今天，第一上诉法院推翻了*定罪*并下令进行新的审判。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁判定被告犯罪？</span></p><p><span style="background-color: #5fb23680">Text: role: origin context: - Start on Texas Ave. and head away from Bryan - Go down Texas Ave. until you * come * to South West Parkway - Take right on SW Parkway -</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the transporting originate?</span></p><p><span style="background-color: #5fb23680">文本：角色：起源背景： - 从 Texas Ave. 出发，远离 Bryan - 沿着 Texas Ave. 行驶，直到到达 South West Parkway - 在 SW Parkway 右转 -</span></p><p><span style="background-color: #5fb23680">生成的问题：运输起源于哪里？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: The charismatic leader of Turkey’s governing party was named prime minister Tuesday, a step that probably boosts chances that the United States will get permission to * deploy * troops in the country along Iraq’s northern border.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who transported troops to country?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：土耳其执政党的魅力领袖周二被任命为总理，这一举措可能会增加美国获得许可在该国伊拉克北部边境部署军队的机会。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁向国家运送军队？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: Turks overwhelmingly oppose a * war * _ by 94 percent, according to some polls.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：根据一些民意调查，土耳其人以 94% 的压倒性反对 * 战争 * _。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: destination context: If the resolution is not passed, Washington would likely want to use the airspace for strikes against Iraq and for * airlifting * troops to northern Iraq.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did Washington transport troops to?</span></p><p><span style="background-color: #5fb23680">文本：角色：目的地背景：如果该决议未获得通过，华盛顿可能希望利用该领空对伊拉克进行打击，并向伊拉克北部空运部队。</span></p><p><span style="background-color: #5fb23680">生成的问题：华盛顿将军队运送到哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: person context: After he was * elected *, Erdogan said Turkey wanted assurances from the United States on its role in Iraq.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was elected?</span></p><p><span style="background-color: #5fb23680">文字：角色：人物背景：埃尔多安当选后表示，土耳其希望美国就其在伊拉克的角色做出保证。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁当选了？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: Iraqi Kurds fear that Turkish troops could move deep into the autonomous enclave in northern Iraq and have threatened * clashes *.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where did troops make an attack?</span></p><p><span style="background-color: #ffd40080">文本：角色：地点背景：伊拉克库尔德人担心土耳其军队可能深入伊拉克北部的自治飞地，并威胁“发生冲突”。</span></p><p><span style="background-color: #ffd40080">生成的问题：部队在哪里发起攻击？（冲突在哪里发生？）</span></p><p><span style="background-color: #5fb23680">Text: role: person context: Erdogan, a leader of Turkey’s pro-Islamic movement when he was * jailed *, said he moderated his policies in prison.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was arrested?</span></p><p><span style="background-color: #5fb23680">文字：角色：人物背景：埃尔多安是土耳其亲伊斯兰运动的领导人，他在入狱时表示，他在监狱中缓和了自己的政策。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被捕了？</span></p><p><span style="background-color: #ff666680">Text: role: agent context: other p.o.w.s from iraq after they were captured and released, that dramatic release that sunday morning when they were picked up by a squadron of marines who had wanted * wandered * in a town in baghdad and were told where they were being kept.</span></p><p><span style="background-color: #ff666680">Generated Question: Who is responsible for the transport event?</span></p><p><span style="background-color: #ff666680">文本：角色：特工背景：其他来自伊拉克的战俘在被抓获并被释放后，周日早上戏剧性地释放了他们，当时他们被一个海军陆战队中队抓了起来，他们想要在巴格达的一个小镇<em>徘徊</em>并被告知 他们被关押的地方。</span></p><p><span style="background-color: #ff666680">生成的问题：谁负责运输事件？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: moving on now, in upstate new york stock exchange criminal * charges * have been filed in last month’s fraternity hazing death at platsberg state university of new york.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where did the indictment take place?</span></p><p><span style="background-color: #ffd40080">文本：角色：地点背景：现在继续，纽约州北部证券交易所对上个月发生在纽约普拉茨伯格州立大学兄弟会欺凌死亡事件的刑事指控已被提起。</span></p><p><span style="background-color: #ffd40080">生成的问题：起诉发生在哪里？（哪里发生了指控或者指控地点在哪里）</span></p><p><span style="background-color: #5fb23680">Text: role: adjudicator context: the fraternity also faces more than 150 * charges * for other hazing activities, as well.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who adjudicated the indictment?</span></p><p><span style="background-color: #5fb23680">文本：角色：裁决者背景：兄弟会还因其他欺凌活动而面临 150 多项*指控*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁对起诉书作出裁决？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: 2004-12-01T23:13:00 More than a few e-mails have come in wondering why I haven’t remarked on the horrible hunting * tragedy * on Nov. 21 that left six people dead, and why I haven’t updated the ASSAULT WEAPONS BAN COUNTER.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文本： 角色： 代理人 上下文： 2004-12-01T23:13:00 很多电子邮件都在问我为什么没有对 11 月 21 日造成六人死亡的可怕狩猎 * 悲剧 * 发表评论 死了，以及为什么我没有更新攻击武器禁令计数器。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: The ban expired in September and at the time of this posting, no one has been * killed * by any one of those weapons since the ban expired.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the killer?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：禁令已于 9 月份到期，截至发帖时，自禁令到期以来，没有人被任何一种武器*杀死*。</span></p><p><span style="background-color: #ffd40080">产生的问题：谁是凶手？（模板、生硬）</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: If convicted of the * killings *, Vang faces life in prison as Minnesota does not honor the death penalty.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文字：角色：受害者背景：如果因“杀人”罪名成立，Vang 将面临终身监禁，因为明尼苏达州不执行死刑。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: Although North Korea accused the United States of leading the region toward * war * in its state media, U.S. officials denied reports the talks had broken down.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：目标背景：尽管朝鲜在其官方媒体上指责美国带领该地区走向“战争”，但美国官员否认了谈判破裂的报道。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: They said reports of a breakdown in the * talks * were a misrepresentation.’’</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the meeting takes place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：他们说有关*会谈失败的报道*是一种歪曲事实。”</span></p><p><span style="background-color: #5fb23680">生成的问题：会议在哪里举行？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Discussions were scheduled to end Friday, when Kelly was to fly to Seoul the same day to * meet * with South Korean officials.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did Kelly meet others?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：讨论定于周五结束，凯利当天将飞往首尔与韩国官员*会面*。</span></p><p><span style="background-color: #5fb23680">生成的问题：凯利在哪里认识其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: The situation on the Korean Peninsula is so tense that a * war * may break out any moment due to the U.S. moves,’’ the KCNA statement said.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：攻击者背景：朝鲜半岛局势如此紧张，由于美国的举动，“战争”随时可能爆发，”朝中社声明称。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: beneficiary context: The North also likely wants aid for its economy, which has been crippled by the loss of Soviet * subsidies * and years of drought and mismanagement.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who benefited from the transfer?</span></p><p><span style="background-color: #5fb23680">文本：角色：受益人背景：朝鲜也可能希望为其经济提供援助，该国经济因苏联*补贴*的丧失以及多年的干旱和管理不善而陷入瘫痪。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁从转移中受益？</span></p><p><span style="background-color: #5fb23680">Text: role: beneficiary context: China, the North’s ally and major aid donor, says it doesn’t want Pyongyang to * acquire * nuclear weapons and has appealed for a negotiated settlement to the crisis.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who benefits from the transaction?</span></p><p><span style="background-color: #5fb23680">文本：角色：受益人背景：作为朝鲜的盟友和主要援助国，中国表示不希望平壤“获得”核武器，并呼吁通过谈判解决危机。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁从交易中受益？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: CHILCOTE He orders his men * back * to their compound to await cooler heads.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who is responsible for the transport event?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：CHILCOTE 他命令他的部下*返回*他们的大院，等待头脑冷静。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁负责运输事件？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: In one of the incidents, a soldier was * killed * and several others wounded.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：在其中一次事件中，一名士兵*被杀*，其他几人受伤。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Before word of that death, 40 Americans had been killed by hostile * fire * in Operation Iraqi Freedom.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：在死亡消息传出之前，40 名美国人在伊拉克自由行动中被敌对的“火力”杀害。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Eleven of them by friendly fire or in other accidents. Most of the 27 British troops killed have been victims of friendly * fire * or accidents.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：其中十一次因友军火力或其他事故而发生。 阵亡的 27 名英国士兵中的大多数都是友军“炮火”或事故的受害者。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: origin context: Well, when they do finally * enter * Baghdad, U.S. and coalition troops could face urban combat with the Republican Guard, some of whom may have withdrawn into the city.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the transporting originate?</span></p><p><span style="background-color: #5fb23680">文本：角色：起源背景：好吧，当他们最终*进入*巴格达时，美国和联军可能会面临与共和国卫队的城市战斗，其中一些人可能已经撤回了该市。</span></p><p><span style="background-color: #5fb23680">生成的问题：运输起源于哪里？</span></p><p><span style="background-color: #ffd40080">Text: role: prosecutor context: like any good spy movie, it’s already had a sequel with the first * indictment * earlier in the week and another one just yesterday.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who executed the indictment?</span></p><p><span style="background-color: #ffd40080">文本：角色：检察官背景：就像任何一部优秀的间谍电影一样，它已经有了续集，第一部*起诉书*在本周早些时候发布，昨天又发布了另一部。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁执行了起诉书？</span></p><p><span style="background-color: #5fb23680">Text: role: prosecutor context: leung’s lawyers wasted little time responding to the grand jury * indictment *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who indicated leung for crime?</span></p><p><span style="background-color: #5fb23680">文字：角色：检察官背景：梁振英的律师几乎没有浪费时间回应大陪审团*起诉书*。</span></p><p><span style="background-color: #5fb23680">生成问题：谁指认梁某犯罪？</span></p><p><span style="background-color: #5fb23680">Text: role: adjudicator context: 2005-01-05T09:22:00 Yesterday’s bad day for Krispy Kreme included some speculation that the new securities * lawsuit * filed against the company would be granted class action status.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who adjudicated the suing?</span></p><p><span style="background-color: #5fb23680">文本： 角色：裁决者 背景： 2005-01-05T09:22:00 昨天 Krispy Kreme 的糟糕日子包括一些猜测，即针对该公司提起的新证券*诉讼*将被授予集体诉讼地位。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁对起诉做出裁决？</span></p><p><span style="background-color: #ff666680">Text: role: adjudicator context: The results highlight trends in types of filings (increase in product market related * filings *), affected sectors (big increase in energy &#x26;amp; technology sector), and overall number of filings (fairly steady).</span></p><p><span style="background-color: #ff666680">Generated Question: Who adjudicated the suing?</span></p><p><span style="background-color: #ff666680">文本：角色：裁决者背景：结果突出了申请类型的趋势（与产品市场相关的*申请*增加）、受影响的行业（能源和技术行业大幅增加）以及申请总数（相当稳定） 。</span></p><p><span style="background-color: #ff666680">生成的问题：谁对起诉做出裁决？</span></p><p><span style="background-color: #ffd40080">Text: role: entity context: once he gets out of the helicopter he’ll transfer to air force one to come home after a 20-hour * visit * with the prime minister of great britain.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who met with others?</span></p><p><span style="background-color: #ffd40080">文本：角色：实体背景：一旦他下了直升机，他将转乘空军一号，在与英国首相进行 20 小时的“访问”后回家。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: and i asked him about the news that saddam hussein was targeted in yesterday’s strike and how iraqis would react if saddam was * killed *.</span></p><p><span style="background-color: #5fb23680">Generated Question: What device was used to kill?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：我向他询问了萨达姆·侯赛因在昨天的袭击中成为目标的消息，以及如果萨达姆被*杀死*，伊拉克人将如何反应。</span></p><p><span style="background-color: #5fb23680">生成的问题： 使用什么设备进行杀人？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: What do you think of Israel’s policies surrounding Arafat’s illness and * death *?</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：您如何看待以色列围绕阿拉法特患病和*死亡*的政策？</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #ffd40080">Text: role: attacker context: They’re fi- they don’t even know why they’re * fighting * anymore. They just they hate each other – and they’re always going to hate each other – and it doesn’t matter who started it, but – i- you know, somebody eh, th- somebody’s in always intent on winning.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #ffd40080">文本：角色：攻击者上下文：他们是——他们甚至不知道为什么要* 战斗* 了。 他们只是互相憎恨——而且他们总是会互相憎恨——谁先开始的并不重要，但是——我——你知道，有人呃，有人总是一心想赢。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ffd40080">Text: role: attacker context: There were – two very strong – militant groups that were Israeli and they – committed a lot of terrorist * acts *,</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #ffd40080">文本：角色：攻击者背景：有两个非常强大的以色列激进组织，他们犯下了许多恐怖行为*，</span></p><p><span style="background-color: #ffd40080">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ff666680">Text: role: target context: Mike He was he was basically – I mean, I’ve read I’ve read articles an- and- and- and – stories that basically have linked him to the to the to the Munich – * massacre * – th- you know, the Munich Olympic massacre th- the Is- the Israeli team.</span></p><p><span style="background-color: #ff666680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #ff666680">文字：角色：目标背景：迈克 他基本上是——我的意思是，我读过我读过的文章和——以及——基本上将他与慕尼黑联系起来的故事—— -*屠杀*–你知道，慕尼黑奥运会的屠杀就是-以色列队。</span></p><p><span style="background-color: #ff666680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: These pictures were taken on the runway just moments after the coalition * attack *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文字： 角色： 目标背景： 这些照片是在联军*攻击*后不久在跑道上拍摄的。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #ffd40080">Text: role: attacker context: MATES Outside the airport, the * fighting * was fierce, but the battle unequal. Here, the remains of an Iraqi armored car, and by its side the body of an Iraqi soldier, all that remains of a column that pushed up the airport road last night in a final effort to defend the airport.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #ffd40080">文字：角色：袭击者背景：伙伴 机场外，*战斗*很激烈，但战斗不平等。 这里有一辆伊拉克装甲车的残骸，旁边还有一名伊拉克士兵的尸体，这些都是昨晚在机场道路上奋力保卫机场的一支纵队的残骸。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: But the final push into the city could yet prove to be the toughest * fighting * of all.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：但最后的进城可能会被证明是最艰难的*战斗*。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #ffd40080">Text: role: instrument context: This isn’t a football game, and it’s not two drunken cousins * fighting * at a family reunion.</span></p><p><span style="background-color: #ffd40080">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #ffd40080">文本：角色：乐器背景：这不是一场足球比赛，也不是两个喝醉的表兄弟在家庭聚会上*打架*。</span></p><p><span style="background-color: #ffd40080">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #ff666680">Text: role: beneficiary context: The rebels have * captured * the country’s main international airport, said a top official in a 300-strong African security force policing the city.</span></p><p><span style="background-color: #ff666680">Generated Question: Who benefits from the transaction?</span></p><p><span style="background-color: #ff666680">文字：角色：受益人背景：负责该市治安的 300 名非洲安全部队的一名高级官员表示，叛乱分子已经<em>占领</em>了该国的主要国际机场。</span></p><p><span style="background-color: #ff666680">生成的问题：谁从交易中受益？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: he is also suspected in three atlanta-area * bombings *.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：仪器背景：他还涉嫌参与亚特兰大地区三起*爆炸案*。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: The Revolutionary Armed Forces of Colombia (FARC) said Monday that it was prepared to exchange prisoners with the government despite the * death * of 10 hostages held by the rebel group.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：哥伦比亚革命武装力量 (FARC) 周一表示，尽管反叛组织扣押的 10 名人质“死亡”，但仍准备与政府交换囚犯。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: The 17,000-strong FARC, the largest guerrilla force in Colombia, has been fighting a war against the government for more than 40 years, leaving 400,000 * dead *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：17,000 人的哥伦比亚最大游击队哥伦比亚革命武装力量 (FARC) 与政府的战争已持续 40 多年，造成 40 万人*死亡*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: Despite a security crackdown over the weekend in Baghdad and an announcement that some 7,000 policemen had returned to their jobs since the end of the * war *, ordinary Iraqis still felt unsafe on the street with gunfire rife and police a near invisible presence.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：尽管巴格达周末进行了安全镇压，并宣布自*战争*结束以来大约7,000名警察已返回工作岗位，但普通伊拉克人在枪林弹雨的街道上仍然感到不安全 警察几乎是隐形的存在。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: The comments came on the same day that a prominent Iraqi called for internationally-supervised * elections * in Iraq.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the voting agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：特工背景：在发表上述评论的同一天，一位著名的伊拉克人呼吁在伊拉克进行国际监督的*选举*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是投票代理人？</span></p><p><span style="background-color: #ff666680">Text: role: person context: coalition forces in baghdad have * arrested * the palestinian terrorist who led the hijacking of the italian cruise ship the achille lauro in 1985.</span></p><p><span style="background-color: #ff666680">Generated Question: Who was arrested by forces in baghdad?</span></p><p><span style="background-color: #ff666680">文本：角色：人物背景：巴格达的联军已*逮捕*1985年领导劫持意大利游轮阿奇·劳罗号的巴勒斯坦恐怖分子。</span></p><p><span style="background-color: #ff666680">生成的问题： 谁在巴格达被部队逮捕？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: They also serve as a reminder that many of our colleagues covering this * war * are putting their lives on the line every day.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：它们还提醒我们，我们报道这场*战争*的许多同事每天都在冒着生命危险。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #a28ae580">Text: role: place context: At a nearby hotel, two other journalists, a photographer from Reuters and another from Tele 5 Spain * died *, another case, CENTCOM says, of coalition forces returning fire.</span></p><p><span style="background-color: #a28ae580">Generated Question: Where was photographer killed?</span></p><p><span style="background-color: #a28ae580">文本：角色：地点背景：在附近的一家酒店，另外两名记者、一名来自路透社的摄影师和另一名来自西班牙第五电视台的摄影师*死亡*，中央司令部称，这是联军还击的另一起案件。</span></p><p><span style="background-color: #a28ae580">生成的问题：摄影师在哪里被杀？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: And an American writer&#x2F;editor, “Washington Post” editorial columnist Michael Kelly, was killed when his Humvee plunged into a canal while evading Iraqi * fire *.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：乐器背景：美国作家&#x2F;编辑、《华盛顿邮报》社论专栏作家迈克尔·凯利在躲避伊拉克*火力*时，他的悍马车陷入运河中身亡。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: Famed combat photographer Robert Capa, who took a classic photo of a fighter’s death during the Spanish Civil * War *, himself died from a land mine in Indochina.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：仪器背景：著名战地摄影师罗伯特·卡帕在西班牙内战时期拍摄了一张战士死亡的经典照片，他本人也在印度支那死于地雷。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: ABC News producer David Kaplan was killed by sniper * fire * in the Balkans in 1992. Sometimes reporters, like “The Wall Street Journal”‘s Danny Pearl, die in covering a different kind of war.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：乐器背景：1992 年，ABC 新闻制片人戴维·卡普兰 (David Kaplan) 在巴尔干半岛被狙击手 * 火力 * 杀死。有时，像《华尔街日报》的丹尼·珀尔 (Danny Pearl) 这样的记者，会在报道不同类型的战争时丧生 。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: The 600 journalists embedded with American troops in Iraq will be threatened by the same * fire * as the troops they are covering.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：随驻伊拉克美军的 600 名记者将受到与他们报道的部队相同的“火力”威胁。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: Reporters who ignore or distort facts are betraying their craft no matter what and no matter how much that may anger the people running a * war *.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：忽视或歪曲事实的记者正在背叛他们的技艺，无论怎样，无论这可能激怒正在发动*战争*的人们。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: Just now, we want to show you scenes from Andrews Air Force Base just moments ago, President Bush returning to the United States from his * summit * in Northern Ireland in Belfast with British Prime Minister Tony Blair, the president back on American soil after a quick two-day trip, less than two-day trip to Belfast, he and the prime minister discussing, of course, the war in Iraq, what happens after, as well as the peace process in the Middle East, and restarting the peace process in Northern Ireland.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where did Bush meet others?</span></p><p><span style="background-color: #ffd40080">文字：角色：地点背景：刚才，我们想向您展示不久前安德鲁斯空军基地的场景，布什总统与英国首相托尼·布莱尔在贝尔法斯特举行的北爱尔兰峰会返回美国 总统在结束了为期两天的快速访问后回到了美国领土，贝尔法斯特的访问还不到两天，他和总理当然讨论了伊拉克战争、之后发生的事情，以及伊拉克的和平进程。 中东局势，重启北爱尔兰和平进程。</span></p><p><span style="background-color: #ffd40080">生成的问题：布什在哪里见到其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: a massive manhunt underway where a rapist is * targeting * children.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was attacked by rapist?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：大规模搜捕正在进行中，一名强奸犯正在以儿童为目标。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被强奸犯袭击了？</span></p><p><span style="background-color: #ffd40080">Text: role: vehicle context: the who says sars advisories against * travel * to hong kong, beijing and the chinese provences will remain in effect.</span></p><p><span style="background-color: #ffd40080">Generated Question: What vehicle was used for transporting?</span></p><p><span style="background-color: #ffd40080">文字：角色：车辆背景：世卫组织表示，针对“非典”旅行建议，禁止前往香港、北京和中国普罗旺斯地区旅行。</span></p><p><span style="background-color: #ffd40080">生成的问题： 使用什么车辆进行运输？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: ask any american marine and they’ll tell you they’ll do anything possible to recover the bodies of * fallen * comrades. that grim task was carried out by marines engaged in the fierce battle for the city of nasiriyah nasiriyah.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：询问任何美国海军陆战队员，他们会告诉你他们会尽一切可能来找回<em>倒下的</em>战友的尸体。 这项艰巨的任务是由参与纳西里耶市激烈战斗的海军陆战队员执行的。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #ffd40080">Text: role: artifact context: I wonder if B had a huge messy divorce, and his ex * took * the kid out of state.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was transported?</span></p><p><span style="background-color: #ffd40080">文本：角色：神器背景：我想知道 B 是否经历了一次巨大而混乱的离婚，并且他的前<em>把</em>孩子带出了州。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁被运送了？</span></p><p><span style="background-color: #5fb23680">Text: role: person context: Sometimes we want to see * marriage * one dimensionally.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was married?</span></p><p><span style="background-color: #5fb23680">文本：角色：人物背景：有时我们希望以一维的方式看待<em>婚姻</em>。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁结婚了？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: I really haven’t changed very much from who I was before. Although, the dog thing is really post * divorce *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the divorce take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：我与以前相比确实没有太大改变。 不过，狗的事情确实是<em>离婚后</em>的。</span></p><p><span style="background-color: #5fb23680">生成的问题： 离婚发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Especially for those of us who still have so many years (if one year for every 2 * married *, then I’ve still got another 7 or so) to go to get our heads screwed back on and find some sort of life that rivals what we had or what our ex has or what you and your ex have.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the marriage take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：特别是对于我们这些还有很多年时间（如果每 2 个结婚*一年，那么我还有另外 7 年左右）去把我们的头拧回去并 找到某种与我们或我们的前任或你和你的前任拥有的生活相媲美的生活。</span></p><p><span style="background-color: #5fb23680">生成的问题： 婚姻在哪里举行？</span></p><p><span style="background-color: #5fb23680">Text: role: defendant context: It would be, certainly, to know, to apprehend him, to * bring * him before a court of justice.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was on trial?</span></p><p><span style="background-color: #5fb23680">文本：角色：被告背景：当然，这将是了解、逮捕将他<em>带</em>上法庭。</span></p><p><span style="background-color: #5fb23680">生成的问题： 谁受审？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: the store’s owner and the palestinian bomber were * killed *. the store is a total loss.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：商店老板和巴勒斯坦轰炸机被<em>杀死</em>。 商店完全亏损。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #ff666680">Text: role: agent context: powell is wrapping up a trip to southeast asia, he’s * due * here in jerusalem tomorrow morning for talks with the israeli prime minister and the foreign minister.</span></p><p><span style="background-color: #ff666680">Generated Question: Who is responsible for the transport event?</span></p><p><span style="background-color: #ff666680">文本：角色：特工背景：鲍威尔即将结束东南亚之行，他将于明天早上在耶路撒冷与以色列总理和外交部长举行会谈。</span></p><p><span style="background-color: #ff666680">生成的问题：谁负责运输事件？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: Five Iraqi civilians, including a woman, were * killed * Monday when their houses were hit by a missile fired by the US-led coalition warplanes, witnesses said.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：目击者称，周一，五名伊拉克平民（其中包括一名妇女）的房屋被美国领导的联军战机发射的导弹击中而死亡。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #e56eee80">Text: role: instrument context: Five Iraqi civilians, including a woman, were killed Monday when their houses were * hit * by a missile fired by the US-led coalition warplanes, witnesses said.</span></p><p><span style="background-color: #e56eee80">Generated Question: What instrument did warplanes use to attack houses?</span></p><p><span style="background-color: #e56eee80">文本：角色：仪器背景：目击者称，周一，五名伊拉克平民（包括一名妇女）的房屋被美国领导的联军战机发射的导弹击中身亡。</span></p><p><span style="background-color: #e56eee80">生成的问题：战机使用什么工具来攻击房屋？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: Although the coalition leaders have repeatedly assured that every effort would be made to minimize civilian casualties in the current Iraq * war *, at least 130 Iraqi civilians have been reportedly killed since the war started five days ago.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文字：角色：受害者背景：尽管联军领导人一再保证将尽一切努力减少当前伊拉克<em>战争</em>中的平民伤亡，但据报道，自五天前战争爆发以来，至少有130名伊拉克平民被杀。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #e56eee80">Text: role: victim context: According to other reports reaching here, five Syrian bus passengers were killed and 10 others were * injured * on Sunday morning when a US missile hit the bus they were traveling in near the Iraqi border.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was harmed with missile?</span></p><p><span style="background-color: #e56eee80">文字：角色：受害者背景：根据其他报道，周日早上，一枚美国导弹击中了他们在伊拉克边境附近行驶的巴士，导致 5 名叙利亚巴士乘客死亡，另有 10 人受伤。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁被导弹伤害了？</span></p><p><span style="background-color: #e56eee80">Text: role: destination context: The vehicle was * carrying * Syrians fleeing the war in Iraq.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where was Syrians transported to with vehicle?</span></p><p><span style="background-color: #e56eee80">文本：角色：目的地背景：这辆车<em>载着</em>逃离伊拉克战争的叙利亚人。</span></p><p><span style="background-color: #e56eee80">生成的问题：叙利亚人被车辆运到哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: origin context: The convoy was * escorted * by U.S. soldiers.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the transporting originate?</span></p><p><span style="background-color: #5fb23680">文本：角色：起源背景：车队由美国士兵<em>护送</em>。</span></p><p><span style="background-color: #5fb23680">生成的问题：运输起源于哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: After days of fierce * fighting * that shut down the city of Umm Qasr, Iraqi youths cheered and swarmed British troops as they handed out yellow meal packets and bottles of water Wednesday.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：袭击者背景：经过数天的激烈“战斗”，乌姆盖斯尔市被封锁，星期三，伊拉克年轻人欢呼雀跃，蜂拥而至英国军队，分发黄色餐包和瓶装水。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: White House spokesman Ari Fleischer blamed Saddam Hussein’s regime for slowing the flow of US$105 million in U.S. * aid * by placing mines in the port of Umm Qasr.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where was the amount transferred?</span></p><p><span style="background-color: #ffd40080">文字：角色：地点背景：白宫发言人阿里·弗莱舍尔 (Ari Fleischer) 指责萨达姆·侯赛因政权在乌姆盖斯尔港埋设地雷，减缓了美国<em>援助</em>的 1.05 亿美元的流动。<br><br>生成的问题： 转账金额到哪里了？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: The World Food Program, a U.N. agency, said it would make its biggest single request for cash in its history _ more than US$1 billion to help feed the * war *-stricken nation for about six months.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：联合国机构世界粮食计划署表示，将提出其历史上最大的单笔现金请求——超过 10 亿美元，以帮助为这个饱受战争之苦的国家提供大约六个月的粮食。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: Because the United States and Britain failed to get U.N. backing for the war, Russia, France, Germany and China want to ensure that the immediate humanitarian costs of the * war * are paid by the United States</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：由于美国和英国未能获得联合国对战争的支持，俄罗斯、法国、德国和中国希望确保<em>战争</em>的直接人道主义费用由美国支付</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: while we do, we want to tell you marines * battling * for control of the bridges in the southern city of nasiriyah face stiff resistance from iraqi paramilitary groups today. for some perspective, let’s turn to miles o’brien with retired air force general don shepperd.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：在我们这样做的同时，我们想告诉你们，为控制南部城市纳西里耶的桥梁而进行的海军陆战队员今天面临着伊拉克准军事组织的顽强抵抗。 为了了解一些观点，让我们转向迈尔斯·奥布莱恩和退役空军将军唐·谢珀德。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #ff666680">Text: role: place context: this is one technique, one possible way u.s. forces might * seize * a bridge, a bridge that might be defended by iraqis.</span></p><p><span style="background-color: #ff666680">Generated Question: Where did the sale take place?</span></p><p><span style="background-color: #ff666680">文本：角色：地点上下文：这是一种技术，一种可能的方式。 军队可能会夺取一座桥梁，一座可能由伊拉克人保卫的桥梁。</span></p><p><span style="background-color: #ff666680">生成的问题： 销售在哪里进行？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: they have burns in front of them. artillery behind them * firing * back.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：乐器背景：他们前面有烧伤。 他们身后的大炮<em>开火</em>还击。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #e56eee80">Text: role: attacker context: There was fierce * fighting * in Kut, to the south of Baghdad, where desperate Iraqis armed with rifles charged tanks in a suicide raid. We mowed down’’ the attackers, said Lt. Col. B.P. McCoy.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who made the attack in Kut?</span></p><p><span style="background-color: #e56eee80">文本：角色：袭击者背景：巴格达南部的库特发生了激烈的“战斗”，绝望的伊拉克人手持步枪向坦克发起自杀式袭击。 B.P. 中校说，我们击落了袭击者。 麦考伊。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁在库特发动了袭击？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: Despite declarations that more tough fighting lies ahead, the top U.S. military official indicated there may not be an all-out * battle * for Baghdad.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：尽管有声明称未来将有更艰苦的战斗，但美国高级军事官员表示，巴格达可能不会发生全面的“战斗”。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #e56eee80">Text: role: place context: Tracer rounds * lit * the night sky and artillery boomed near the airport a few kilometers (miles) from the heart of President Saddam Hussein’s capital of 5 million people.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #e56eee80">文本：角色：地点背景：曳光弹*照亮*夜空和炮火在距离萨达姆·侯赛因总统拥有500万人口的首都中心几公里（英里）的机场附近轰鸣。</span></p><p><span style="background-color: #e56eee80">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: vehicle context: Capture of the airport would give American and British troops a facility for * airlifting * equipment and troops to Baghdad.</span></p><p><span style="background-color: #5fb23680">Generated Question: What vehicle was used for transporting?</span></p><p><span style="background-color: #5fb23680">文本：角色：车辆背景：占领机场将为美国和英国军队提供一个设施，用于*空运*设备和部队到巴格达。</span></p><p><span style="background-color: #5fb23680">生成的问题： 使用什么车辆进行运输？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: Two Marines were killed and one * injured * in the close-quarters fighting in Kut.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was harmed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：在库特的近距离战斗中，两名海军陆战队员被杀，一名*受伤*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁受到伤害？</span></p><p><span style="background-color: #ffd40080">Text: role: artifact context: The overall toll of American troops dead passed 50, and Bush * visited * a Marine camp, which has lost 13 _ more than any other installation.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was transported to camp?</span></p><p><span style="background-color: #ffd40080">文本： 角色：神器 背景： 美军死亡总数已超过 50 人，布什 * 参观了 * 一个海军陆战队营地，该营地的死亡人数比任何其他设施都多 13 人。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁被运送到营地？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: God will disgrace them,’’ they said, referring to * invading * American and British troops.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：攻击者背景：上帝会羞辱他们，”他们说，指的是*入侵*美国和英国军队。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ff666680">Text: role: artifact context: To the far north, U.S. special forces and Kurdish militiamen * captured * the town of Bardarash and a nearby bridge, one of few routes into the city of Mosul near government-held oil fields.</span></p><p><span style="background-color: #ff666680">Generated Question: What did militiamen buy in Bardarash?</span></p><p><span style="background-color: #ff666680">文本：角色：神器背景：在遥远的北方，美国特种部队和库尔德民兵占领了巴达拉什镇和附近的一座桥梁，这是进入政府控制的油田附近的摩苏尔市的少数路线之一。</span></p><p><span style="background-color: #ff666680">生成的问题：民兵在巴达拉什购买了什么？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: American officials cited continuing examples of Iraqis cooperating with * invading * troops.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：美国官员列举了伊拉克人与<em>入侵</em>部队合作的持续例子。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: American and British helicopters and planes * bombed * positions in Kut, and Marines and Iraqis lobbed grenades at close quarters.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：美国和英国的直升机和飞机<em>轰炸</em>库特阵地，海军陆战队和伊拉克士兵近距离投掷手榴弹。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Between 10 and 15 Iraqis armed only with rifles charged Marine tanks in the * suicide * charge.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本： 角色： 地点 背景： 10 到 15 名仅携带步枪的伊拉克人在“自杀式”冲锋中对海军陆战队坦克发起冲锋。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: origin context: Army forces rolled past dozens of dead Iraqi soldiers and bombed-out hulks of Iraqi military equipment as they made their * way * toward Baghdad from the area around Karbala.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where was forces transported from to Baghdad?</span></p><p><span style="background-color: #5fb23680">文本：角色：起源背景：陆军从卡尔巴拉周边地区向巴格达进军时，碾过数十名阵亡的伊拉克士兵和被炸毁的伊拉克军事装备。</span></p><p><span style="background-color: #5fb23680">生成的问题：部队是从哪里运到巴格达的？</span></p><p><span style="background-color: #5fb23680">Text: role: person context: * Married * for the second time, Hariri has five children.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was married?</span></p><p><span style="background-color: #5fb23680">文本：角色：人物背景：第二次结婚，哈里里有五个孩子。</span></p><p><span style="background-color: #5fb23680">引发的问题：谁结婚了？</span></p><p><span style="background-color: #ffd40080">Text: role: instrument context: I often wondered how he was doing with all the meds because of his illness, which developed before his * paralyzing * accident.</span></p><p><span style="background-color: #ffd40080">Generated Question: What device was used to inflict the harm?</span></p><p><span style="background-color: #ffd40080">文本：角色：仪器背景：我经常想知道他是如何处理所有药物的，因为他的疾病是在他的*瘫痪*事故之前发展的。</span></p><p><span style="background-color: #ffd40080">生成的问题：使用什么设备造成伤害？</span></p><p><span style="background-color: #e56eee80">Text: role: instrument context: What I think was quite appalling from what Dana said on the Oprah show was that the doctors wanted to * pull * the life support from Chris *without her being there.</span></p><p><span style="background-color: #e56eee80">Generated Question: What device was used to kill?</span></p><p><span style="background-color: #e56eee80">文本：角色：仪器背景：我认为达娜在奥普拉节目中所说的非常令人震惊的是，医生想在克里斯不在场的情况下<em>撤回</em>克里斯的生命支持。</span></p><p><span style="background-color: #e56eee80">生成的问题： 使用什么设备进行杀人？</span></p><p><span style="background-color: #5fb23680">Text: role: person context: Re: The old * wedding * problem</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was married?</span></p><p><span style="background-color: #5fb23680">文字：角色：人物背景：回复：旧<em>婚礼</em>问题</span></p><p><span style="background-color: #5fb23680">生成的问题：谁结婚了？</span></p><p><span style="background-color: #5fb23680">Text: role: person context: For my part though, I think we started the * marriage * with a compromise and deined ourselves tremendous blessing and ultimately paid the price.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was married?</span></p><p><span style="background-color: #5fb23680">文本：角色：人物背景：但就我而言，我认为我们以妥协开始了“婚姻”，并为自己定义了巨大的祝福，并最终付出了代价。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁结婚了？</span></p><p><span style="background-color: #e56eee80">Text: role: place context: A serial killer in Wichita, Kansas who * killed * at least 8 people in the ‘70s and ‘80s.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where did killer kill people?</span></p><p><span style="background-color: #e56eee80">文本：角色：地点背景：堪萨斯州威奇托市的一名连环杀手，在 70 年代和 80 年代“杀死”了至少 8 人。</span></p><p><span style="background-color: #e56eee80">生成问题：杀手在哪里杀人？</span></p><p><span style="background-color: #e56eee80">Text: role: place context: The rich * hire * private security for a reason–public security is often inadequate.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where did the employment relationship begin?</span></p><p><span style="background-color: #e56eee80">文字：角色：地点背景：富人<em>雇用</em>私人保安是有原因的——公共安全往往不够充分。</span></p><p><span style="background-color: #e56eee80">生成的问题：雇佣关系从哪里开始？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: I believe Bind Torture * Kill * &#x3D; BTK. My point about taking so long… for thirty years people didn’t feel safe. The LE has an obligation to keep safe. I bet the neighbors are going through hell.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点上下文：我相信 Bind Torture <em>Kill</em> &#x3D; BTK。 我的观点是花了这么长时间……三十年来人们都没有感到安全。 LE 有义务保证安全。 我敢打赌邻居们正在经历地狱。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: The * war * in Iraq could last months and require considerable US military reinforcements to assure a victory, the Washington Post reported Thursday, quoting senior US military officials.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：《华盛顿邮报》周四援引美国高级军事官员的话说，伊拉克的“战争”可能会持续数月，需要大量的美国军事增援才能确保胜利。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ffd40080">Text: role: target context: The Post also quoted Central Intelligence Agency and Pentagon intelligence analysts complaining that Bush officials largely ignored their warning that Iraqi irregular forces would use guerrilla tactics and offer significant * resistance *.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #ffd40080">文字：角色：目标背景：《华盛顿邮报》还援引中央情报局和五角大楼情报分析人士的话说，布什官员在很大程度上忽视了他们的警告，即伊拉克非正规部队将使用游击战术并提供重大“抵抗”。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #ffd40080">Text: role: artifact context: Meanwhile Blair * arrived * in Washington late Wednesday for two days of talks with Bush at the Camp David presidential retreat.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was transported to Washington?</span></p><p><span style="background-color: #ffd40080">文本：角色：神器背景：与此同时，布莱尔周三晚间抵达华盛顿，在戴维营总统度假胜地与布什进行为期两天的会谈。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁被运送到华盛顿？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Britain has deployed some 45,000 troops to * fight * with the more than 250,000 US soldiers lined up against Iraqi troops.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：英国已部署约 45,000 名士兵与超过 250,000 名美国士兵列队对抗伊拉克军队。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: prosecutor context: just one day after being * charged * with a felony. he is accused of leaving the scene of a fatal accident.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who executed the indictment?</span></p><p><span style="background-color: #5fb23680">文本：角色：检察官背景：就在被 * 指控 * 重罪一天后。 他被指控离开致命事故现场。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁执行了起诉书？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: WOODRUFF An apparent friendly * fire * incident in northern Iraq is taking more of a toll on Kurdish leaders than we knew at first.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：WOODRUFF 伊拉克北部发生的一场明显的友军“开火”事件给库尔德领导人造成的损失比我们最初知道的还要严重。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: This morning, an American bomb destroyed a convoy carrying high officials of the Kurdish Peshmerga forces, which have been * fighting * alongside the Americans on the northern front.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：今天早上，一枚美国炸弹摧毁了一支载有库尔德自由斗士部队高级官员的车队，该部队一直在北部战线与美国并肩作战。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: The idea was to open the way with heavy sustained American * bombing * of Iraqi positions.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本： 角色： 目标背景： 这个想法是通过美国对伊拉克阵地的持续猛烈轰炸开辟道路。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: Here in the north, Iraqi tanks and guns are still * firing *, and the American effort is looking a little ragged.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：在北方，伊拉克的坦克和大炮仍在*开火*，而美国的努力看起来有点破烂。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #ffd40080">Text: role: artifact context: officials say the pilot reported ice on the plane and planned to * land * in massachusetts when the plane left radar.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was transported?</span></p><p><span style="background-color: #ffd40080">文本：角色：神器背景：官员称，飞行员报告飞机上结冰，并计划在飞机离开雷达后在马萨诸塞州降落。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁被运送了？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: of course there are ongoing fears about * terrorism * and a war with iraq.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：当然，人们一直担心*恐怖主义*和与伊拉克的战争。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: At least 19 people were killed and 114 people were wounded in Tuesday’s southern Philippines airport * blast *, officials said, but reports said the death toll could climb to 30.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：袭击者背景：官员称，周二菲律宾南部机场*爆炸*造成至少19人死亡、114人受伤，但有报道称死亡人数可能攀升至30人。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: The Davao Medical Center, a regional government hospital, recorded 19 deaths with 50 * wounded *.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who enacted the harm?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：达沃医疗中心是一家地区政府医院，记录了 19 人死亡、50 人受伤。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁造成了伤害？</span></p><p><span style="background-color: #ffd40080">Text: role: agent context: There were no reports of * injuries * in the second blast.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who enacted the harm?</span></p><p><span style="background-color: #ffd40080">文本：角色：特工背景：第二次爆炸中没有*受伤*的报告。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁造成了伤害？</span></p><p><span style="background-color: #5fb23680">Text: role: destination context: Television footage showed medical teams * carting * away dozens of wounded victims with fully armed troops on guard.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where was the transporting directed?</span></p><p><span style="background-color: #5fb23680">文本：角色：目的地背景：电视画面显示，医疗队在全副武装的士兵的护卫下“运走”了数十名伤者。</span></p><p><span style="background-color: #5fb23680">生成的问题：运输的方向是哪里？</span></p><p><span style="background-color: #ffd40080">Text: role: target context: hezbollah is an organization based in lebanon that has beenify dn dn been tied to terrorist * activity * and peter bergen mentioned saudi hezbollah an organization working in that country.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #ffd40080">文本：角色：目标背景：真主党是一个总部位于黎巴嫩的组织，已与恐怖分子 * 活动 * 联系在一起，彼得·伯根提到沙特真主党是一个在该国工作的组织。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #ffd40080">Text: role: origin context: we’ll watch and listening very closely to president khatami’s * visit * there in beirut, lebanon.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where did the transporting originate?</span></p><p><span style="background-color: #ffd40080">文本：角色：起源背景：我们将密切关注并密切关注哈塔米总统*访问*黎巴嫩贝鲁特。</span></p><p><span style="background-color: #ffd40080">生成的问题：运输起源于哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: destination context: MAJOR ROB MACGOWAN, ROYAL MARINES We * sent * in one of our companies of about 100 men in here this morning and we took about 12 or 13 prisoners, three or four enemy were injured and they’ve now been flown out and we’re treating them including a man who is almost dead with a gunshot wound to the chest.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where was the transporting directed?</span></p><p><span style="background-color: #5fb23680">文字：角色：目的地背景：皇家海军陆战队罗布·麦高恩少校今天早上我们派遣了一支约 100 人的连队来到这里，俘虏了大约 12 到 13 名俘虏，三到四名敌人受伤，他们’ 现在我们已经空运出去，我们正在治疗他们，其中包括一名胸部受枪伤、几乎死亡的男子。</span></p><p><span style="background-color: #5fb23680">生成的问题：运输的方向是哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: defense attorneys argue that there has been so much pretrial publicity, including an alleged confession from malvo, that this has tainted the jury pool. their more intriguing argument is that one of the * charges * against malvo is under virginia’s anti-terrorism statute and they argue that every resident of fairfax county is potentially a member of the victim’s class.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the indictment take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：辩护律师认为，审前宣传太多，包括马尔沃的供词，这玷污了陪审团。 他们更有趣的论点是，对马尔沃的指控之一是根据弗吉尼亚州的反恐法规，他们认为费尔法克斯县的每个居民都可能是受害者阶层的成员。</span></p><p><span style="background-color: #5fb23680">生成的问题：起诉发生在哪里？</span></p><p><span style="background-color: #e56eee80">Text: role: place context: that’s just one of the ten sniper * shootings * here in the greater washington area.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where did sniper make an attack?</span></p><p><span style="background-color: #e56eee80">文字：角色：地点背景：这只是大华盛顿地区发生的十起狙击手*枪击事件*之一。</span></p><p><span style="background-color: #e56eee80">生成的问题：狙击手在哪里发起攻击？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: that is especially true if you have a loved one in the * war * zone.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：如果您在*战争*区域有一个亲人，则尤其如此。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: 60 percent of the people say they’re watching the * war *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：60% 的人说他们正在观看*战争*。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: if you listen to the from’s men it sounds like the * battle * is about to begin, maybe only days from now.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：如果你听从者的话，听起来*战斗*即将开始，也许只有几天后。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: later this hour i’ll speak exclusively to cardinal pio laghi, the man dismatched by pope john paul ii to persuade president bush to avoid * war *, but we begin with reports from the united nations, the pentagon and the white house.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：这个小时晚些时候，我将专门与枢机主教皮奥·拉吉交谈，他被教皇约翰·保罗二世劝说布什总统避免*战争*，但我们从联合国的报告开始， 五角大楼和白宫。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #e56eee80">Text: role: defendant context: Enron’s principal bankers, including JP Morgan Chase and Citigroup, and along with numerous other Enron advisers, have already been * sued * by the company’s shareholders for allegedly helping the company hide debt, and they face investigations from regulators over their involvement.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was sued by shareholders?</span></p><p><span style="background-color: #e56eee80">文本：角色：被告背景：安然的主要银行家，包括摩根大通和花旗集团，以及许多其他安然顾问，已经因涉嫌帮助公司隐藏债务而被公司股东*起诉*，他们面临调查 来自监管机构的参与。</span></p><p><span style="background-color: #e56eee80">生成的问题： 谁被股东起诉？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: The excuse is invalid because I’ve been convicted on political not criminal grounds, which doesn’t violate my right for contesting the * elections *,’’ Faisal told The Associated Press.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the voting agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：这个借口无效，因为我是因政治而非刑事理由被定罪，这并不侵犯我参加*选举*的权利，”费萨尔告诉美联社。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是投票代理人？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Jordan’s electoral law bans Jordanians from contesting the polls if they were convicted of any crime, except political, and * sentenced * to more than one year in jail.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the sentencing take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：约旦选举法禁止约旦人在被判犯有政治罪以外的任何罪行的情况下参加投票，并*判处*一年以上监禁。</span></p><p><span style="background-color: #5fb23680">生成的问题： 量刑是在哪里进行的？</span></p><p><span style="background-color: #e56eee80">Text: role: place context: for a week now, protesters have been * clashing * with police and backers of the clerical regime in tehran.</span></p><p><span style="background-color: #e56eee80">Generated Question: Where did protesters make an attack?</span></p><p><span style="background-color: #e56eee80">文本：角色：地点背景：一周以来，抗议者一直在与警察和德黑兰教权政权的支持者发生冲突。</span></p><p><span style="background-color: #e56eee80">生成的问题：抗议者在哪里发动袭击？</span></p><p><span style="background-color: #e56eee80">Text: role: defendant context: michael jackson filed * suit * against universal music, the parent company of motown records saying he owe him for music he recorded with the jackson five back in the 1970s.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was sued by michael jackson?</span></p><p><span style="background-color: #e56eee80">文字：角色：被告背景：迈克尔·杰克逊对环球音乐提起诉讼，摩城唱片公司的母公司称迈克尔·杰克逊欠他 1970 年代与杰克逊五人组录制的音乐。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁被迈克尔·杰克逊起诉？</span></p><p><span style="background-color: #e56eee80">Text: role: victim context: Death of Arafat (2) PLO leader PLO leader Yasser Arafat * died * in a Paris hospital last week, after a lot of controversy surrounding his illness and death.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was killed in hospital?</span></p><p><span style="background-color: #e56eee80">文字：角色：受害者 背景：阿拉法特之死 (2) 巴解组织领导人 巴解组织领导人亚西尔·阿拉法特*上周在巴黎一家医院去世*，此前围绕他的病情和死亡引发了很多争议。</span></p><p><span style="background-color: #e56eee80">生成的问题： 谁在医院被杀？</span></p><p><span style="background-color: #5fb23680">Text: role: artifact context: Ed but it wasn’t – like, ah, wasn’t Bush, I definitely wouldn’t * send * him, I don’t think you want to have him in that part of the world right now.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was transported?</span></p><p><span style="background-color: #5fb23680">文本：角色：神器背景：艾德，但它不是——就像，啊，不是布什，我绝对不会 * 发送 * 他，我不认为你想让他出现在那个部分 现在的世界。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被运送了？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: James hundreds of years – and a lot of people have * lost * their lives, and and a lot of kids have grown up and all they’ve ever known – on both sides Israeli and Palestinian, all they’ve ever known is war.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：詹姆斯几百年了——很多人失去了生命，很多孩子已经长大了，他们所知道的一切——以色列和以色列双方 巴勒斯坦人，他们所知道的就是战争。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #ffd40080">Text: role: entity context: North Korea on Sunday rejected the U.N. Security Council’s plan to * discuss * the standoff over its suspected nuclear weapons development, calling it a prelude to war.’’</span></p><p><span style="background-color: #ffd40080">Generated Question: Who met with others?</span></p><p><span style="background-color: #ffd40080">文本：角色：实体背景：朝鲜周日拒绝了联合国安理会“讨论”其疑似核武器开发的僵局的计划，称其为战争的前奏。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁会见了其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: But KCNA quoted the spokesman as saying that the U.S. * invasion * of Iraq showed that Washington was not bound by international agreements.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：工具背景：但朝中社援引发言人的话称，美国“入侵”伊拉克表明华盛顿不受国际协议约束。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: Today the Pentagon is comparing * suicide * bombing attacks on coalition forces in Iraq to terrorism.</span></p><p><span style="background-color: #5fb23680">Generated Question: What device was used to kill?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：今天，五角大楼正在将针对伊拉克联军的“自杀式”爆炸袭击与恐怖主义进行比较。</span></p><p><span style="background-color: #5fb23680">生成的问题： 使用什么设备进行杀人？</span></p><p><span style="background-color: #e56eee80">Text: role: instrument context: Four U.S. Army soldiers were killed when a suicide bomber * attacked * a military checkpoint today in Najaf.</span></p><p><span style="background-color: #e56eee80">Generated Question: What instrument did bomber use to attack checkpoint in Najaf?</span></p><p><span style="background-color: #e56eee80">文本：角色：仪器背景：今天，一枚自杀式炸弹袭击者袭击了纳杰夫的一个军事检查站，四名美国陆军士兵丧生。</span></p><p><span style="background-color: #e56eee80">生成的问题：轰炸机使用什么工具攻击纳杰夫的检查站？</span></p><p><span style="background-color: #e56eee80">Text: role: artifact context: A man driving what appeared to be a taxicab * came * to the checkpoint, waved soldiers over, appeared to be having mechanical problems of some kind.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was transported to checkpoint?</span></p><p><span style="background-color: #e56eee80">文本：角色：神器背景：一名男子驾驶着一辆看似出租车的车辆*来到*到检查站，挥手示意士兵过来，似乎出现了某种机械问题。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁被运送到检查站？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: * This * is something that Iraqi Vice President Ramadan had said would take place.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具上下文：* 这个* 是伊拉克副总统拉马丹说过将会发生的事情。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: He reiterated today in a press conference in Baghdad that this would just be the beginning of this that they would plan on killing thousands of U.S. troops with * suicide * bombing similar to this.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文本：角色：特工背景：他今天在巴格达举行的新闻发布会上重申，这只是他们计划通过类似的“自杀式”爆炸杀死数千名美军的开始。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: Also, in southern Iraq today near Basra, two members - claimed to be members of Saddam’s Thataeen (ph) group surrendered to U.S. troops saying that they had been ordered to carry out suicide bombings down there but that they didn’t want to * die * for the regime so they were surrendering.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文本：角色：特工背景：此外，今天在伊拉克南部巴士拉附近，两名自称是萨达姆塔泰恩（Ph）组织成员的成员向美军投降，称他们奉命在那里进行自杀式爆炸，但他们 不想为政权而死，所以他们投降了。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: No * injuries * reported.</span></p><p><span style="background-color: #5fb23680">Generated Question: What device was used to inflict the harm?</span></p><p><span style="background-color: #5fb23680">文本：角色：仪器上下文：无*伤害*报告。</span></p><p><span style="background-color: #5fb23680">生成的问题：使用什么设备造成伤害？</span></p><p><span style="background-color: #ff666680">Text: role: attacker context: That story when we come back. Since marching into Iraq, coalition troops have engaged in some fierce * battles * with Saddam Hussein’s forces.</span></p><p><span style="background-color: #ff666680">Generated Question: Who attacked forces in Iraq?</span></p><p><span style="background-color: #ff666680">文本：角色：攻击者上下文：我们回来时的故事。 自从进军伊拉克以来，联军与萨达姆的军队进行了一些激烈的“战斗”。</span></p><p><span style="background-color: #ff666680">生成的问题：谁袭击了伊拉克军队？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: on april 9th, about 130 journalists from around the world including myself and a couple of reporters, we were going to try to * cross * the border because we were all desperate to get into iraq, two days after the saddam statue fell and we all knew it was over.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who is responsible for the transport event?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：4 月 9 日，来自世界各地的大约 130 名记者，包括我自己和几位记者，我们打算尝试 * 跨越 * 边境，因为我们都迫切希望进入伊拉克，两个 萨达姆雕像倒塌几天后，我们都知道一切都结束了。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁负责运输事件？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: The dictator Suharto has fallen, the constitution has changed, the media was unshackled, democratic * elections * held, and East Timor freed.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the voting agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：独裁者苏哈托倒台，宪法修改，媒体摆脱束缚，民主*选举*举行，东帝汶获得自由。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是投票代理人？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: And, currently, both have opposed the U.S.- led * war * on Iraq.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文本：角色：攻击者背景：目前，双方都反对美国领导的伊拉克战争。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #e56eee80">Text: role: victim context: Last year’s Bali bombings, which * killed * 202 people, illustrated the threat of terrorism in Indonesia.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was killed in Bali?</span></p><p><span style="background-color: #e56eee80">文本：角色：受害者背景：去年的巴厘岛爆炸案导致 202 人死亡，这说明了印度尼西亚的恐怖主义威胁。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁在巴厘岛被杀？</span></p><p><span style="background-color: #5fb23680">Text: role: beneficiary context: The United States quickly became the Southeast Asian country’s main weapons supplier, and annual arms * sales * peaked at US$400 million in the 1980s.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who benefits from the transaction?</span></p><p><span style="background-color: #5fb23680">文字：角色：受益人背景：美国迅速成为东南亚国家的主要武器供应国，年武器销售额在20世纪80年代达到峰值4亿美元。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁从交易中受益？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: Since then some in the Bush administration _ particularly Deputy Defense Secretary Paul Wolfowitz, a former ambassador to Jakarta and a prime architect of the Iraq * war * _ have pushed for the ban to be repealed.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：目标背景：此后，布什政府中的一些人，特别是国防部副部长保罗·沃尔福威茨（Paul Wolfowitz）、前驻雅加达大使和伊拉克*战争*的主要策划者，一直在推动废除该禁令。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: Currently, Indonesia uses short-range Rapier missiles purchased 30 years ago to protect its vital oil and natural gas fields in Sumatra, Borneo and Papua from air * attack *.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文字：角色：目标背景：目前，印度尼西亚使用30年前购买的短程剑杆导弹来保护其位于苏门答腊岛、婆罗洲和巴布亚的重要石油和天然气田免受空中*攻击*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: seller context: These problems multiplied when the New England chain Stop n’ Shop * acquired * Giant.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who is the selling agent?</span></p><p><span style="background-color: #5fb23680">文本： 角色： 卖家 背景： 当新英格兰连锁店 Stop n’ Shop * 收购 * Giant 时，这些问题更加严重。</span></p><p><span style="background-color: #5fb23680">生成的问题： 销售代理是谁？</span></p><p><span style="background-color: #ff666680">Text: role: person context: Who are they, and why do you think they should be * appointed *?</span></p><p><span style="background-color: #ff666680">Generated Question: Who is the employee?</span></p><p><span style="background-color: #ff666680">文本：角色：人物背景：他们是谁，您为什么认为他们应该被“任命”？</span></p><p><span style="background-color: #ff666680">生成的问题： 员工是谁？</span></p><p><span style="background-color: #ff666680">Text: role: place context: Where’s he * going * to Commerce?</span></p><p><span style="background-color: #ff666680">Generated Question: Where did the employment relationship begin?</span></p><p><span style="background-color: #ff666680">文本：角色：地点上下文：他* 要去* 商务部哪里？</span></p><p><span style="background-color: #ff666680">生成的问题：雇佣关系从哪里开始？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: President Bush points this way today, even the most frivolous of * lawsuits * cost money, premiums go up and either way, the patient pays.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the suit take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：布什总统今天指出，即使是最琐碎的*诉讼*也要花钱，保费会上涨，无论哪种方式，患者都会付出代价。</span></p><p><span style="background-color: #5fb23680">生成的问题：诉讼发生在哪里？</span></p><p><span style="background-color: #ffd40080">Text: role: entity context: If there are any bad doctors we want them * removed * from the practice of medicine.</span></p><p><span style="background-color: #ffd40080">Generated Question: Who fired employee?</span></p><p><span style="background-color: #ffd40080">文本：角色：实体上下文：如果有任何坏医生，我们希望他们从医学实践中“移除”。</span></p><p><span style="background-color: #ffd40080">生成的问题：谁解雇了员工？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: NADER Doctors are * leaving * practice because of insurance premium, right?</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the employment relationship end?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点上下文：NADER 医生因为保险费而“离开”诊所，对吗？</span></p><p><span style="background-color: #5fb23680">生成的问题：雇佣关系在哪里结束？</span></p><p><span style="background-color: #ffd40080">Text: role: place context: BUSH If harmed by a doc, they ought to be able to * recover * their economic costs, economic losses.</span></p><p><span style="background-color: #ffd40080">Generated Question: Where was the amount transferred?</span></p><p><span style="background-color: #ffd40080">文本：角色：地点背景：布什如果受到医生的伤害，他们应该能够*收回*他们的经济成本、经济损失。</span></p><p><span style="background-color: #ffd40080">生成的问题： 转账金额到哪里了？</span></p><p><span style="background-color: #e56eee80">Text: role: artifact context: Nine scanners, developed locally for military purposes, were placed at Singapore’s Changi Airport last week to check people * arriving * from SARS-affected countries.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was transported from countries?</span></p><p><span style="background-color: #e56eee80">文本：角色：文物背景：上周，新加坡樟宜机场放置了九台本地开发的用于军事目的的扫描仪，用于检查从受 SARS 影响的国家抵达的人员。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁是从其他国家被运送过来的？</span></p><p><span style="background-color: #5fb23680">Text: role: vehicle context: Any person found to be * entering * Singapore with a high temperature would be directed to a nearby nurse station for further checks.</span></p><p><span style="background-color: #5fb23680">Generated Question: What vehicle was used for transporting?</span></p><p><span style="background-color: #5fb23680">文本：角色：车辆背景：任何被发现*进入*新加坡并伴有高温的人将被引导到附近的护士站进行进一步检查。</span></p><p><span style="background-color: #5fb23680">生成的问题： 使用什么车辆进行运输？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: Immigration and Checkpoints Authority spokeswoman Ngoon Pei Ling said during the trial period the scanners would be placed at bus checkpoints, where passengers are already required to * disembark * for immigration purposes.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who is responsible for the transport event?</span></p><p><span style="background-color: #5fb23680">文本：角色：代理人背景：移民和检查站管理局发言人 Ngoon Pei Ling 表示，在试用期间，扫描仪将放置在公交车检查站，乘客已经被要求“下车”以进行移民。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁负责运输事件？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Do you think Arafat’s * death * will help or hurt the Israeli-Palestinian peace process?</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：您认为阿拉法特*之死*将有助于还是损害以巴和平进程？</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #e56eee80">Text: role: instrument context: In which, the state of Israel buys – many expensive military weapons, ah, which is used to – oppress and – to * kill * a lot of Palestinians.</span></p><p><span style="background-color: #e56eee80">Generated Question: What device was used to kill Palestinians?</span></p><p><span style="background-color: #e56eee80">文本：角色：工具背景：其中，以色列国购买了许多昂贵的军事武器，啊，这些武器用于压迫和杀死许多巴勒斯坦人。</span></p><p><span style="background-color: #e56eee80">生成的问题： 使用什么装置来杀害巴勒斯坦人？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: WOODRUFF We know that some of the American troops now * fighting * in Iraq are longtime veterans of warfare, probably not most, but some.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：WOODRUFF 我们知道，现在在伊拉克*作战*的一些美国军队是长期参加战争的退伍军人，可能不是大多数，而是一些。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: There’s nothing very pretty about the training that you take to prepare you for * combat *, because it is to kill people.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：为*战斗*做准备而进行的训练并没有什么好看的，因为它是为了杀人。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: (on camera): Did you at the time or have you since looked back and pondered on * killing * someone?</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：（镜头前）：您当时或之后是否回过头来思考*杀死*某人？</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: But I didn’t know * it * was going to bother me as much as it did.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：但我不知道 * 它 * 会像它那样困扰我。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #e56eee80">Text: role: victim context: Sergeant Chuck Hagel was seriously * wounded * twice in Vietnam.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was harmed in Vietnam?</span></p><p><span style="background-color: #e56eee80">文本：角色：受害者背景：查克·哈格尔中士在越南两次受重伤。</span></p><p><span style="background-color: #e56eee80">生成的问题：谁在越南受到伤害？</span></p><p><span style="background-color: #5fb23680">Text: role: victim context: CROWLEY Training is what keeps you running toward the front while trucks loaded with * dead * bodies pass you, going the other way.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was killed?</span></p><p><span style="background-color: #5fb23680">文本：角色：受害者背景：CROWLEY 训练可以让你跑到前面，而装载*尸体*的卡车却从你身边经过，朝相反的方向行驶。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁被杀了？</span></p><p><span style="background-color: #5fb23680">Text: role: attacker context: Rangel, Cunningham, Ridge and Hagel are all proud, decorated * combat * veterans.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the attacking agent?</span></p><p><span style="background-color: #5fb23680">文字：角色：攻击者背景：兰格尔、坎宁安、里奇和哈格尔都是骄傲的、装饰*战斗*的退伍军人。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击者？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: If they are interested in setting up a * meeting * then have them contact me at 979-777-6445 or at <a href="mailto:&#108;&#97;&#x75;&#x72;&#x6f;&#x75;&#115;&#101;&#46;&#46;&#46;&#64;&#x79;&#x61;&#104;&#x6f;&#x6f;&#46;&#x63;&#x6f;&#109;">&#108;&#97;&#x75;&#x72;&#x6f;&#x75;&#115;&#101;&#46;&#46;&#46;&#64;&#x79;&#x61;&#104;&#x6f;&#x6f;&#46;&#x63;&#x6f;&#109;</a> and I will send the info to Tori, or have them contact Tori Foster to set up a time.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who met with others?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体上下文：如果他们有兴趣建立 * 会议 *，请让他们通过 979-777-6445 或 <a href="mailto:&#108;&#97;&#x75;&#114;&#x6f;&#x75;&#x73;&#x65;&#46;&#x2e;&#46;&#x40;&#x79;&#x61;&#104;&#x6f;&#111;&#x2e;&#x63;&#x6f;&#x6d;">&#108;&#97;&#x75;&#114;&#x6f;&#x75;&#x73;&#x65;&#46;&#x2e;&#46;&#x40;&#x79;&#x61;&#104;&#x6f;&#111;&#x2e;&#x63;&#x6f;&#x6d;</a> 与我联系，我会将信息发送给 Tori， 或者让他们联系 Tori Foster 安排时间。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Iraq, however, took the report as an endorsement of its work and argued not only that * war * plans should be canceled, but that sanctions imposed on it by the Security Council for its 1990 invasion of Kuwait should be removed.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?0</span></p><p><span style="background-color: #5fb23680">文本：角色：地点 背景：然而，伊拉克将该报告视为对其工作的认可，并认为不仅应取消*战争*计划，而且还认为安理会因其1990年入侵伊拉克而对其实施制裁。 科威特应该被删除。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: origin context: Inspectors also * returned * to a former helicopter airfield where Iraq buried bombs it says were armed with biological weapons in 1991.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the transporting originate?</span></p><p><span style="background-color: #5fb23680">文本：角色：起源背景：检查人员还*返回*一个前直升机机场，伊拉克1991年在那里埋藏了炸弹，据称这些炸弹配备了生物武器。</span></p><p><span style="background-color: #5fb23680">生成的问题：运输起源于哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: But some Shiite Muslim groups boycotted the * meeting * and thousands protested nearby.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who met with others?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体背景：但一些什叶派穆斯林团体抵制*会议*，数千人在附近抗议。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: The * meeting * concluded with the delegates voting by show of hands to meet again in 10 days.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who met with others?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体上下文：* 会议* 结束，代表们通过举手表决决定在 10 天内再次举行会议。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: Tuesday’s * meeting * was the first step toward that goal after the ouster of Saddam.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who met with others?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体上下文：周二的*会议*是萨达姆被推翻后朝着这一目标迈出的第一步。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #e56eee80">Text: role: artifact context: Chalabi was the first top Iraqi opposition leader to be * airlifted * by the U.S. military into southern Iraq as the fighting wound down, and he and other top members of his group plan to meet soon in Baghdad. U.S. officials said Chalabi was brought in because he offered forces to the coalition.</span></p><p><span style="background-color: #e56eee80">Generated Question: Who was transported to Iraq by military?</span></p><p><span style="background-color: #e56eee80">文本：角色：神器背景：随着战斗的结束，沙拉比是第一位被美军空运到伊拉克南部的伊拉克反对派高级领导人，他和他的组织的其他高级成员计划很快在巴格达会面 。 美国官员表示，查拉比被引进是因为他向联军提供了部队。</span></p><p><span style="background-color: #e56eee80">生成的问题： 谁被军队运送到伊拉克？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Neither Chalabi nor many other leaders of anti-Saddam groups * attended * Tuesday’s meeting, but they sent delegates.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the meeting takes place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：查拉比和许多其他反萨达姆团体的领导人都没有出席周二的会议，但他们派出了代表。</span></p><p><span style="background-color: #5fb23680">生成的问题：会议在哪里举行？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: i wasn’t in a position that my dear friend was in when he was * killed * outside bagdad airport but i had long thought and i was in iraq in the previous war that really all the talk that had been about the rush to war, the push for war, the drive for war, all that propaganda, was essentially nonsensical because in 1990, saddam hussein made the only self criticism.</span></p><p><span style="background-color: #5fb23680">Generated Question: What device was used to kill?</span></p><p><span style="background-color: #5fb23680">文本：角色：仪器背景：当我亲爱的朋友在巴格达机场外被杀时，我并没有处于他所处的位置，但我长期以来一直认为，我在上一场战争中在伊拉克，这真的是所有的谈话 那些关于仓促发动战争、推动战争、推动战争的宣传，本质上是荒谬的，因为萨达姆·侯赛因在1990年做了唯一的自我批评。</span></p><p><span style="background-color: #5fb23680">生成的问题： 使用什么设备进行杀人？</span></p><p><span style="background-color: #5fb23680">Text: role: instrument context: i wasn’t in a position that my dear friend was in when he was killed outside bagdad airport but i had long thought and i was in iraq in the previous war that really all the talk that had been about the rush to war, the push for war, the drive for * war *, all that propaganda, was essentially nonsensical because in 1990, saddam hussein made the only self criticism.</span></p><p><span style="background-color: #5fb23680">Generated Question: What instrument was used in the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：工具背景：当我亲爱的朋友在巴格达机场外被杀时，我并没有处于他所处的位置，但我一直在想，而且我在上一场战争中在伊拉克，这确实是所有关于的话题 急于发动战争、推动战争、推动“战争”，所有这些宣传本质上都是荒谬的，因为萨达姆·侯赛因在1990年做了唯一的自我批评。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击中使用了什么工具？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: the little town i was in this southern iraq, as far as i got, i can’t boast of further, is where the * talks * took place.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who met with others?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体上下文：据我所知，我在伊拉克南部的那个小镇，我无法进一步夸耀，它就是 * 会谈 * 发生的地方。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁见过其他人？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: who have been horribly * murdered * and tortured and reduced to misery since by a half application of violence through sanctions and overflights.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：自从一半通过制裁和飞越使用暴力以来，他们遭到可怕的*谋杀*和酷刑，并陷入痛苦。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: entity context: 2005-01-05T16:32:00 Much like the “I told you so’s” everyone is throwing at the UGA basketball program after their hiring and subsequent * firing * of The Harricks, folks around the Buckeye state have to be having similar thoughts.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who fired employee?</span></p><p><span style="background-color: #5fb23680">文本：角色：实体上下文：2005-01-05T16:32:00 就像“我告诉过你是这样的”，每个人在雇用哈里克夫妇并随后*解雇*后都向佐治亚大学篮球计划扔东西，周围的人 七叶树州也一定有类似的想法。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁解雇了员工？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Of course, it was discovered that his men’s basketball coach had directly * given * six grand to a Yugoslavian recruit, but that was just his stipend for travel and coach Jim O’Brien was just having a problem with the currency exchange rates…right Andy?</span></p><p><span style="background-color: #5fb23680">Generated Question: Where was the amount transferred?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：当然，人们发现他的男篮教练直接给了一名南斯拉夫新兵*六块钱，但这只是他的旅行津贴，而教练吉姆·奥布莱恩只是在 货币汇率问题……对安迪吗？</span></p><p><span style="background-color: #5fb23680">生成的问题： 转账金额到哪里了？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: He looked for the gunshot wounds for the knife * stabbing *, and there is no injury whatsoever.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the attack take place?</span></p><p><span style="background-color: #5fb23680">文字：角色：地点背景：他寻找刀*刺伤*的枪伤，没有任何伤害。</span></p><p><span style="background-color: #5fb23680">生成的问题：攻击发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: QUESTION If those weren’t gunshot wounds to cause the broken bones, do they know what caused the * fractures *?</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the injuring take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：问题如果这些不是枪伤导致骨折，他们知道是什么导致*骨折*吗？</span></p><p><span style="background-color: #5fb23680">生成的问题：受伤发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: target context: ozzy’s wife reportedly got into a * fight * with hollywood agent renee tab.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the target of the attack?</span></p><p><span style="background-color: #5fb23680">文本：角色：目标背景：据报道，奥兹的妻子与好莱坞经纪人蕾妮·塔布发生了*争吵*。</span></p><p><span style="background-color: #5fb23680">生成的问题：谁是攻击的目标？</span></p><p><span style="background-color: #5fb23680">Text: role: agent context: The submarine was on an exercise when the accident occurred, and because of a mechanical malfunction, the 70 crew members on board * died *,’’ the Xinhua report said.</span></p><p><span style="background-color: #5fb23680">Generated Question: Who was the killer?</span></p><p><span style="background-color: #5fb23680">文字：角色：特工背景：事故发生时该潜艇正在演习，由于机械故障，船上70名船员*死亡*，”新华社报道称。</span></p><p><span style="background-color: #5fb23680">产生的问题：谁是凶手？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: There have been rumors going around about the loss of submarines, but this is the first * fatal * accident that I know of,’’ said Cole.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：一直有关于潜艇损失的谣言，但这是我所知道的第一起“致命”事故，”科尔说。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><p><span style="background-color: #5fb23680">Text: role: place context: Cole said the * loss * of all hands suggested the vessel was flooded or sank because of a collision or engineering problem.</span></p><p><span style="background-color: #5fb23680">Generated Question: Where did the death take place?</span></p><p><span style="background-color: #5fb23680">文本：角色：地点背景：科尔表示，所有人员的*损失*表明该船因碰撞或工程问题而被淹没或沉没。</span></p><p><span style="background-color: #5fb23680">生成的问题：死亡发生在哪里？</span></p><h2 id="4-3-t5-arg-predictions"><a href="#4-3-t5-arg-predictions" class="headerlink" title="4.3 t5_arg_predictions"></a>4.3 t5_arg_predictions</h2><h2 id="4-4-evaluate-e2e-predicted-triggers-t5"><a href="#4-4-evaluate-e2e-predicted-triggers-t5" class="headerlink" title="4.4 evaluate_e2e_predicted_triggers_t5"></a>4.4 evaluate_e2e_predicted_triggers_t5</h2><h1 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h1><ul><li><strong>模板局限性</strong>：非常模板化，好像没有论文中提到的山丘与地点的具象</li><li><strong>其他部分</strong>：相较于整个问答系统来说，问题生成的质量，或者说问题生成导致的错误示例仅是一部分，问题回答也有</li><li><strong>事件背景信息</strong>：事件背景信息编码到生成的问题可能优于设计的动态模板</li><li><strong>90%是模板（模板错用、不同触发器用同一个模板），完全错误（提问不相干，可能是模板选错）、少量包含上下文信息的10左右，1条非常完美与论文符合。</strong></li></ul><h1 id="6-改进"><a href="#6-改进" class="headerlink" title="6. 改进"></a>6. 改进</h1><p>一共有三个大语言模型，命名实体识别模型为事件参数提取模型提供了基础信息，帮助构建更好的模板，进而更好的事件参数提取</p><p><img src="/../imgs/$%7Bfiilename%7D/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E6%AF%95%E8%AE%BE.drawio.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E6%AF%95%E8%AE%BE.drawio.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="软件开发-毕设.drawio"></p><h1 id="1-代码功能标注"><a href="#1-代码功能标注" class="headerlink" title="1.代码功能标注"></a>1.代码功能标注</h1><h2 id="1-1-load-py"><a href="#1-1-load-py" class="headerlink" title="1.1 load.py"></a>1.1 load.py</h2><h3 id="1-1-1-class-AceExample-object"><a href="#1-1-1-class-AceExample-object" class="headerlink" title="1.1.1 class AceExample(object)"></a>1.1.1 class AceExample(object)</h3><p>这段代码定义了一个名为AceExample的类，用于表示ACE数据集中的单个训练&#x2F;测试样本。让我们逐句分析其作用：</p><ol><li><p><code>class AceExample(object):</code></p><ul><li>定义了一个名为AceExample的类，用于表示ACE数据集中的单个训练&#x2F;测试样本。</li></ul></li><li><p><code>def __init__(self, sentence, events, s_start, tokens, trigger_label, char_offset):</code></p><ul><li>定义了该类的初始化方法（构造函数），用于初始化类的实例（对象）。</li><li>方法参数包括sentence, events, s_start, tokens, trigger_label, char_offset等属性，用于接收训练&#x2F;测试样本的各个属性值。</li></ul></li><li><p><code>self.sentence = sentence</code></p><ul><li>将传入的sentence参数赋值给类的实例变量self.sentence。</li></ul></li><li><p><code>self.events = events</code></p><ul><li>将传入的events参数赋值给类的实例变量self.events。</li></ul></li><li><p><code>self.s_start = s_start</code></p><ul><li>将传入的s_start参数赋值给类的实例变量self.s_start。</li></ul></li><li><p><code>self.tokens = tokens</code></p><ul><li>将传入的tokens参数赋值给类的实例变量self.tokens。</li></ul></li><li><p><code>self.trigger_label = trigger_label</code></p><ul><li>将传入的trigger_label参数赋值给类的实例变量self.trigger_label。</li></ul></li><li><p><code>self.char_offset = char_offset</code></p><ul><li>将传入的char_offset参数赋值给类的实例变量self.char_offset。</li></ul></li><li><p><code>def __str__(self):</code></p><ul><li>定义了该类的__str__方法，用于返回对象的字符串表达形式。</li><li>在这里，调用了__repr__方法来实现具体的字符串表达形式。</li></ul></li><li><p><code>def __repr__(self):</code></p></li></ol><ul><li>定义了该类的__repr__方法，用于返回对象的规范字符串表示形式。</li><li>在这里，根据对象的属性值构建了一个字符串表示，并返回该字符串。</li></ul><p>这段代码定义了一个用于存储ACE数据集中单个训练&#x2F;测试样本的类，通过初始化方法将属性值赋予类的实例变量，并提供了字符串表示形式的方法，便于对样本进行输出和展示。</p><h3 id="1-1-2-class-InputFeatures-trigger-object"><a href="#1-1-2-class-InputFeatures-trigger-object" class="headerlink" title="1.1.2 class InputFeatures_trigger(object)"></a>1.1.2 class InputFeatures_trigger(object)</h3><p>这段代码定义了一个名为InputFeatures_trigger的类，该类用于表示数据的单个特征集合。</p><ol><li><p><code>class InputFeatures_trigger(object):</code></p><ul><li>定义了一个名为InputFeatures_trigger的类，它是一个对象类（object）。这个类用于表示数据的特征集合。</li></ul></li><li><p><code>def __init__(self, example_id, tokens, input_ids, segment_ids, mask_ids, labels, trigger_masks, sub_type):</code></p><ul><li>定义了该类的初始化方法（构造函数），用于初始化类的实例（对象）。</li><li>方法参数包括example_id, tokens, input_ids, segment_ids, mask_ids, labels, trigger_masks, sub_type等属性，用于接收特征集合的各个属性值。</li></ul></li><li><p><code>self.example_id = example_id</code></p><ul><li>将传入的example_id参数赋值给类的实例变量self.example_id。</li></ul></li><li><p><code>self.tokens = tokens</code></p><ul><li>将传入的tokens参数赋值给类的实例变量self.tokens。</li></ul></li><li><p><code>self.input_ids = input_ids</code></p><ul><li>将传入的input_ids参数赋值给类的实例变量self.input_ids。</li></ul></li><li><p><code>self.mask_ids = mask_ids</code></p><ul><li>将传入的mask_ids参数赋值给类的实例变量self.mask_ids。</li></ul></li><li><p><code>self.segment_ids = segment_ids</code></p><ul><li>将传入的segment_ids参数赋值给类的实例变量self.segment_ids。</li></ul></li><li><p><code>self.trigger_masks = trigger_masks</code></p><ul><li>将传入的trigger_masks参数赋值给类的实例变量self.trigger_masks。</li></ul></li><li><p><code>self.sub_type = sub_type</code></p><ul><li>将传入的sub_type参数赋值给类的实例变量self.sub_type。</li></ul></li><li><p><code>self.labels = labels</code></p><ul><li>将传入的labels参数赋值给类的实例变量self.labels。</li></ul></li></ol><p>这段代码定义了一个用于存储特征集合的类，通过初始化方法将特征集合的各个属性值赋予类的实例变量，使得可以方便地对特征集合进行存储和管理。</p><h3 id="1-1-3-class-InputFeatures-arg-t5-object"><a href="#1-1-3-class-InputFeatures-arg-t5-object" class="headerlink" title="1.1.3 class InputFeatures_arg_t5(object)"></a>1.1.3 class InputFeatures_arg_t5(object)</h3><h4 id="1-1-3-1-def-load-template-t5-input-doc"><a href="#1-1-3-1-def-load-template-t5-input-doc" class="headerlink" title="1.1.3.1 def load_template_t5(input_doc)"></a>1.1.3.1 def load_template_t5(input_doc)</h4><p>这段代码是一个函数，名为load_template_t5，用于加载ACE数据集的动态模板。让我逐步解释它的作用：</p><ol><li><p><code>def load_template_t5(input_doc):</code></p><ul><li>定义了一个函数load_template_t5，接受一个名为input_doc的参数，该参数是用于指定ACE数据集的输入文档。</li></ul></li><li><p><code>data_dic = &#123;&#125;</code></p><ul><li>创建了一个空字典data_dic，用于存储加载的动态模板数据。</li></ul></li><li><p><code>main_type = None</code>和<code>sub_type = None</code></p><ul><li>初始化了main_type和sub_type两个变量为None。</li></ul></li><li><p><code>with open(input_doc) as fd:</code></p><ul><li>打开指定的输入文档，并使用文件句柄fd来操作文件内容。</li></ul></li><li><p><code>rd = csv.reader(fd, delimiter=&quot;\t&quot;, quotechar=&#39;&quot;&#39;)</code></p><ul><li>使用csv模块创建了一个CSV文件读取器rd，指定了分隔符为制表符”\t”，引用字符为双引号’”‘。</li></ul></li><li><p><code>for row in rd:</code></p><ul><li>对读取器rd中的每一行进行迭代。</li></ul></li><li><p><code>if rd_index == 0: ... continue</code></p><ul><li>如果当前行是第一行（索引为0），则跳过该行（continue），因为这一行通常是标题行，不包含有效数据。</li></ul></li><li><p><code>if row[0].strip() != &quot;&quot;: ...</code></p><ul><li>如果当前行的第一个单元格不为空（去除首尾空白后），则将其作为main_type，创建一个对应的空字典，并将其加入data_dic中。</li></ul></li><li><p><code>if row[1].strip() != &quot;&quot;: ...</code></p><ul><li>如果当前行的第二个单元格不为空（去除首尾空白后），则将其作为sub_type，创建一个对应的空字典，并将其加入data_dic[main_type]中。</li></ul></li><li><p>接下来的代码段落主要是根据输入文档中的内容，构建了一个嵌套的字典数据结构，用于存储ACE数据集中的动态模板信息，包括角色、问题等。</p></li><li><p>最后，函数返回了整理好的data_dic字典数据，其中包含了从输入文档中加载的动态模板信息。</p></li></ol><p>总的来说，这段代码的作用是从指定的输入文档中加载ACE数据集的动态模板信息，并以字典的形式返回整理好的数据结构。</p><h4 id="1-1-3-2-def-load-sentences-path"><a href="#1-1-3-2-def-load-sentences-path" class="headerlink" title="1.1.3.2 def load_sentences(path)"></a>1.1.3.2 def load_sentences(path)</h4><p>这段代码定义了一个函数load_sentences，用于加载ACE数据集中的句子信息。让我逐步解释它的作用：</p><ol><li><p><code>def load_sentences(path):</code></p><ul><li>定义了一个函数load_sentences，接受一个名为path的参数，该参数是用于指定ACE数据集句子信息文件的路径。</li></ul></li><li><p><code>examples = []</code></p><ul><li>创建了一个空列表examples，用于存储加载的句子信息。</li></ul></li><li><p><code>with open(path) as f:</code></p><ul><li>打开指定的句子信息文件，并使用文件句柄f来操作文件内容。</li></ul></li><li><p><code>lines = f.readlines()</code></p><ul><li>使用readlines()方法读取文件中的所有行，并将其存储在列表lines中。</li></ul></li><li><p><code>for line in lines:</code></p><ul><li>对lines列表中的每一行进行迭代。</li></ul></li><li><p><code>line = json.loads(line)</code></p><ul><li>将当前行解析为JSON格式，并将解析结果存储在变量line中。</li></ul></li><li><p>提取line中的相关字段，包括token_list、s_start和events等。</p></li><li><p>根据line中是否包含”tokens”字段判断是否存在更详细的标记信息，如果存在，则提取tokens、trigger_label和char_offset字段。</p></li><li><p>创建AceExample对象example，将从line中提取的信息作为参数传递给构造函数。</p></li><li><p>将example添加到examples列表中。</p></li><li><p>最后，函数返回整理好的examples列表，其中包含了从句子信息文件中加载的句子信息。</p></li></ol><p>总的来说，这段代码的作用是从指定的句子信息文件中加载ACE数据集的句子信息，并将其整理为AceExample对象的列表形式返回。</p><h4 id="1-1-3-3-def-convert-examples-to-features-sequence"><a href="#1-1-3-3-def-convert-examples-to-features-sequence" class="headerlink" title="1.1.3.3 def convert_examples_to_features_sequence()"></a>1.1.3.3 def convert_examples_to_features_sequence()</h4><p>这段代码定义了一个函数convert_examples_to_features_sequence，用于将ACE数据集中的句子信息转换为模型的输入特征。让我逐步解释它的作用：</p><ol><li><p><code>def convert_examples_to_features_sequence(examples, tokenizer, category_to_index, lower_case=False):</code></p><ul><li>定义了一个函数convert_examples_to_features_sequence，接受四个参数，分别是AceExample对象的列表examples、tokenizer、分类到索引的字典category_to_index和是否将单词转换为小写的标志lower_case。</li></ul></li><li><p>创建了一些空列表和变量，用于存储特征。</p></li><li><p>对于每个从ACE数据集中读取的例子，将其tokens和trigger_label提取出来。</p></li><li><p>创建一个空字典offset_category，并在其中存储所有非”O”标签的偏移量和标签对应的映射关系。</p></li><li><p>初始化tokens、segment_ids、mask_ids、labels和trigger_masks等列表。</p></li><li><p>将[CLS]标记添加到tokens列表中，并将其对应的segment_id设置为0，mask_id设置为1，label设置为-100，trigger_mask设置为0。</p></li><li><p>对于原始tokens中的每个单词，如果设置了lower_case标志，则将其转换为小写。</p></li><li><p>使用tokenizer.tokenize()方法将单词拆分为子单词，并迭代每个子单词。</p></li><li><p>将子单词添加到tokens列表中，并在segment_ids列表中加入0，在mask_ids列表中加入1。</p></li><li><p>如果当前子单词是当前单词的第一个子单词，将trigger_masks列表中对应的位置标记为1。</p></li><li><p>如果当前单词的偏移量在offest_category字典中，则将其对应的标签添加到labels列表中；否则，将0添加到labels列表中。</p></li><li><p>如果当前子单词不是当前单词的第一个子单词，则在trigger_masks列表中对应的位置设置为0，并将-100添加到labels列表中。</p></li><li><p>将[SEP]标记添加到tokens列表中，并将其对应的segment_id设置为0，mask_id设置为1，label设置为-100，trigger_mask设置为0。</p></li><li><p>将tokens列表中的子单词转换为input_ids列表中的数字ID。</p></li><li><p>将input_ids、segment_ids、mask_ids、labels、trigger_masks和feature_index等信息添加到对应的列表中。</p></li><li><p>创建一个InputFeatures_trigger对象one_feature，并将从上述步骤中提取的特征作为参数传递给其构造函数。</p></li><li><p>将one_feature添加到features列表中，并将feature_index加1。</p></li><li><p>将所有特征列表all_input_ids、all_segment_ids、all_mask_ids、all_labels、all_feature_index和all_trigger_masks作为参数传递给Event_trigger_dataset对象的构造函数，创建一个BucketDataset类型的数据集bucket_dataset。</p></li><li><p>函数返回bucket_dataset和features两个结果。</p></li></ol><p>总的来说，这段代码的作用是将ACE数据集中的句子信息转换为模型的输入特征并打包成数据集bucket_dataset的形式返回。</p><h4 id="1-1-3-4-def-normalize-ace-arg-arg-role-event-type"><a href="#1-1-3-4-def-normalize-ace-arg-arg-role-event-type" class="headerlink" title="1.1.3.4 def normalize_ace_arg(arg_role, event_type)"></a>1.1.3.4 def normalize_ace_arg(arg_role, event_type)</h4><p>这段代码定义了一个函数normalize_ace_arg，用于修正ACE数据集中的论证角色（argument role）的不一致问题。让我逐步解释它的作用：</p><ol><li><p><code>def normalize_ace_arg(arg_role, event_type):</code></p><ul><li>定义了一个函数normalize_ace_arg，接受两个参数，分别是论证角色arg_role和事件类型event_type。</li></ul></li><li><p>对于每个事件类型，根据特定的条件修正对应的论证角色。具体的修正规则如下：</p><ul><li>如果事件类型是”Personnel.Elect”且论证角色是”Entity”，则将论证角色修正为”Agent”。</li><li>如果事件类型是”Justice.Appeal”且论证角色是”Plaintiff”，则将论证角色修正为”Defendant”。</li><li>如果事件类型是”Life.Die”且论证角色是”Person”，则将论证角色修正为”Victim”。</li><li>如果事件类型是”Conflict.Attack”且论证角色是”Victim”，则将论证角色修正为”Target”。</li><li>如果事件类型是”Conflict.Attack”且论证角色是”Agent”，则将论证角色修正为”Attacker”。</li><li>如果事件类型是”Movement.Transport”且论证角色是”Victim”，则将论证角色修正为”Artifact”。</li><li>如果事件类型是”Movement.Transport”且论证角色是”Place”，则将论证角色修正为”Destination”。</li></ul></li><li><p>返回修正后的论证角色。</p></li></ol><p>总的来说，这段代码的作用是根据ACE数据集中的事件类型和论证角色，修正不一致的论证角色标注，并返回修正后的论证角色。</p><h4 id="1-1-3-5-def-is-whitespace-c"><a href="#1-1-3-5-def-is-whitespace-c" class="headerlink" title="1.1.3.5 def is_whitespace(c)"></a>1.1.3.5 def is_whitespace(c)</h4><p>这段代码定义了一个函数is_whitespace，用于判断给定的字符是否为空白字符。让我逐步解释它的作用：</p><ol><li><p><code>def is_whitespace(c):</code></p><ul><li>定义了一个函数is_whitespace，接受一个参数c，即待判断的字符。</li></ul></li><li><p>使用条件语句判断字符c是否为空白字符。</p><ul><li>如果字符c是空格、制表符、回车符、换行符或特定Unicode码点（0x202F）表示的空白字符，则返回True。</li><li>否则，返回False。</li></ul></li></ol><p>总的来说，这段代码的作用是判断给定的字符是否为空白字符，如果是则返回True，否则返回False。</p><h4 id="1-1-3-6-def-my-collate-trigger-train-batch"><a href="#1-1-3-6-def-my-collate-trigger-train-batch" class="headerlink" title="1.1.3.6 def my_collate_trigger_train(batch)"></a>1.1.3.6 def my_collate_trigger_train(batch)</h4><p>这段代码定义了一个函数my_collate_trigger_train，用于对触发词训练数据进行批处理的操作。让我逐步解释它的作用：</p><ol><li><p>初始化一些空列表和变量：</p><ul><li>list_input_ids：用于存储输入的token id序列。</li><li>list_token_type_ids：用于存储token的类型id序列。</li><li>list_attention_masks：用于存储attention mask序列。</li><li>list_trigger_labels：用于存储触发词标签序列。</li><li>list_sentence_id：用于存储句子id序列。</li><li>list_trigger_masks：用于存储触发词mask序列。</li><li>max_len：用于记录当前batch中最长的输入序列长度。</li></ul></li><li><p>遍历batch中的每个样本，并进行以下操作：</p><ul><li>获取样本的输入序列input_ids和当前长度cur_len。</li><li>将input_ids补齐到最长长度max_len，并添加到list_input_ids中。</li><li>将样本的token类型序列token_type_ids补齐到最长长度max_len，并添加到list_token_type_ids中。</li><li>将样本的attention mask序列attention_masks补齐到最长长度max_len，并添加到list_attention_masks中。</li><li>将样本的触发词标签序列trigger_labels补齐到最长长度max_len，并添加到list_trigger_labels中。</li><li>将样本的句子id添加到list_sentence_id中。</li><li>将样本的触发词mask序列trigger_masks补齐到最长长度max_len，并添加到list_trigger_masks中。</li></ul></li><li><p>将列表转换为PyTorch的Tensor张量：</p><ul><li>将list_input_ids转换为LongTensor类型，赋值给input_ids_tensor。</li><li>将list_token_type_ids转换为LongTensor类型，赋值给token_type_ids_tensor。</li><li>将list_attention_masks转换为LongTensor类型，赋值给attention_masks_tensor。</li><li>将list_trigger_labels转换为LongTensor类型，赋值给trigger_labels_tensor。</li><li>将list_trigger_masks转换为LongTensor类型，赋值给trigger_masks_tensor。</li><li>将list_sentence_id转换为LongTensor类型，赋值给sentence_id_tensor。</li></ul></li><li><p>返回批处理后的张量元组，顺序为：<br>input_ids_tensor,<br>trigger_labels_tensor,<br>attention_masks_tensor,<br>token_type_ids_tensor,<br>sentence_id_tensor,<br>trigger_masks_tensor</p></li></ol><p>总的来说，这段代码的作用是对触发词训练数据进行批处理，将输入序列、触发词标签、attention mask等转换为PyTorch的Tensor张量，并补齐序列长度到当前batch中最长的长度。返回的张量元组可以直接作为训练模型的输入。</p><h4 id="1-1-3-7-def-my-collate-qg-train-t5-batch"><a href="#1-1-3-7-def-my-collate-qg-train-t5-batch" class="headerlink" title="1.1.3.7 def my_collate_qg_train_t5(batch)"></a>1.1.3.7 def my_collate_qg_train_t5(batch)</h4><p>这段代码定义了一个函数my_collate_qg_train_t5，用于对T5模型的生成式问答训练数据进行批处理的操作。让我逐步解释它的作用：</p><ol><li><p>初始化一些空列表和变量：</p><ul><li>list_input_ids：用于存储输入的token id序列。</li><li>list_attention_masks：用于存储attention mask序列。</li><li>list_output_ids：用于存储输出的token id序列。</li><li>list_feature_idx：用于存储特征索引序列。</li><li>max_len_input：用于记录当前batch中最长的输入序列长度。</li><li>max_len_output：用于记录当前batch中最长的输出序列长度。</li></ul></li><li><p>遍历batch中的每个样本，并进行以下操作：</p><ul><li>获取样本的输入序列input_ids、attention mask序列和输出序列output_ids的长度cur_len_input、cur_len_output。</li><li>将input_ids补齐到最长长度max_len_input，并添加到list_input_ids中。</li><li>将attention mask序列补齐到最长长度max_len_input，并添加到list_attention_masks中。</li><li>将output_ids补齐到最长长度max_len_output，并添加到list_output_ids中。</li><li>将特征索引添加到list_feature_idx中。</li></ul></li><li><p>将列表转换为PyTorch的Tensor张量：</p><ul><li>将list_input_ids转换为LongTensor类型，赋值给input_ids_tensor。</li><li>将list_attention_masks转换为LongTensor类型，赋值给attention_masks_tensor。</li><li>将list_output_ids转换为LongTensor类型，赋值给output_ids_tensor。</li><li>将列表中值为0的元素设置为-100，用于T5模型的训练损失计算。</li><li>将list_feature_idx转换为LongTensor类型，赋值给feature_idx_tensor。</li></ul></li><li><p>返回批处理后的张量元组，顺序为：<br>input_ids_tensor,<br>attention_masks_tensor,<br>output_ids_tensor,<br>feature_idx_tensor</p></li></ol><p>总的来说，这段代码的作用是对T5模型的生成式问答训练数据进行批处理，将输入序列、输出序列、attention mask等转换为PyTorch的Tensor张量，并补齐序列长度到当前batch中最长的长度。返回的张量元组可以直接作为训练模型的输入。</p><h4 id="1-1-3-8-def-my-collate-qg-train-bart-batch"><a href="#1-1-3-8-def-my-collate-qg-train-bart-batch" class="headerlink" title="1.1.3.8 def my_collate_qg_train_bart(batch)"></a>1.1.3.8 def my_collate_qg_train_bart(batch)</h4><p>这段代码定义了一个函数my_collate_qg_train_bart，用于对BART模型的生成式问答训练数据进行批处理的操作。让我逐步解释它的作用：</p><ol><li><p>初始化一些空列表和变量：</p><ul><li>pad_id：定义了填充符的id。</li><li>list_input_ids：用于存储输入的token id序列。</li><li>list_attention_masks：用于存储attention mask序列。</li><li>list_output_ids：用于存储输出的token id序列。</li><li>list_feature_idx：用于存储特征索引序列。</li><li>max_len_input：用于记录当前batch中最长的输入序列长度。</li><li>max_len_output：用于记录当前batch中最长的输出序列长度。</li></ul></li><li><p>第一个遍历batch中的每个样本，并获取最长的输入序列长度max_len_input和输出序列长度max_len_output。</p></li><li><p>第二个遍历batch中的每个样本，并进行以下操作：</p><ul><li>获取样本的输入序列input_ids、attention mask序列和输出序列output_ids的长度cur_len_input、cur_len_output。</li><li>将input_ids补齐到最长长度max_len_input，并添加到list_input_ids中。</li><li>将attention mask序列补齐到最长长度max_len_input，并添加到list_attention_masks中。</li><li>将output_ids补齐到最长长度max_len_output，并添加到list_output_ids中。</li><li>将特征索引添加到list_feature_idx中。</li></ul></li><li><p>将列表转换为PyTorch的Tensor张量：</p><ul><li>将list_input_ids转换为LongTensor类型，赋值给input_ids_tensor。</li><li>将list_attention_masks转换为LongTensor类型，赋值给attention_masks_tensor。</li><li>将list_output_ids转换为LongTensor类型，赋值给output_ids_tensor。</li><li>将列表中值为0的元素设置为-100，用于BART模型的训练损失计算。</li><li>将list_feature_idx转换为LongTensor类型，赋值给feature_idx_tensor。</li></ul></li><li><p>返回批处理后的张量元组，顺序为：<br>input_ids_tensor,<br>attention_masks_tensor,<br>output_ids_tensor,<br>feature_idx_tensor</p></li></ol><p>总的来说，这段代码的作用是对BART模型的生成式问答训练数据进行批处理，将输入序列、输出序列、attention mask等转换为PyTorch的Tensor张量，并补齐序列长度到当前batch中最长的长度。返回的张量元组可以直接作为训练模型的输入。</p><h4 id="1-1-3-9-def-convert-examples-to-features-qg"><a href="#1-1-3-9-def-convert-examples-to-features-qg" class="headerlink" title="1.1.3.9 def convert_examples_to_features_qg()"></a>1.1.3.9 def convert_examples_to_features_qg()</h4><p>这段代码的作用是将输入的示例转换为特征，用于问题生成（Question Generation）任务。以下是代码的详细分析：</p><ol><li><p>代码定义了一个名为<code>convert_examples_to_features_qg</code>的函数，接受四个参数：<code>examples</code>（示例列表）、<code>tokenizer</code>（分词器）、<code>query_templates</code>（查询模板）、<code>lower_case</code>（是否转换为小写）。函数返回转换后的特征数据集。</p></li><li><p>初始化一些空列表，用于存储所有的输入ID、目标ID、掩码ID和特征索引。</p></li><li><p>使用两个嵌套的循环遍历示例列表中的每个示例及其事件。</p></li><li><p>获取事件类型、主要事件类型、子事件类型、触发词和参数。</p></li><li><p>根据查询模板中的配置，生成针对目标参数类型的查询。</p></li><li><p>初始化一个字典<code>query_dic</code>，用于存储查询。</p></li><li><p>遍历参数列表，获取其他参数角色，并将其添加到<code>other_role_set</code>中。</p></li><li><p>检查目标参数角色是否在事件中被提及。</p></li><li><p>调用<code>generate_questions_with_contextual_args</code>函数生成带有上下文参数的查询。</p></li><li><p>根据参数个数，使用不同的阈值调用<code>template_fill_in</code>函数填充模板查询。这部分代码被注释掉了，因此不会执行。</p></li><li><p>在查询字典中选择具有最多上下文参数的模板作为训练查询。如果目标参数角色未在示例中提及，则选择基本模板。</p></li><li><p>针对每个训练查询，构建目标文本和输入文本，并使用分词器对其进行编码。</p></li><li><p>将编码后的输入ID、掩码ID、目标ID和特征索引添加到相应的列表中。</p></li><li><p>创建一个<code>QG_dataset</code>对象，将所有的输入ID、掩码ID、目标ID和特征索引传入。</p></li><li><p>返回数据集对象。</p></li></ol><p>总体来说，这段代码的作用是将输入的示例转换为适合问题生成任务的特征数据集，其中包含了输入文本、目标文本和相关信息。</p><h4 id="1-1-3-10-def-template-fill-in"><a href="#1-1-3-10-def-template-fill-in" class="headerlink" title="1.1.3.10  def template_fill_in()"></a>1.1.3.10  def template_fill_in()</h4><p>这段代码是一个递归函数，名为<code>template_fill_in</code>，用于填充模板。</p><p>函数接受多个输入参数，包括参数列表（<code>arguments</code>），起始索引（<code>start_idx</code>），角色个数（<code>num_role</code>），事件类型（<code>event_type</code>），其他角色集合（<code>other_role_set</code>），已找到的其他参数列表（<code>found_other_arg_list</code>），已找到的其他角色列表（<code>found_other_role_list</code>），角色映射（<code>role_mapping</code>），查询模板（<code>query_templates</code>），目标参数类型（<code>target_argument_type</code>），查询字典（<code>query_dic</code>），以及阈值参数（<code>threshold_arg</code>）。</p><p>函数的目的是根据输入的参数信息，填充查询模板，生成具体的查询语句。</p><p>具体来说，函数的主要步骤如下：</p><ol><li>在参数列表中遍历每个参数，从起始索引开始。</li><li>获取当前参数的角色，并将其转换为标准化的角色名称。</li><li>根据事件类型和标准化的角色名称，判断是否需要跳过该参数。</li><li>检查标准化的角色名称是否在其他角色集合中，如果不在则跳过该参数。</li><li>将当前参数添加到已找到的其他参数列表和角色列表中。</li><li>如果角色个数大于1，则递归调用<code>template_fill_in</code>函数，继续填充其他参数。</li><li>当角色个数减为1时，表示达到了阈值参数个数，开始构建查询语句。</li><li>根据已找到的其他参数列表的角色索引，选择相应的查询模板，并替换其中的参数占位符。</li><li>将生成的查询语句添加到查询字典中。</li><li>弹出已找到的其他参数列表和角色列表的最后一个元素，以便继续填充其他参数。</li><li>返回最终的已找到的其他参数列表、已找到的其他角色列表和查询字典。</li></ol><p>需要注意的是，该函数通过递归的方式实现了对不同参数组合的填充，最终生成完整的查询语句。</p><p>总之，该函数的作用是根据输入的参数信息，填充查询模板，生成具体的查询语句。</p><p>这段代码是一个递归函数，根据一系列参数和条件，生成查询语句。下面是逐句分析：</p><ol><li><p><code>for sub_idx in range(start_idx + 1, len(arguments)):</code>：通过循环遍历输入的参数列表，从指定的<code>start_idx</code>开始。</p></li><li><p><code>cur_argument = arguments[sub_idx]</code>：获取当前索引<code>sub_idx</code>处的参数。</p></li><li><p><code>argument_role = cur_argument[2]</code>：从参数中获取角色信息。</p></li><li><p><code>normalized_argument_role = normalize_ace_arg(argument_role, event_type)</code>：通过调用<code>normalize_ace_arg</code>函数，对角色进行规范化处理。</p></li><li><p><code>if event_type == &quot;Contact.Phone-Write&quot; and normalized_argument_role == &quot;Place&quot;:</code>：检查事件类型是否为”Contact.Phone-Write”，且规范化后的角色是否为”Place”，如果是，则跳过当前循环。</p></li><li><p><code>if normalized_argument_role not in other_role_set:</code>：检查规范化后的角色是否在给定的<code>other_role_set</code>中，如果不在，则跳过当前循环。</p></li><li><p><code>cur_argument[2] = normalized_argument_role</code>：将当前参数的角色更新为规范化后的角色。</p></li><li><p><code>if cur_argument in found_other_arg_list:</code>：如果当前参数已经在已找到的参数列表<code>found_other_arg_list</code>中，则跳过当前循环。</p></li><li><p><code>if role_mapping[normalized_argument_role] in found_other_role_list:</code>：如果规范化后的角色对应的映射在已找到的角色列表<code>found_other_role_list</code>中，则跳过当前循环。</p></li><li><p><code>else:</code>：如果以上条件都不满足，则执行以下操作：</p><ul><li><p><code>found_other_arg_list.append(cur_argument)</code>：将当前参数添加到已找到的参数列表。</p></li><li><p><code>found_other_role_list.append(role_mapping[normalized_argument_role])</code>：将规范化后的角色对应的映射添加到已找到的角色列表。</p></li><li><p><code>if num_role - 1 &gt; 0:</code>：检查剩余的角色数量是否大于0，如果是，则递归调用<code>template_fill_in</code>函数。</p></li><li><p><code>found_other_arg_list.pop()</code>和<code>found_other_role_list.pop()</code>：递归结束后，将最后添加的参数和角色移除。</p></li><li><p><code>else:</code>：如果剩余的角色数量为0，则执行以下操作：</p><ul><li><p><code>assert len(found_other_arg_list) == threshold_arg</code>：确保已找到的参数列表的长度等于阈值<code>threshold_arg</code>。</p></li><li><p><code>found_other_arg_index_list = [role_mapping[x[2]] for x in found_other_arg_list]</code>：获取已找到的参数对应的角色映射。</p></li><li><p><code>found_other_arg_index_list.sort(key=lambda x: x)</code>：对角色映射进行排序。</p></li><li><p><code>found_other_arg_index_list = [str(x) for x in found_other_arg_index_list]</code>：将角色映射转换为字符串格式。</p></li><li><p>通过索引获取查询模板，并替换其中的参数占位符。</p></li><li><p><code>query_dic[str(threshold_arg)].append(query)</code>：将生成的查询语句添加到结果字典中。</p></li><li><p><code>found_other_arg_list.pop()</code>和<code>found_other_role_list.pop()</code>：将最后添加的参数和角色移除。</p></li></ul></li></ul></li><li><p><code>return found_other_arg_list, found_other_role_list, query_dic</code>：返回已找到的参数列表、角色列表和生成的查询语句字典。</p></li></ol><h4 id="1-1-3-11-def-convert-examples-to-features-qa-用了QG-checkpoint"><a href="#1-1-3-11-def-convert-examples-to-features-qa-用了QG-checkpoint" class="headerlink" title="1.1.3.11 def convert_examples_to_features_qa(用了QG checkpoint)"></a>1.1.3.11 def convert_examples_to_features_qa(用了QG checkpoint)</h4><p>该函数的作用是将输入的examples转换为模型需要的特征数据集。</p><p>参数解析：</p><ul><li>examples: 输入的样本列表。</li><li>tokenizer: 分词器，用于对文本进行分词和编码。</li><li>query_templates: 查询模板，包含了不同事件类型和参数类型的查询模板。</li><li>nth_query: 指定使用查询模板中的第几个查询。</li><li>is_training: 是否为训练模式。</li><li>multi_arg: 是否为多参数模式。</li><li>qg_model: 问题生成模型，用于生成问题。</li><li>na_format: 未找到答案时的格式。</li><li>transformer_name: 使用的transformer模型名称。</li><li>qg_length_penalty: 问题生成模型的长度惩罚因子。</li><li>lower_case: 是否将文本转换为小写。</li><li>qa_inf_batch_size: 问题回答推理的批次大小。</li><li>qg_num_beams: 问题生成模型的beam搜索数量。</li></ul><p>函数主要步骤：</p><ol><li>定义存储特征数据的列表和字典。</li><li>遍历每个样本和事件。</li><li>根据查询模板和事件类型生成问题，并根据问题生成模型生成问题的编码。</li><li>如果是训练模式，将问题、上下文和答案编码后加入特征数据集。</li><li>如果是推理模式，将问题的输入编码加入特征数据集。</li><li>将特征数据集转换为数据加载器，并通过问题生成模型生成问题。</li><li>更新特征数据集中的问题编码。</li><li>返回特征数据集和特征列表。</li></ol><p>这段代码看起来是用于生成问题（Question Generation）的部分。以下是逐行的解析：</p><ol><li><p><code>qg_model.eval()</code>: 将模型置于评估模式，这表示模型不会进行梯度计算。</p></li><li><p><code>for idx, batch in enumerate(query_dataset_loader):</code>: 遍历查询数据集加载器的批次。</p></li><li><p><code>input_ids, input_mask, example_indices = batch</code>: 从批次中提取输入ID、输入掩码和示例索引。</p></li><li><p><code>input_ids = input_ids.cuda()</code>: 将输入ID移至GPU。</p></li><li><p><code>input_mask = input_mask.cuda()</code>: 将输入掩码移至GPU。</p></li><li><p><code>with torch.no_grad():</code>: 在这个上下文中，禁用梯度计算。</p></li><li><p><code>outputs = qg_model.generate(...)</code>：使用模型生成问题。这里使用了模型的<code>generate</code>方法，通过传递输入ID和输入掩码，以及一些生成问题时的参数，如<code>num_beams</code>、<code>early_stopping</code>和<code>length_penalty</code>。生成的结果存储在<code>outputs</code>中。</p></li><li><p><code>for i, example_index in enumerate(example_indices):</code>: 遍历批次中的示例索引。</p></li><li><p><code>example_index = example_index.cpu().item()</code>: 将示例索引移回CPU。</p></li><li><p><code>if example_index not in input_text_dic: continue</code>: 如果示例索引不在<code>input_text_dic</code>中，则跳过当前循环。</p></li><li><p><code>pre_answer = qg_tokenizer.decode(outputs[i], skip_special_tokens=True)</code>: 将生成的回答解码为文本。这里使用了模型的tokenizer的<code>decode</code>方法。</p></li><li><p><code>pre_answer = pre_answer.strip()</code>: 去除生成的回答中的空白字符。</p></li><li><p>构建输入文本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">input_text = <span class="string">&quot;question: %s in * %s * event? context: %s &lt;/s&gt;&quot;</span> % (</span><br><span class="line">    pre_answer[:-<span class="number">1</span>],</span><br><span class="line">    input_text_dic[example_index],</span><br><span class="line">    examples[cur_feature.example_id].sentence,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>构建了一个包含问题、上下文的输入文本。这似乎是<strong>为了重新输入生成的问题，以获得更多的上下文信息</strong>。</p></li><li><p><code>if lower_case: input_text = input_text.lower()</code>: 如果<code>lower_case</code>为True，则将输入文本转换为小写。</p></li><li><p><code>input_encodings = tokenizer.encode_plus(input_text)</code>: 使用tokenizer对输入文本进行编码。</p></li><li><p>更新特征和输入ID、输入掩码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_features[example_index].input_ids = input_ids</span><br><span class="line">all_features[example_index].input_mask = input_mask</span><br><span class="line"></span><br><span class="line">all_input_ids[example_index] = input_ids</span><br><span class="line">all_mask_ids[example_index] = input_mask</span><br></pre></td></tr></table></figure></li><li><p>构建<code>QA_dataset</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bucket_dataset = QA_dataset(</span><br><span class="line">    all_input_ids, all_mask_ids, all_target_ids, all_feature_idex</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用构建的输入ID、输入掩码、目标ID和特征索引构建<code>QA_dataset</code>对象。</p></li></ol><p>这段代码的目的似乎是使用模型生成问题，然后将生成的问题重新输入模型，以获取更多的上下文信息，并构建一个新的数据集（<code>QA_dataset</code>）。</p><p>【举例】</p><p>在这个上下文中，生成问题后，作者通过将生成的问题重新构造成一个新的输入文本，将其输入到模型中。这样做的目的可能是为了获取与生成问题相关的更多上下文信息，以便模型能够更全面地理解问题并生成更准确的回答。</p><p>举个例子，假设原始的输入文本是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;event: John attended the conference. context: The conference was about artificial intelligence.&quot;</span><br></pre></td></tr></table></figure><p>生成的问题是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;question: What did John do in the conference? context: John attended the conference. The conference was about artificial intelligence.&quot;</span><br></pre></td></tr></table></figure><p>重新构造后的输入文本可能是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;question: What did John do in the conference? context: John attended the conference. The conference was about artificial intelligence. &lt;/s&gt;&quot;</span><br></pre></td></tr></table></figure><p>在这个例子中，重新构造的输入文本将生成的问题放在了新的上下文环境中，并且添加了<code>&lt;/s&gt;</code>标记，可能是为了表示输入的结束。这样做的目的可能是为了确保生成的问题在模型中得到充分的上下文支持，以便更好地理解问题的语境并生成准确的答案。</p><p>【举例】</p><p>当生成问题后，将其重新构造成一个新的输入文本是为了结合原始上下文和生成的问题，以创建一个更为完整的输入，希望通过这种方式能够提供更多的信息给模型。让我们通过一个更详细的例子来解释：</p><p>假设原始上下文是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;event: John attended the conference. context: The conference was about artificial intelligence.&quot;</span><br></pre></td></tr></table></figure><p>生成的问题是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;question: What was the topic of the conference? context: John attended the conference. The conference was about artificial intelligence.&quot;</span><br></pre></td></tr></table></figure><p>现在，我们将生成的问题重新构造成一个新的输入文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;question: What was the topic of the conference? context: John attended the conference. The conference was about artificial intelligence. &lt;/s&gt;&quot;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们将生成的问题放回原始上下文中，并通过<code>&lt;/s&gt;</code>标记表示输入的结束。这个新的输入文本包含了原始上下文、生成的问题以及一个额外的结束标记。这样做的目的是向模型提供一个更丰富的输入，希望通过将生成的问题与原始上下文结合起来，模型能够更好地理解问题的语境，提高问题生成的质量。</p><p>在实际应用中，这种操作可能是为了引入生成的问题以及相关上下文，以更好地控制问题的语义和逻辑，从而改善模型对问题的生成能力。</p><h4 id="1-1-3-12-def-my-collate-qa-t5-batch"><a href="#1-1-3-12-def-my-collate-qa-t5-batch" class="headerlink" title="1.1.3.12 def my_collate_qa_t5(batch)"></a>1.1.3.12 def my_collate_qa_t5(batch)</h4><p>这段代码是一个自定义的数据处理函数，用于将输入的批量数据转换为模型训练或推理所需的Tensor格式。</p><p>函数的输入参数为一个批量数据的列表，其中每个元素是一个样本，包含输入特征、注意力掩码、输出特征和特征索引。</p><p>函数首先初始化了一些空列表和变量，用于存储转换后的特征数据和特征索引。然后，通过遍历批量数据，逐个处理每个样本。</p><p>在处理样本时，函数会根据输入特征和输出特征的长度，计算出当前样本的最大长度，并将所有样本的最大长度记录下来。</p><p>然后，函数将输入特征进行填充，使其长度与最大长度一致，并将填充后的结果添加到输入特征列表中。</p><p>接着，函数将注意力掩码进行填充，使其长度与最大长度一致，并将填充后的结果添加到注意力掩码列表中。</p><p>类似地，函数将输出特征进行填充，使其长度与最大长度一致，并将填充后的结果添加到输出特征列表中。</p><p>最后，函数将特征索引列表转换为Tensor格式，并返回输入特征Tensor、注意力掩码Tensor、输出特征Tensor和特征索引Tensor。</p><p>需要注意的是，在输出特征Tensor中，将所有填充位置的值设置为-100，这是因为在T5模型中，-100被用作忽略损失的标记。</p><h4 id="1-1-3-13-def-my-collate-qa-bart-batch"><a href="#1-1-3-13-def-my-collate-qa-bart-batch" class="headerlink" title="1.1.3.13 def my_collate_qa_bart(batch)"></a>1.1.3.13 def my_collate_qa_bart(batch)</h4><p>这段代码定义了一个名为<code>my_collate_qa_bart</code>的函数，用于将一个批次的样本整理成BART模型所需的张量格式。</p><p>函数首先遍历一次批次，找到输入序列和输出序列的最大长度，以便进行填充操作。然后，对于每个样本，将输入序列、注意力掩码和输出序列进行填充，使它们的长度与最大长度相同。同时，将样本对应的特征索引添加到列表中。</p><p>最后，将填充后的输入序列、注意力掩码、输出序列和特征索引转换为PyTorch张量，并返回。</p><p>这段代码与之前提到的<code>my_collate_qa_t5</code>函数非常相似，都是用于整理模型训练数据的函数。主要区别在于填充的数值不同，以及使用的模型不同（一个是T5模型，一个是BART模型）。</p><p>需要注意的是，这段代码中使用了<code>torch</code>库，因此需要确保已经正确导入了<code>torch</code>。</p><h4 id="1-1-3-14-def-my-collate-qa-inference-t5-batch"><a href="#1-1-3-14-def-my-collate-qa-inference-t5-batch" class="headerlink" title="1.1.3.14 def my_collate_qa_inference_t5(batch)"></a>1.1.3.14 def my_collate_qa_inference_t5(batch)</h4><p>这段代码定义了一个名为<code>my_collate_qa_inference_t5</code>的函数，用于将一个批次的样本整理成T5模型推断所需的张量格式。</p><ul><li><code>pad_id = 0</code>: 定义填充值的数值为0。</li><li><code>list_input_ids = []</code>: 定义一个空列表，用于存储填充后的输入序列。</li><li><code>list_attention_masks = []</code>: 定义一个空列表，用于存储填充后的注意力掩码。</li><li><code>list_feature_idx = []</code>: 定义一个空列表，用于存储每个样本对应的特征索引。</li><li><code>max_len = 0</code>: 定义一个变量，用于存储批次中最长的输入序列的长度。</li></ul><p>接下来通过两个for循环遍历每个样本：</p><ul><li>第一个for循环计算批次中最长的输入序列的长度，以便进行填充操作。</li><li>第二个for循环对于每个样本，将输入序列和注意力掩码进行填充，使它们的长度与最大长度相同。同时，将样本对应的特征索引添加到列表中。</li></ul><p>填充使用的是0值进行补齐，因为T5模型的tokenizer中默认的填充值是0。</p><p>最后，将填充后的输入序列、注意力掩码和特征索引转换为PyTorch张量，并返回。返回的三个张量分别是填充后的输入序列、注意力掩码和特征索引。这些张量可以直接输入到T5模型中进行推断。</p><p>需要注意的是，这段代码中使用了<code>torch</code>库，因此需要确保已经正确导入了<code>torch</code>。</p><h4 id="1-1-3-15-def-my-collate-qa-inference-bart-batch"><a href="#1-1-3-15-def-my-collate-qa-inference-bart-batch" class="headerlink" title="1.1.3.15 def my_collate_qa_inference_bart(batch)"></a>1.1.3.15 def my_collate_qa_inference_bart(batch)</h4><p>这段代码定义了一个名为<code>my_collate_qa_inference_bart</code>的函数，用于将一个批次的样本整理成BART模型推断所需的张量格式。</p><ul><li><code>pad_id = 1</code>: 定义填充值的数值为1。</li><li><code>list_input_ids = []</code>: 定义一个空列表，用于存储填充后的输入序列。</li><li><code>list_attention_masks = []</code>: 定义一个空列表，用于存储填充后的注意力掩码。</li><li><code>list_feature_idx = []</code>: 定义一个空列表，用于存储每个样本对应的特征索引。</li><li><code>max_len = 0</code>: 定义一个变量，用于存储批次中最长的输入序列的长度。</li></ul><p>接下来通过两个for循环遍历每个样本：</p><ul><li>第一个for循环计算批次中最长的输入序列的长度，以便进行填充操作。</li><li>第二个for循环对于每个样本，将输入序列和注意力掩码进行填充，使它们的长度与最大长度相同。同时，将样本对应的特征索引添加到列表中。</li></ul><p>填充使用的是1值进行补齐，因为BART模型的tokenizer中默认的填充值是1。</p><p>最后，将填充后的输入序列、注意力掩码和特征索引转换为PyTorch张量，并返回。返回的三个张量分别是填充后的输入序列、注意力掩码和特征索引。这些张量可以直接输入到BART模型中进行推断。</p><p>需要注意的是，这段代码中使用了<code>torch</code>库，因此需要确保已经正确导入了<code>torch</code>。</p><h4 id="1-1-3-16-def-generate-questions-with-contextual-args"><a href="#1-1-3-16-def-generate-questions-with-contextual-args" class="headerlink" title="1.1.3.16 def generate_questions_with_contextual_args()"></a>1.1.3.16 def generate_questions_with_contextual_args()</h4><p>该函数的作用是生成带有上下文参数的问题。具体而言，它接受如下参数：</p><ul><li>query_dic：一个字典，用于存储生成的问题。</li><li>num_args：一个整数，表示要在问题中使用的参数数量。</li><li>role_mapping：一个字典，将事件类型中的角色映射到模板中的角色。</li><li>target_argument_type：一个字符串，表示目标参数类型的事件角色。</li><li>arguments：一个字典，表示事件类型中的参数。</li><li>event_type：一个字符串，表示事件类型。</li><li>other_role_set：一个集合，其中包含与事件类型中的其他参数对应的角色。</li><li>query_templates：一个列表，其中包含要用于生成问题的模板。</li></ul><p>函数首先检查num_args是否大于等于1，如果是，则设置threshold_arg为1，将query_dic的键值对“1”初始化为空列表，将found_other_arg_list和found_other_role_list分别初始化为空列表和[target_argument_type]，并调用template_fill_in函数填充模板。 </p><p>然后，函数检查num_args是否大于等于2，如果是，则设置threshold_arg为2，将query_dic的键值对“2”初始化为空列表，将found_other_arg_list和found_other_role_list分别初始化为空列表和[target_argument_type]，并再次调用template_fill_in函数填充模板。</p><p>然后，函数继续检查num_args是否大于等于3和4，如果是，则按照类似的方式设置threshold_arg，调用template_fill_in函数填充模板。</p><p>最后，函数检查num_args是否小于6，并断言它是真的，然后返回query_dic字典，其中包含生成的问题。</p><h2 id="1-2-processors-py"><a href="#1-2-processors-py" class="headerlink" title="1.2 processors.py"></a>1.2 processors.py</h2><h3 id="1-2-1-def-load-data"><a href="#1-2-1-def-load-data" class="headerlink" title="1.2.1 def load_data()"></a>1.2.1 def load_data()</h3><p>这段代码定义了一个名为<code>load_data</code>的方法，用于加载训练、开发、测试和（可选的）黄金标准数据集。以下是代码的逐行解释：</p><ol><li><p>**<code>def load_data(self, train_path, dev_path, test_path, gold_path=None):</code>**：定义了一个名为<code>load_data</code>的方法，该方法接受四个参数，分别是训练数据路径（<code>train_path</code>）、开发数据路径（<code>dev_path</code>）、测试数据路径（<code>test_path</code>）和（可选的）黄金标准数据路径（<code>gold_path</code>）。</p></li><li><p>**<code>self.train_samples = loader.load_sentences(train_path)</code>**：使用名为<code>loader</code>的对象的<code>load_sentences</code>方法加载训练数据，并将结果存储在类属性<code>train_samples</code>中。</p></li><li><p>**<code>self.dev_samples = loader.load_sentences(dev_path)</code>**：使用<code>loader</code>对象的<code>load_sentences</code>方法加载开发数据，并将结果存储在类属性<code>dev_samples</code>中。</p></li><li><p>**<code>self.test_samples = loader.load_sentences(test_path)</code>**：使用<code>loader</code>对象的<code>load_sentences</code>方法加载测试数据，并将结果存储在类属性<code>test_samples</code>中。</p></li><li><p>**<code>if gold_path:</code>**：检查是否提供了黄金标准数据路径。</p><ul><li>**<code>self.gold_samples = loader.load_sentences(gold_path)</code>**：如果提供了黄金标准数据路径，使用<code>loader</code>对象的<code>load_sentences</code>方法加载黄金标准数据，并将结果存储在类属性<code>gold_samples</code>中。</li></ul></li></ol><p>这段代码的作用是将训练、开发、测试和（可选的）黄金标准数据加载到相应的类属性中。这样，在后续的代码中，可以通过访问这些属性来获取加载的数据。具体数据的结构和格式将取决于<code>loader</code>对象的<code>load_sentences</code>方法的实现。</p><h3 id="1-2-2-def-generate-vocab-self-files-list"><a href="#1-2-2-def-generate-vocab-self-files-list" class="headerlink" title="1.2.2 def generate_vocab(self, files_list)"></a>1.2.2 def generate_vocab(self, files_list)</h3><p>这段代码定义了一个名为<code>generate_vocab</code>的方法，用于生成一个词汇表（vocabulary）。以下是代码的逐行解释：</p><ol><li><p>**<code>def generate_vocab(self, files_list):</code>**：定义了一个名为<code>generate_vocab</code>的方法，该方法接受一个参数<code>files_list</code>，其中包含多个文件的路径。</p></li><li><p>**<code>self.category_to_index = dict()</code>**：创建一个空的字典，用于存储事件类型到索引的映射。</p></li><li><p>**<code>self.index_to_category = dict()</code>**：创建一个空的字典，用于存储索引到事件类型的映射。</p></li><li><p>**<code>self.counter_event = Counter()</code>**：创建一个空的计数器，用于统计每个事件类型的出现次数。</p></li><li><p><strong><code>self.category_to_index[&quot;O&quot;] = 0</code></strong> 和 **<code>self.index_to_category[0] = &quot;O&quot;</code>**：将”O”（表示非事件）添加到映射中，索引为0。</p></li><li><p>**<code>for file in files_list:</code>**：遍历传入的文件列表。</p><ul><li><p>**<code>with open(file) as f:</code>**：打开文件，使用<code>f</code>作为文件句柄。</p><ul><li><p>**<code>for line in f:</code>**：遍历文件的每一行。</p><ul><li><p>**<code>example = json.loads(line)</code>**：将每一行解析为 JSON 格式。</p></li><li><p>**<code>labels = example[&quot;trigger_label&quot;]</code>**：获取当前例子的触发标签。</p></li><li><p>**<code>for label in labels:</code>**：遍历触发标签列表。</p><ul><li><p>**<code>if label == &quot;O&quot;: continue</code>**：如果标签为”O”（非事件），则跳过当前循环。</p></li><li><p>**<code>event_type = label</code>**：将标签作为事件类型。</p></li><li><p>**<code>self.counter_event[event_type] += 1</code>**：对相应事件类型的计数加一。</p></li><li><p>**<code>if event_type not in self.category_to_index:</code>**：检查事件类型是否已存在于映射中。</p><ul><li><p>**<code>index = len(self.category_to_index)</code>**：如果不存在，则为当前事件类型分配一个新的索引。</p></li><li><p>**<code>self.category_to_index[event_type] = index</code>**：将事件类型到索引的映射添加到字典中。</p></li><li><p>**<code>self.index_to_category[index] = event_type</code>**：将索引到事件类型的映射添加到字典中。</p></li></ul></li></ul></li></ul></li></ul></li></ul></li></ol><p>这段代码的目的是从给定的文件中读取 JSON 格式的例子，并生成一个事件类型的词汇表。词汇表包括每个事件类型到索引的映射，以及索引到事件类型的映射。同时，使用计数器来统计每个事件类型的出现次数。生成的信息存储在对象的属性中。</p><h3 id="1-2-3-def-construct-dataset-trigger"><a href="#1-2-3-def-construct-dataset-trigger" class="headerlink" title="1.2.3 def construct_dataset_trigger()"></a>1.2.3 def construct_dataset_trigger()</h3><p>这段代码定义了一个名为<code>construct_dataset_trigger</code>的方法，该方法用于构建触发词（trigger）的数据集。以下是代码的逐行解释：</p><ol><li><p>**<code>self.train_dataset, self.train_features = convert_examples_to_features_sequence(...)</code>**：使用名为<code>convert_examples_to_features_sequence</code>的函数将训练数据（<code>self.train_samples</code>）转换为适用于训练的特征集（<code>self.train_features</code>）和数据集（<code>self.train_dataset</code>）。这个过程可能涉及将文本序列转换为模型可接受的输入格式，使用了给定的tokenizer和事件类型到索引的映射。</p></li><li><p>**<code>self.dev_dataset, self.dev_features = convert_examples_to_features_sequence(...)</code>**：类似地，将开发数据转换为适用于开发的特征集和数据集。</p></li><li><p>**<code>self.test_dataset, self.test_features = convert_examples_to_features_sequence(...)</code>**：类似地，将测试数据转换为适用于测试的特征集和数据集。</p></li><li><p>**<code>self.tokenizer = tokenizer</code>**：将tokenizer存储在对象的属性中。</p></li><li><p><strong>数据加载器的设置</strong>：</p><ul><li>**<code>self.train_dataset_loader</code>**：使用<code>torch.utils.data.DataLoader</code>创建一个训练数据的加载器，指定批次大小、是否打乱数据、是否丢弃最后一个不完整的批次，并指定数据的处理函数<code>my_collate_trigger_train</code>。</li><li>**<code>self.dev_dataset_loader</code>**：类似地，为开发数据创建加载器。</li><li>**<code>self.test_dataset_loader</code>**：为测试数据创建加载器。</li></ul></li><li><p><strong>返回值</strong>：返回训练、开发和测试数据的加载器，以便在后续的训练和评估中使用。</p></li></ol><p>这段代码的主要目的是将原始数据转换为适用于模型训练的特征和数据集，并设置对应的数据加载器。这通常是在深度学习中准备数据以供模型训练的一般步骤。</p><h3 id="1-2-4-def-construct-dataset-qa"><a href="#1-2-4-def-construct-dataset-qa" class="headerlink" title="1.2.4 def construct_dataset_qa()"></a>1.2.4 def construct_dataset_qa()</h3><p>这段代码定义了一个名为<code>construct_dataset_qa</code>的方法，该方法用于构建问答（QA）任务的数据集。以下是代码的逐行解释：</p><ol><li><p>**<code>self.train_dataset, self.train_features = convert_examples_to_features_qa(...)</code>**：使用名为<code>convert_examples_to_features_qa</code>的函数将训练数据（<code>self.train_samples</code>）转换为适用于训练的特征集（<code>self.train_features</code>）和数据集（<code>self.train_dataset</code>）。这个过程可能涉及将文本序列转换为模型可接受的输入格式，使用了给定的tokenizer和问题模板等参数。</p></li><li><p>**<code>self.dev_dataset, self.dev_features = convert_examples_to_features_qa(...)</code>**：类似地，将开发数据转换为适用于开发的特征集和数据集。</p></li><li><p>**<code>self.test_dataset, self.test_features = convert_examples_to_features_qa(...)</code>**：类似地，将测试数据转换为适用于测试的特征集和数据集。</p></li><li><p>**<code>self.tokenizer = tokenizer</code>**：将tokenizer存储在对象的属性中。</p></li><li><p><strong>打印信息</strong>：使用<code>logger.info</code>打印训练、开发和测试数据集的样本数量信息。</p></li><li><p><strong>数据加载器的设置</strong>：</p><ul><li>如果模型名称中包含”t5”，则使用<code>t5</code>特定的数据加载器（<code>my_collate_qa_t5</code>）。</li><li>否则，使用<code>bart</code>特定的数据加载器（<code>my_collate_qa_bart</code>）。</li></ul></li><li><p><strong>返回值</strong>：返回训练、开发和测试数据的加载器，以便在后续的训练和评估中使用。</p></li></ol><p>这段代码的主要目的是将原始QA数据转换为适用于模型训练的特征和数据集，并设置对应的数据加载器。其中，可能还包括了问题生成模型（<code>qg_model</code>）的使用以及一些其他与QA任务相关的特殊处理。</p><h3 id="1-2-5-def-construct-dataset-qg"><a href="#1-2-5-def-construct-dataset-qg" class="headerlink" title="1.2.5  def construct_dataset_qg()"></a>1.2.5  def construct_dataset_qg()</h3><p>这段代码定义了一个名为<code>construct_dataset_qg</code>的方法，该方法用于构建问题生成（QG）任务的数据集。以下是代码的逐行解释：</p><ol><li><p>**<code>self.train_dataset = convert_examples_to_features_qg(...)</code>**：使用名为<code>convert_examples_to_features_qg</code>的函数将训练数据（<code>self.train_samples</code>）转换为适用于训练的数据集（<code>self.train_dataset</code>）。这个过程可能涉及将文本序列转换为模型可接受的输入格式，使用了给定的tokenizer和问题模板等参数。</p></li><li><p>**<code>self.dev_dataset = convert_examples_to_features_qg(...)</code>**：类似地，将开发数据转换为适用于开发的数据集。</p></li><li><p>**<code>self.test_dataset = convert_examples_to_features_qg(...)</code>**：类似地，将测试数据转换为适用于测试的数据集。</p></li><li><p>**<code>self.tokenizer = tokenizer</code>**：将tokenizer存储在对象的属性中。</p></li><li><p><strong>数据加载器的设置</strong>：</p><ul><li>如果模型名称中包含”t5”，则使用<code>t5</code>特定的数据加载器（<code>my_collate_qg_train_t5</code>）。</li><li>否则，使用<code>bart</code>特定的数据加载器（<code>my_collate_qg_train_bart</code>）。</li></ul></li><li><p><strong>返回值</strong>：返回训练、开发和测试数据的加载器，以便在后续的训练和评估中使用。</p></li></ol><p>这段代码的主要目的是将原始问题生成数据转换为适用于模型训练的数据集，并设置对应的数据加载器。其中，可能还包括了问题生成模型（<code>qg_model</code>）的使用以及一些其他与问题生成任务相关的特殊处理。</p><h2 id="1-3-LabelSmoother-py"><a href="#1-3-LabelSmoother-py" class="headerlink" title="1.3  LabelSmoother.py"></a>1.3  LabelSmoother.py</h2><p>这个名为<code>LabelSmoother</code>的类实现了对来自Transformers模型的预计算输出进行标签平滑。标签平滑是一种正则化技术，用于在分类问题中，不是将概率1分配给真实类别，而是分配一个小概率（epsilon）给所有类别，包括真实类别。这有助于防止过拟合，使模型更加健壮。</p><p>让我们逐步解析这个类的关键组成部分：</p><ol><li><p><strong><code>epsilon</code> 和 <code>ignore_index</code> 属性:</strong></p><ul><li><code>epsilon: float = 0.1</code>: 这是标签平滑因子，默认为0.1。</li><li><code>ignore_index: int = -100</code>: 这是在计算损失时要忽略的标签索引，默认为-100。</li></ul></li><li><p><strong><code>__call__</code> 方法:</strong></p><ul><li><code>__call__(self, model_output, labels)</code>: 当类的实例像函数一样被调用时，将调用这个方法。</li><li><code>model_output</code> 是来自Transformers模型的预计算输出。</li><li><code>labels</code> 是实际标签。</li></ul></li><li><p><strong>处理模型输出:</strong></p><ul><li><code>logits = model_output[&quot;logits&quot;] if isinstance(model_output, dict) else model_output[0]</code>: 从模型输出中提取logits。</li><li><code>log_probs = -nn.functional.log_softmax(logits, dim=-1)</code>: 使用log-softmax函数计算log概率。</li></ul></li><li><p><strong>处理标签维度:</strong></p><ul><li>如果<code>labels</code>的维度比<code>log_probs</code>少一维，使用<code>labels = labels.unsqueeze(-1)</code>添加新维度。</li></ul></li><li><p><strong>填充掩码:</strong></p><ul><li><code>padding_mask = labels.eq(self.ignore_index)</code>: 为标签等于<code>ignore_index</code>的位置创建掩码。</li><li><code>labels = torch.clamp(labels, min=0)</code>: 将负标签替换为0。</li></ul></li><li><p><strong>计算损失:</strong></p><ul><li><code>nll_loss = log_probs.gather(dim=-1, index=labels)</code>: 收集真实标签的负对数似然损失。</li><li><code>smoothed_loss = log_probs.sum(dim=-1, keepdim=True, dtype=torch.float32)</code>: 计算log概率的总和。</li></ul></li><li><p><strong>掩码损失:</strong></p><ul><li><code>nll_loss.masked_fill_(padding_mask, 0.0)</code>: 对填充位置的NLL损失进行掩码。</li><li><code>smoothed_loss.masked_fill_(padding_mask, 0.0)</code>: 对填充位置的平滑损失进行掩码。</li></ul></li><li><p><strong>计算最终损失:</strong></p><ul><li>计算标签维度上损失的均值。</li><li>除以活动元素的数量（非填充的元素）。</li><li>返回使用标签平滑因子<code>epsilon</code>对NLL损失和平滑损失进行加权求和的结果。</li></ul></li></ol><p>总之，这个类在训练过程中对模型输出应用标签平滑，以改善泛化能力并防止过拟合。标签平滑由<code>epsilon</code>参数控制，<code>ignore_index</code>参数处理在损失计算中应忽略的标签。</p><h2 id="1-4-evaluate-py"><a href="#1-4-evaluate-py" class="headerlink" title="1.4 evaluate.py"></a>1.4 evaluate.py</h2><h3 id="1-4-1-def-evaluate-qa"><a href="#1-4-1-def-evaluate-qa" class="headerlink" title="1.4.1 def evaluate_qa()"></a>1.4.1 def evaluate_qa()</h3><p>这段代码定义了一个用于评估QA模型的函数<code>evaluate_qa</code>。以下是代码的逐行解释：</p><ol><li><p><strong>导入库</strong>：</p><ul><li><code>collections</code>：Python标准库中的<code>collections</code>模块，用于创建有序字典。</li><li><code>torch</code>：PyTorch深度学习框架。</li><li><code>copy</code>：用于进行深拷贝。</li></ul></li><li><p><strong>初始化一些数据结构</strong>：</p><ul><li><code>all_pred</code>、<code>all_visualize</code>、<code>all_gold</code>：用于存储模型的预测结果、可视化信息以及黄金标准结果。</li><li><code>model.eval()</code>：将模型设置为评估模式，不进行梯度计算。</li></ul></li><li><p><strong>迭代评估数据加载器</strong>：</p><ul><li>遍历评估数据加载器中的每个批次。</li><li>对于每个批次，使用模型生成答案，并将生成的结果与标准答案进行比较。</li><li>将比较结果保存在<code>all_pred</code>中。</li></ul></li><li><p><strong>构建黄金标准</strong>：</p><ul><li>将黄金标准数据构建为<code>all_gold</code>结构，以便后续评估使用。</li></ul></li><li><p><strong>计算结果</strong>：</p><ul><li>统计生成的结果与黄金标准的交叉信息，包括精确度、召回率和F1得分，分为分类和识别两个方面。</li><li>将结果存储在<code>result</code>中。</li></ul></li><li><p><strong>返回结果</strong>：</p><ul><li>返回评估的结果以及初始化时的预测结果。</li></ul></li></ol><p>整个函数的目的是评估QA模型的性能，包括对生成的结果进行分类和识别两个方面的评估。这些评估指标包括精确度（precision）、召回率（recall）和F1得分，分别计算在分类和识别任务上。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Kaggle&#39;s_30_Days_Of_ML</title>
      <link href="/2023/11/16/kaggle-s-30-days-of-ml/"/>
      <url>/2023/11/16/kaggle-s-30-days-of-ml/</url>
      
        <content type="html"><![CDATA[<h1 id="Kaggle’s-30-Days-Of-ML-Day-1-Getting-Started-With-Kaggle"><a href="#Kaggle’s-30-Days-Of-ML-Day-1-Getting-Started-With-Kaggle" class="headerlink" title="Kaggle’s 30 Days Of ML (Day-1): Getting Started With Kaggle"></a>Kaggle’s 30 Days Of ML (Day-1): Getting Started With Kaggle</h1><h1 id="Kaggle’s-30-Days-Of-ML-Day-9-First-Machine-Learning-Model-and-Validation"><a href="#Kaggle’s-30-Days-Of-ML-Day-9-First-Machine-Learning-Model-and-Validation" class="headerlink" title="Kaggle’s 30 Days Of ML (Day-9): First Machine Learning Model and Validation"></a>Kaggle’s 30 Days Of ML (Day-9): First Machine Learning Model and Validation</h1><p><img src="/../imgs/$%7Bfiilename%7D/image-20231117125459917-1700196901968-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231117125459917-1700196901968-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117125459917"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231117125647067-1700197008690-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231117125647067-1700197008690-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231117125647067"></p>]]></content>
      
      
      <categories>
          
          <category> kaggle比赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kaggle比赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献整理</title>
      <link href="/2023/11/09/wen-xian-zheng-li/"/>
      <url>/2023/11/09/wen-xian-zheng-li/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">基于大语言模型的零样本信息抽取方法实现</th><th></th><th></th></tr></thead><tbody><tr><td align="left">Event Extraction by Answering (Almost) Natural Questions</td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr><tr><td align="left"></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 文献整理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文献整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于提示的零样本关系抽取方法探索</title>
      <link href="/2023/11/06/ji-yu-ti-shi-de-ling-yang-ben-guan-xi-chou-qu-fang-fa-tan-suo/"/>
      <url>/2023/11/06/ji-yu-ti-shi-de-ling-yang-ben-guan-xi-chou-qu-fang-fa-tan-suo/</url>
      
        <content type="html"><![CDATA[<h1 id="基于提示的零样本关系抽取方法探索"><a href="#基于提示的零样本关系抽取方法探索" class="headerlink" title="基于提示的零样本关系抽取方法探索"></a>基于提示的零样本关系抽取方法探索</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><strong>零样本关系抽取是处理现实世界中缺乏标记数据的新兴关系的重要方法</strong>。然而，<strong>主流的两塔零样本方法通常依赖于预定义关系的大规模域内标记数据</strong>。在这项工作中，我们<strong>将零样本关系提取视为一种通过提示调整优化的语义匹配任务，当预定义关系的标记数据极其稀缺时，它仍然保持优异的泛化性能</strong>。为了最大限度地提高数据利用的效率，我们引入了一种<strong>提示调整技术来引出预训练语言模型（PLM）中现有的关系知识，而不是直接进行微调</strong>。此外，在训练过程中模型接触到的关系描述很少，我们认为这是两塔方法的性能瓶颈。为了突破瓶颈，我们在编码过程中直接对关系实例及其描述之间的语义交互进行建模。在两个学术数据集上的实验结果表明：（1）我们的方法在预定义关系的不同样本上大幅优于之前最先进的方法； （2）这种优势在资源匮乏的情况下会进一步放大。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>近年来，人们对从发票、采购订单、纳税申报表等各种垂直领域的<strong>类似表单的文档中提取结构化信息越来越感兴趣</strong>。[Zhao、Wu 和 Wang 2019；林等人。 2020；于等人。 2019]。在本文中，我们重新审视<strong>关键信息提取（KIE）问题，即从给定文档中提取一组键的值</strong>[Huang et al. 2017]。 2019]。例如，在图 1 中，给定一组键（“电话”、“总计”）和左侧收据文档，KIE 任务旨在提取“电话”的值“03-55423228”和“电话”的值“50.60”全部的”。提取的结构化信息对于广泛的下游任务至关重要，例如知识库构建、问答、文档理解等[Liu and Croft 2002；吴森等人。 2018； Geva 和 Berant 2018]。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107114701675-1699328823889-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107114701675-1699328823889-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107114701675"></p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ACL2022 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>忘掉你想忘掉的东西：LLMs的高效忘却</title>
      <link href="/2023/11/06/wang-diao-ni-xiang-wang-diao-de-dong-xi-llms-de-gao-xiao-wang-que/"/>
      <url>/2023/11/06/wang-diao-ni-xiang-wang-diao-de-dong-xi-llms-de-gao-xiao-wang-que/</url>
      
        <content type="html"><![CDATA[<h1 id="忘掉你想忘掉的东西：LLMs的高效忘却"><a href="#忘掉你想忘掉的东西：LLMs的高效忘却" class="headerlink" title="忘掉你想忘掉的东西：LLMs的高效忘却"></a>忘掉你想忘掉的东西：LLMs的高效忘却</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>大型语言模型（LLM）在预训练和记忆各种文本数据方面取得了显着进展，然而，这个过程可能会遇到<strong>隐私问题</strong>和<strong>违反数据保护法规</strong>的问题。因此，<strong>从此类模型中轻松删除与个人用户相关的数据，同时在删除后不降低其预测质量的能力变得越来越重要</strong>。为了解决这些问题，在这项工作中，我们提出了一种有效的取消学习框架，<strong>通过将选择性师生目标学习的轻量级取消学习层引入到变压器中，可以有效地更新 LLM，而无需在数据删除后重新训练整个模型</strong>。此外，我们引入了<strong>一种融合机制来有效地结合不同的遗忘层，学习遗忘不同的数据集来处理一系列遗忘操作</strong>。<strong>分类和生成任务</strong>的实验证明了我们提出的方法与最先进的基线相比的有效性。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>利用大型语言模型（LLM）已成为各种 NLP 应用的主导范式（Brown et al., 2020；Chowdhery et al., 2022a；Kojima et al., 2022；Ouyang et al., 2022；Brown et al., 2020；Radford et al., 2019；Lewkowycz et al., 2022；Qin et al., 2023；Touvron et al., 2023），因为法学硕士在预训练或大范围微调期间会记住大量知识文本数据（Brown 等人，2020；Radford 等人，2019；Hoffmann 等人，2022；Webson 和 Pavlick，2022；Min 等人，2022；Liang 等人，2022；Carlini 等人， 2022）。然而，这些数据可能包含敏感信息，例如姓名、电话号码、电子邮件地址和私人临床记录（Jang 等人，2022 年；Kurmanji 等人，2023 年；Kumar 等人，2022）。广泛的研究表明，法学硕士可以生成私人信息，例如《麻省理工学院技术评论》主编，包括他的家庭成员、工作地址和电话号码（Carlini 等人，2022）。最近，欧盟的《通用数据保护条例》（GDPR）和美国的《加州消费者隐私法案》（CCPA）也对被遗忘权提出了新的规定，要求应用程序支持在用户请求时删除用户生成的内容（Sekhari）等人，2021 年；库马尔等人，2022 年）。有鉴于此，有必要为法学硕士提供一种高效且有效的方法来忘记用户所请求的信息。</p><p>​最近人们开始关注通过再训练和数据预处理来处理法学硕士的此类忘却请求（Bourtoule et al., 2021; Kumar et al., 2022），其中训练数据存储在不同的隔离切片和每个检查点中在每个切片上训练后保存。当收到删除请求时，相应的数据点将从切片中删除，并且直到该数据点的模型检查点将用于进一步重新训练模型。遗忘的影响通常通过已删除数据的模型错误来体现（模型无法预测已删除数据）（Kurmanji et al., 2023; Jang et al., 2022）。其他工作也探索了确保差分隐私（DP）的算法设计（Yu et al., 2021；Li et al., 2021；Anil et al., 2021）。然而，像 SISA (Bourtoule et al., 2021) 这样的机器去学习方法通常需要大量的存储空间 (Bourtoule et al., 2021)，而 DP 方法可能会导致模型性能收敛缓慢和显着恶化 (Nguyen等人，2022）。此外，两者都需要重新训练整个模型，考虑到当前法学硕士的模型规模，这是极其昂贵和耗时的。这些限制也使它们无法动态处理一系列忘记学习的请求，这些请求通常是现实场景中的需要（Jang et al., 2022; Nguyen et al., 2022）。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107182632183-1699352793499-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107182632183-1699352793499-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107182632183"></p><p>【我们EUL框架的整体流程。遗忘层被插入到前馈网络之后的变压器层中。在训练过程中，只有取消学习层会忘记所请求的数据，而原始的 LLM 保持不变。对于每个删除请求，首先学习一个取消学习层，然后通过我们设计的融合机制与其他取消学习层合并，形成满足一系列删除请求的融合取消学习变压器。】</p><p>​为了填补这些空白，在这项工作中，我们提出了一种 LLM 的高效忘却方法（EUL），可以有效地忘却需要忘记的内容，而无需完全重新训练整个模型，同时保留模型的性能。具体来说，我们提出了一种轻量级方法来学习遗忘层，该方法通过选择性的师生公式（Kurmanji 等人，2023）在几次更新中插入变压器，而无需调整大型语言模型。此外，我们引入了一种融合机制，通过最小化回归目标，有效地将学习忘记不同数据集的不同未学习层的权重组合到单个统一的未学习层。这使得 EUL 能够有效地处理一系列删除操作。为了证明我们提出的 EUL 的有效性，我们在不同设置下的 IMDB（Maas 等人，2011）和 SAMSum（Gliwa 等人，2019）上进行了实验，与最先进的取消学习或模型编辑基线相比。总而言之，我们的主要贡献有三个：</p><ul><li>我们引入了一种有效的忘却方法，通过选择性的师生公式以轻量级的方式消除所需数据的影响。</li><li>我们设计了一种融合机制，将学习忘记不同数据集的遗忘层合并到单个遗忘层中，以处理一系列删除操作。</li><li>我们在不同设置下使用不同规模的骨干模型进行分类和生成任务的实验，以说明EUL的有效性。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><h3 id="2-1-Large-Language-Models"><a href="#2-1-Large-Language-Models" class="headerlink" title="2.1 Large Language Models"></a>2.1 Large Language Models</h3><p>大型语言模型最近取得了广泛的进展（Brown et al., 2020; Radford et al., 2019; Smith et al., 2022; Rae et al., 2021; Chowdhery et al., 2022b; Touvron et al., 2023 ），特别是在扩大法学硕士方面，例如 LLAMA（Touvron 等人，2023）、Megatron-turing NLG（Smith 等人，2022）、Gopher（Rae 等人，2021）和 PaLM Chowdhery 等人。 （2022b）。其他工作也通过更长的训练（Hoffmann et al., 2022）、指令调整（Wang et al., 2022；Zhou et al., 2023）和人类反馈（Ouyang et al., 2022）在较小的模型上取得了更好的性能。 。然而，最近的研究表明，训练数据，例如姓名、电话号码、电子邮件地址，甚至银行帐号等个人身份信息（Carlini 等人，2021；Lee 等人，2021；Carlini 等人，2022） ; Jagielski et al., 2022），可以很容易地从 LLM 中提取，因为 LLM 会记住数十亿个参数的训练数据（Carlini et al., 2022）。我们的工作旨在通过允许从法学硕士中学习的参数中有效地消除所请求的或私有的数据来缓解此类问题。</p><h3 id="2-2-Machine-Unlearning-for-Privacy"><a href="#2-2-Machine-Unlearning-for-Privacy" class="headerlink" title="2.2 Machine Unlearning for Privacy"></a>2.2 Machine Unlearning for Privacy</h3><p>为了减轻法学硕士的隐私风险，引入了机器取消学习方法来消除用户要求删除的训练示例的贡献（Bourtoule 等人，2021；Chien 等人，2023），包括重新训练深度学习的精确取消学习删除后新数据集上的学习模型（Bourtoule et al., 2021）和近似遗忘（Izzo et al., 2021; Golatkar et al., 2020; Kurmanji et al., 2023; Jang et al., 2022），旨在修改训练模型的权重以生成一组新的权重，这些权重近似于重新训练的权重。遗忘的影响通常通过已删除数据的模型错误来体现（模型无法预测已删除数据）（Kurmanji et al., 2023; Jang et al., 2022）。另一条工作重点是差分隐私（DP），它确保训练数据中的用户信息无法被推断（Dwork，2008；Yu et al.，2021；Li et al.，2021；Anil et al.，2021；Abadi等人，2016）。然而，这两种方法都需要重新训练整个模型，这是极其昂贵和耗时的，特别是对于大型语言模型，甚至会影响任务性能（Anil et al., 2021）。因此，它们无法动态处理删除序列（Jang et al., 2022；Nguyen et al., 2022）。为了克服这些限制，我们引入了一种有效的忘却方法以及融合机制来高效、动态地忘却用户数据序列。我们的工作也与模型编辑相关（Mitchell et al., 2021; Belinkov et al., 2017; Dai et al., 2021; Wang et al., 2020），而他们通常专注于根据几个给定的数据编辑模型输出有关世界的语言结构或事实，而不是忘记所需的数据。</p><h2 id="3-Efficient-Unlearning-for-LLMs"><a href="#3-Efficient-Unlearning-for-LLMs" class="headerlink" title="3 Efficient Unlearning for LLMs"></a>3 Efficient Unlearning for LLMs</h2><p>本节介绍了我们为法学硕士（EUL）设计的高效遗忘方法，该方法可以高效、动态地处理一系列删除请求。整体流程如图1所示。形式上，对于在数据集D &#x3D; {(x, y)}上训练的大型语言模型F(.)，其中x是文本数据，y是相应的标签，并且删除请求忘记 Df &#x3D; {(xf , yf } )，我们的目标是学习满足以下条件的更新模型 F ′(.) (Kurmanji et al., 2023)：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183151791-1699353113266-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183151791-1699353113266-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183151791"></p><p>其中 Dr &#x3D; D − Df &#x3D; {(xr, yr)} 指的是我们想要保留的数据，I(.) 是互信息。直观上，我们将用 F(.) 更新 F(.)，为我们想要保留的数据生成类似的输出，同时丢失有关对我们想要忘记的数据进行预测的所有信息。</p><h3 id="3-1-Learning-to-Forget-via-Unlearning-Layers"><a href="#3-1-Learning-to-Forget-via-Unlearning-Layers" class="headerlink" title="3.1 Learning to Forget via Unlearning Layers"></a>3.1 Learning to Forget via Unlearning Layers</h3><p>由于当前法学硕士的规模和训练数据量通常很大，更新模型 F(.) 中的所有参数（例如，在 Dr i 上重新训练 F(.)）变得极其昂贵。受参数高效微调最新进展的启发（Houlsby et al., 2019; Chien et al., 2023），我们通过 F (f (.)) 对 F ′(.) 进行建模，其中 f (.; W ) 是与 F (.) 相比，W 的参数数量显着减少。我们只会更新 f(.) 来满足取消学习的请求。</p><p>​为了有效地实现等式 1 中的忘却目标，我们最小化了选择性的师生目标，其中学生模型 F ′(.) &#x3D; F (f (.)) 被学习以遵循 Dr 上的教师模型 F (.)，同时不服从F (.) 在 Df 上：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183310417-1699353191715-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183310417-1699353191715-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183310417"></p><p>其中 α 是一个超参数，用于平衡忘记 xf 和保留 xr 之间的权衡。直观上，在训练过程中，f(.) 倾向于最小化更新模型的输出和原始模型在要保留的数据上的输出之间的 KL 散度，同时最大化它们在要忘记的数据上的输出之间的 KL 散度。</p><p>​为了保持任务性能，我们针对保留数据上的任务损失优化 f(.)：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183345526-1699353226937-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183345526-1699353226937-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183345526"></p><p>其中 l(.) 是与任务相关的损失，例如，对于分类任务，交叉熵损失 - log P (F (f (xr)))。</p><p>​此外，我们还否定了法学硕士中使用的原始训练目标（例如，掩码语言建模目标（Raffel et al., 2020）），以忘记与数据相关的知识，以便忘记预先训练的参数并确保遗忘数据中的信息不能轻易地从 F(.) 中提取：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183433768-1699353275101-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183433768-1699353275101-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183433768"></p><p>其中l(.)是预训练F(.)时使用的语言模型损失，例如，屏蔽语言模型损失，− log P (^ x|x − ^ x)（^ x是随机屏蔽的标记）。在我们的实验中，我们使用 T5 模型（Raffel et al., 2020）。因此，我们在这个损失项的输入开头添加了一个额外的“预测屏蔽词”。</p><p>​我们的最终培训目标如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183512165-1699353314324-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183512165-1699353314324-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183512165"></p><p>其中 λ 和 γ 是超参数。在实践中，遵循 Kurmanji 等人。 （2023），我们交替更新要忘记的数据和要保留的数据，以更稳定地优化 LEUL 中的最小-最大项。具体来说，我们迭代地对要保留的数据执行一个纪元更新，然后对要忘记的数据执行一个纪元更新。</p><h3 id="3-2-Fusing-Unlearning-Layers"><a href="#3-2-Fusing-Unlearning-Layers" class="headerlink" title="3.2 Fusing Unlearning Layers"></a>3.2 Fusing Unlearning Layers</h3><p>为了动态处理一系列遗忘请求并导出一个可以忘记所有请求数据的统一模型，我们引入了一种融合机制，可以合并不同的遗忘层 fi(.; Wi)，这些层学会了忘记 Df i &#x3D; (Xf i ,Yf i ) 将上一节中的单个 f m(.; Wm) 转换为单个 f m(.; Wm)。也就是说，我们希望 Df i 上的 f m(.) 输出接近 fi(.)：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183611459-1699353373309-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183611459-1699353373309-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183611459"></p><p>这是一个线性回归问题，有一个封闭式解：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231107183649235-1699353410763-15.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231107183649235-1699353410763-15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231107183649235"></p><p>具体来说，为了导出合并的遗忘层 f m 的权重 Wm，我们将使用遗忘数据 Xf i T Xf i 的 LLM 中的遗忘层之前的隐藏表示的预先计算的内积矩阵，然后根据公式 7 计算 Wm。</p><p>​融合机制确保了效率和隐私，因为它可以在没有任何额外训练的情况下执行，并且只需要存储要忘记的数据表示的内积矩阵而不是数据本身。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在这项工作中，我们提出了 EUL，这是一种针对LLMs的有效忘却方法，可以<strong>通过选择性的师生目标通过学习忘却层来高效且有效地忘却用户请求的数据</strong>。我们进一步引入了<strong>一种融合机制，可以将不同的遗忘层合并到一个统一的层中，以动态地遗忘一系列数据</strong>。对不同设置（不同数据集、不同模型大小、不同遗忘集大小）的实验证明了我们提出的 EUL 方法与最先进的基线相比的有效性。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发编程</title>
      <link href="/2023/11/03/bing-fa-bian-cheng/"/>
      <url>/2023/11/03/bing-fa-bian-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="3-7-sleep和yield"><a href="#3-7-sleep和yield" class="headerlink" title="3.7 sleep和yield"></a>3.7 sleep和yield</h2><p><strong>sleep</strong></p><p>1.调用sleep会让当前线程从<em><strong>Running</strong></em>进入<em><strong>Timed Waiting</strong></em>状态（阻塞）</p><p>2.其他线程可以使用interupt方法打断正在睡眠的线程，这时sleep方法会抛出InterruptedException</p><p>3.睡眠结束后的线程未必会立刻得到执行</p><p>4.建议用TimeUnit的sleep代替Thread的sleep来获得更好的可读性</p><p><strong>yield</strong></p><p>1.调用yield会让当前线程从Running进入Runnable就绪状态，然后调度执行其它线程</p><p>2.<strong>具体的实现依赖于操作系统的任务调度器</strong></p><p><strong>线程优先级</strong></p><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p><p>如果CPU比较忙，那么优先级高的线程会获得更多的时间片，但CPU空闲时，优先级几乎没作用</p><p>不使用yield</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test9</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                System.out.prinln(<span class="string">&quot;----&gt;1&quot;</span> + count ++ );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// Thread.yield();</span></span><br><span class="line">                System.out.println(<span class="string">&quot;         ------&gt;2 &quot;</span> + count ++ );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task2, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">        <span class="comment">// t1.setPriority(Thread.MIN_PRIORITY);</span></span><br><span class="line">        <span class="comment">// t2.setPriority(Thread.MAX_PRIORITY);</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未开启yield两者打印次数基本差不多</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103223923885-1699022365204-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103223923885-1699022365204-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103223923885"></p><p>开启后</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103224121283-1699022483089-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103224121283-1699022483089-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103224121283"></p><p>开启优先级</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103224359120-1699022640208-6.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103224359120-1699022640208-6.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103224359120"></p><h2 id="案例-防止CPU占用100"><a href="#案例-防止CPU占用100" class="headerlink" title="案例-防止CPU占用100%"></a>案例-防止CPU占用100%</h2><p><strong>sleep实现</strong></p><p>在没有利用CPU进行计算时，不要让while(true)空转浪费CPU，这时可以使用yield或sleep来让出cpu的使用权给其他程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以使用wait或条件变量达到类似的效果</li><li>不同的是，后两种都需要加锁，并且需要响应的唤醒操作，一般适用于要进行同步的场景</li><li>sleep适用于无需锁同步的场景</li></ul><p>不使用sleep，将会占满单核虚拟机资源</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103225132518-1699023094621-8.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103225132518-1699023094621-8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103225132518"></p><p>使用后</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103225214908-1699023136594-10.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103225214908-1699023136594-10.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103225214908"></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/11/03/jvm/"/>
      <url>/2023/11/03/jvm/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JVM与Java体系结构"><a href="#1-JVM与Java体系结构" class="headerlink" title="1. JVM与Java体系结构"></a>1. JVM与Java体系结构</h1><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103173059181-1699003860604-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103173059181-1699003860604-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103173059181"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103173525870-1699004128599-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103173525870-1699004128599-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103173525870"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103174101458-1699004463451-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103174101458-1699004463451-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103174101458"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103175519266-1699005321228-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103175519266-1699005321228-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103175519266"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103175721844-1699005443920-15.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103175721844-1699005443920-15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103175721844"></p><h2 id="1-1Java虚拟机"><a href="#1-1Java虚拟机" class="headerlink" title="1.1Java虚拟机"></a>1.1Java虚拟机</h2><p><strong>字节码</strong>：</p><p>1.任何能在jvm平台上执行的字节码格式都是一样的，称为<strong>jvm字节码</strong></p><p>2.不同的编译器，可以编译出相同的字节码文件，字节码文件也可以在不同的JVM上运行</p><p>3.Java虚拟机与Java语言并没有必然的联系，它只与特定的二进制文件——Class文件格式所关联，Class文件中包含了Java虚拟机指令集（或称为字节码、Bytecodes）和符号表，还有其他辅助信息</p><p><strong>虚拟机</strong>：</p><p>1.所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。他是一款软件，用来执行一系列不腻计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。Visual Box、VMware属于系统虚拟机，完全是对物理计算机的仿真，提供了一个可运行完整操作系统的软件平台；程序虚拟机就是Java虚拟机，它专门为执行单个计算机程序而设计</p><p>2.无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制与虚拟机提供的自愿者中</p><p><strong>作用</strong></p><p>1.Java虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条Java指令，Java虚拟机规范中都有详细的定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</p><p><strong>特点</strong></p><p>1.一次编译，到处运行</p><p>2.自动内存管理</p><p>3.自动垃圾回收功能</p><h2 id="1-2JVM位置"><a href="#1-2JVM位置" class="headerlink" title="1.2JVM位置"></a>1.2JVM位置</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105223414697-1699194857625-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105223414697-1699194857625-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105223414697"></p><p>JVM是运行在操作系统之上的，它与硬件没有直接的交互。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105223614555-1699194975706-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105223614555-1699194975706-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105223614555"></p><h2 id="1-3Google的Android系统结构"><a href="#1-3Google的Android系统结构" class="headerlink" title="1.3Google的Android系统结构"></a>1.3Google的Android系统结构</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105223734847-1699195056452-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105223734847-1699195056452-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105223734847"></p><h2 id="1-4JVM整体结构"><a href="#1-4JVM整体结构" class="headerlink" title="1.4JVM整体结构"></a>1.4JVM整体结构</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105223857089-1699195138528-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105223857089-1699195138528-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105223857089"></p><p>1.HotSpot VM是目前市面上高性能虚拟机的代表作之一</p><p>2.它采用解释器与即时编译器并存的架构</p><h2 id="1-5Java代码的执行流程"><a href="#1-5Java代码的执行流程" class="headerlink" title="1.5Java代码的执行流程"></a>1.5Java代码的执行流程</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105224512300-1699195514828-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105224512300-1699195514828-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105224512300"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105224745162-1699195666593-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105224745162-1699195666593-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105224745162"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105224907157-1699195749883-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105224907157-1699195749883-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105224907157"></p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/11/02/she-ji-mo-shi/"/>
      <url>/2023/11/02/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="1，设计模式"><a href="#1，设计模式" class="headerlink" title="1，设计模式"></a>1，设计模式</h1><h2 id="1-1-软件设计模式产生背景"><a href="#1-1-软件设计模式产生背景" class="headerlink" title="1.1 软件设计模式产生背景"></a>1.1 软件设计模式产生背景</h2><h2 id="1-2-软件设计模式概念"><a href="#1-2-软件设计模式概念" class="headerlink" title="1.2 软件设计模式概念"></a>1.2 软件设计模式概念</h2><p>软件设计模式（Software Design Pattern），是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈的代码设计经验的总结，具有一定的普遍性，可以反复被使用的</p><h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象上街原则的实际运用，是对类的封装性、继承性、多态性以及类的关联关系和组合关系的充分理解。</p><p>正确使用设计模式优点：</p><ul><li>提高思维能力、编程能力和设计能力</li><li>使得程序上街更加标准化、代码百年之更加工程化、使得软件开发效率大大提高，从而缩短软件的开发周期</li><li>使得设计的diamond可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><ul><li><p><strong>创建型模式</strong></p><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”，GoF书中提供了单例、原型、工厂方法、抽象工厂、建造者等5种创建型模式。</p></li><li><p><strong>结构型模式</strong></p><p>用于描述如何将类或对象按某种布局组成更大的结构，GoF书中提供了代理、适配器、桥接、装饰、外观、享元、组合等7种结构型模式。</p></li><li><p><strong>行为性模式</strong></p><p>用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。GoF书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等11种行为型模式。</p></li></ul><h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。特点是简单、统一、图形化、能表达软件设计种的动态与静态信息。</p><h2 id="2-1类图概述"><a href="#2-1类图概述" class="headerlink" title="2.1类图概述"></a>2.1类图概述</h2><p>类图（Class digram）是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息，类图是面向对象建模的主要组成部分。</p><h2 id="2-2类图的作用"><a href="#2-2类图的作用" class="headerlink" title="2.2类图的作用"></a>2.2类图的作用</h2><ul><li>在软件工程中，类图是一种惊天的结构图，描述了系统的类的集合，类的属性和类之间的关系，简化了人们对系统的理解。</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测hi是的额重要模型。</li></ul><h2 id="2-3类图表示法"><a href="#2-3类图表示法" class="headerlink" title="2.3类图表示法"></a>2.3类图表示法</h2><p>2.3.1类的表示方法</p><p>在UML类图中，类使用半酣类名、属性（field）和方法(method)且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name，age和address这3个属性，以及work()方法</p><p><img src="/../imgs/$%7Bfiilename%7D/Employee-1698935475644-2.jpg" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/Employee-1698935475644-2.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="Employee"></p><p>属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li>+表示public</li><li>-表示private</li><li>#表示protected</li></ul><p>属性的完整表示方法是：<strong>可见性 名称：类型 [ &#x3D; 缺省值]</strong></p><p>方法的完整表示方式是：<strong>可见性 名称（参数列表）[ : 返回类型]</strong></p><p><code>注意：</code></p><p><code>1.括号中的内容表示可选</code></p><p><code>2.也有将类型放在变量名前面，返回值类型放在方法名前面</code></p><p>例子：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103210913189-1699016955618-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103210913189-1699016955618-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103210913189"></p><p>Demo定义了三个方法：</p><p>method()方法：修饰符为public，没有参数，没有返回值</p><p>method1()方法：修饰符为private，没有参数，返回值类型为String</p><p>method2()方法：修饰符为protexted，接收两个参数，第一个参数为int，第二个参数为String，返回值类型是int</p><h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1关联关系"><a href="#2-3-2-1关联关系" class="headerlink" title="2.3.2.1关联关系"></a>2.3.2.1关联关系</h4><p>关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类直接按最常用的一种关系，非为一般关联关系、聚合关系和组合关系</p><p>关联又可以分为单向关联、双向该你了，自关联</p><p>1，单向关联</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103211501365-1699017304175-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103211501365-1699017304175-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103211501365"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p>2，双向关联</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103211651053-1699017414657-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103211651053-1699017414657-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103211651053"></p><p>所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中子啊Customer类中维护一个List<Product>，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p>3，自关联</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103211956190-1699017598958-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103211956190-1699017598958-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103211956190"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是部分和整体之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如：学校和老师的关系，学校包含老师，但是如果学校停办了，老师依然存在。</p><p>在UML类图中，聚合关系可以用带空心菱形的实现表示，菱形指向整体。下图是大学和教师的关系图：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103212410245-1699017852817-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103212410245-1699017852817-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103212410245"></p><h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更加强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如：头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在UML类图中，组合关系用带实心菱形的实线来表示，菱形指向整体，下图所示是头和嘴的关系图：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103212718430-1699018041821-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103212718430-1699018041821-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103212718430"></p><h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合程度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过<strong>局部变量、方法的参数或者对静态方法的调用</strong>来访问另一个类（被依赖类）中的<strong>某些方法</strong>来完成一些职责。</p><p>在UML类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103213153944-1699018317717-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103213153944-1699018317717-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103213153944"></p><h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在UML类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如：Student类和Teacher类都是Person类的子类。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103213523353-1699018524901-15.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103213523353-1699018524901-15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103213523353"></p><h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中国的操作实现接口中所声明的所有的抽象操作。</p><p>在UML类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如：汽车和船实现了交通工具。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103213803600-1699018685051-17.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103213803600-1699018685051-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103213803600"></p><h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行扩展的时候，不能去修改原有的代码，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们就需要接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生出来的实现类来进行扩展，当软件需要发生变化时，只需要根据要求重新派生一个实现类来扩展就可以了。</p><p>下面哦才能够<code>搜狗输入法</code>的皮肤为例介绍开闭原则的应用。</p><p>例子：<code>搜狗输入法</code>的皮肤设计</p><p>分析：<code>搜狗输入法</code>的皮肤时输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HiSpecificSkin）是其子类。用户窗体可以根据需要选择或增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104161728132-1699085849532-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104161728132-1699085849532-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104161728132"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: AbstractSkin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 抽象类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSkin</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 显示方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: DefaultSkin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 默认皮肤类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSkin</span> <span class="keyword">extends</span> <span class="title class_">AbstractSkin</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认皮肤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.priciples.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: HiSkin</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Hi皮肤</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HiSkin</span> <span class="keyword">extends</span> <span class="title class_">AbstractSkin</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.printlin(<span class="string">&quot;Hi皮肤&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.priciples.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: SougouInput</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 搜狗输入法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SougouInput</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AbstractSkin skin;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSkin</span><span class="params">(AbstractSkin skin)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.skin = skin;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        skin.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.priciples.demo1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: SougouInput</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 搜狗输入法</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建搜狗输入法对象</span></span><br><span class="line">        <span class="type">SougouInput</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SougouInput</span>();</span><br><span class="line">        <span class="comment">// 创建皮肤对象</span></span><br><span class="line">        <span class="type">DefaultSkin</span> <span class="variable">skin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultSkin</span>();</span><br><span class="line">        <span class="comment">// 将皮肤设置到输入法中去</span></span><br><span class="line">        input.setSkin(skin);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示皮肤</span></span><br><span class="line">        input.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的而基本原则之一。</p><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：子类可以扩展父类的功能，但不能该百年父类原有的功能。换句话说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用堕胎比较频繁时，出现运行出错的概率会非常大。</p><p>里氏代换原则经典例子</p><p>例子：正方形不是长方形。</p><p>在数学里面，正方形毫无疑问时长方形，他是一个长宽相等的长方形。所以，我们开发的一个于几何图像相关的软件系统，就可以顺理成章的让正方形继承长方形。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104164605744-1699087569174-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104164605744-1699087569174-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104164605744"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Rectangle</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 长方形类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Square</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 正方形类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: RectangleDemo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setWidth(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽操作</span></span><br><span class="line">        resize(r);</span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        printLengthAngWidth(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩宽方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，则进行扩宽操作</span></span><br><span class="line">        <span class="keyword">while</span>(rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectang;e.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAngWidth</span> <span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104211035522-1699103436900-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104211035522-1699103436900-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104211035522"></p><p>如果进行下面的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: RectangleDemo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setWidth(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽操作</span></span><br><span class="line">        resize(r);</span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        printLengthAngWidth(r);</span><br><span class="line">        </span><br><span class="line">        System.out.prinln(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建正方形对象</span></span><br><span class="line">        <span class="type">Square</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        s.setLenth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用resize方法进行扩宽操作</span></span><br><span class="line">        resize(s);</span><br><span class="line">        <span class="comment">// 打印结果</span></span><br><span class="line">        printLengthAngWidth(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩宽方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，则进行扩宽操作</span></span><br><span class="line">        <span class="keyword">while</span>(rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectang;e.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAngWidth</span> <span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        System.out.println(rectangle.getWidth());</span><br><span class="line">        System.out.println(rectangle.getLength());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>卡死了，程序继续在运行</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104213559602-1699104961394-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104213559602-1699104961394-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104213559602"></p><p>我们运行一下这段代码就会发现，加入我们把一个普通长方形作为参数传入resize方法，就会看到长方形阔度逐渐增长的效果，当宽度大于长度，代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度不断增长，代码会一致运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。</p><p>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数是不能被Square类型的参数所替代，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>如何改进呢？此时我们<strong>需要重新设计他们之间的关系，抽象出来一个四边形接口（Quardrilateral），让Rectangle类和Square类实现Quadrilateral接口</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104215456650-1699106098335-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104215456650-1699106098335-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104215456650"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Quardrilateral</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 四边形接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Quardrilateral</span> &#123;</span><br><span class="line">    <span class="comment">// 获取长</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取宽</span></span><br><span class="line">    <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Square</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 正方形</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Quadrilateral</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> side;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getSide</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSide</span><span class="params">(<span class="type">double</span> side)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.side = side;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Rectangle</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 长方形</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Quadrilateral</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.pinciples.demo2.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: RectangleDemo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(Sting[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        r.setLength(<span class="number">20</span>);</span><br><span class="line">        r.setWidth(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">// 调用方法进行扩宽操作</span></span><br><span class="line">        resise(r);</span><br><span class="line">        </span><br><span class="line">        printLengthAndWidth(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩宽的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断宽如果比长小，则进行扩宽操作</span></span><br><span class="line">        <span class="keyword">while</span>(rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectang;e.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印长和宽</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printLengthAndWidth</span><span class="params">(Quadrilateral quadrilateral)</span> &#123;</span><br><span class="line">        System.out.println(quadrilateral.getLength());</span><br><span class="line">        System.out.println(quadrilateral.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104222827936-1699108109259-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104222827936-1699108109259-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104222827936"></p><h2 id="3-3依赖倒转原则"><a href="#3-3依赖倒转原则" class="headerlink" title="3.3依赖倒转原则"></a>3.3依赖倒转原则</h2><p>高层模块不应该依赖于底层模块，两者都应该依赖其抽象；抽象不应该依赖于细节，细节应该依赖于抽象。简单说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与是西安模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><p>【例】组装电脑</p><p>现在要组装一台电脑，需要配件CPU，硬盘，内存条。只有这些配置都有了，计算机才能正常的与性能。选择CPU有很多选择，如Inter，AMD等，硬盘可以选择希捷，西部数据等，内存条可以选择金士顿，海盗船等。</p><p><strong>类图如下：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105123733760-1699159054934-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105123733760-1699159054934-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105123733760"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: XiJieHardDisk</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 希捷硬盘</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.printlin(<span class="string">&quot;使用希捷硬盘存储数据为&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷硬盘获取数据为&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Intel cpu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Intel cpu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Intel处理器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: KingstonMemory</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 金士顿内存条</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用金士顿内存条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Computer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 计算机类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> XiJieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> XiJieHardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(XiJieHardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> IntelCpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        retrun cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(IntelCpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> KingstonMemory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(KingstonMemory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始运行计算机&quot;</span>);</span><br><span class="line">        <span class="comment">// 开机先从硬盘加载数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘上获取的数据是：&quot;</span> + data);</span><br><span class="line">        <span class="comment">// 运行cpu</span></span><br><span class="line">        cpu.run();</span><br><span class="line">        <span class="comment">// 内存条保存</span></span><br><span class="line">        memory.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cpu.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建组件对象</span></span><br><span class="line">        <span class="type">XiJieHardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>();</span><br><span class="line">        <span class="type">IntelCpu</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>();</span><br><span class="line">        <span class="type">KingstonMemory</span> <span class="variable">memory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KingstonMemory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 组装计算机</span></span><br><span class="line">        c.setCpu(cpu);</span><br><span class="line">        c.setHardDisk(hardDisk);</span><br><span class="line">        c.setMemory(memory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行计算机</span></span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105130414980-1699160657248-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105130414980-1699160657248-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105130414980"></p><p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的额，用户有了机箱后肯定是按照自己的喜好，选择自己喜欢的额配件。</p><p>根据依赖倒转原则进行改进</p><p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p><p><strong>类图如下：</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105130853836-1699160935529-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105130853836-1699160935529-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105130853836"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: HardDisk</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 硬盘接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cuo.principes.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: XiJieHardDisk</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 希捷硬盘</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XiJieHardDisk</span> <span class="keyword">implements</span> <span class="title class_">HardDisk</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.printlin(<span class="string">&quot;使用希捷硬盘存储数据为&quot;</span> + data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取数据的方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用希捷硬盘获取数据为&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;数据&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Cpu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: cpu接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cpu</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行cpu</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Intel cpu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Intel cpu</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> <span class="keyword">implements</span> <span class="title class_">Cpu</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用Intel处理器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Memory</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 内存条接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memory</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: KingstonMemory</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 金士顿内存条</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> <span class="keyword">implements</span> <span class="title class_">Memory</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用金士顿内存条&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Computer</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 计算机类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> HardDisk hardDisk;</span><br><span class="line">    <span class="keyword">private</span> Cpu cpu;</span><br><span class="line">    <span class="keyword">private</span> Memory memory;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> HardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(HardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Cpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        retrun cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(Cpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Memory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(Memory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始运行计算机&quot;</span>);</span><br><span class="line">        <span class="comment">// 开机先从硬盘加载数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘上获取的数据是：&quot;</span> + data);</span><br><span class="line">        <span class="comment">// 运行cpu</span></span><br><span class="line">        cpu.run();</span><br><span class="line">        <span class="comment">// 内存条保存</span></span><br><span class="line">        memory.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cpu.principles.demo3.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: ComputerDemo</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建组件对象</span></span><br><span class="line">        <span class="type">HardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XiJieHardDisk</span>();</span><br><span class="line">        <span class="type">Cpu</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>();</span><br><span class="line">        <span class="type">Memory</span> <span class="variable">memory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KingstonMemory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建计算机对象</span></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="comment">// 组装计算机</span></span><br><span class="line">        c.setCpu(cpu);</span><br><span class="line">        c.setHardDisk(hardDisk);</span><br><span class="line">        c.setMemory(memory);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 运行计算机</span></span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105132207649-1699161729686-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105132207649-1699161729686-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105132207649"></p><h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105162929419-1699172971634-11-1699172999929-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105162929419-1699172971634-11-1699172999929-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105162929419"></p><p>下面看一个例子来理解接口隔离原则</p><p>【例】安全门案例</p><p>我们需要创建一个<code>Hi</code>品牌的安全门，该安全门具有防火、防水、防盗的功能，可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105162651879-1699172814772-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105162651879-1699172814772-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105162651879"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: SafetyDoor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 安全门接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SafetyDoor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防盗</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防火</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 防水</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterProof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: CupkSafetyDoor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Cupk品牌安全门</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CupkSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">SafetyDoor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.before;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Client</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CupkSafetyDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CupkSafetyDoor</span>();</span><br><span class="line">        door.antiTheft();</span><br><span class="line">        door.fireProof();</span><br><span class="line">        door.waterProof();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105164451730-1699173893501-15.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105164451730-1699173893501-15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105164451730"></p><p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗、防水、防火的功能。现在如果我们还需要再创建一个<code>cupk</code>品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果是实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看下面类图：</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105164609875-1699173971685-17.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105164609875-1699173971685-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105164609875"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: AntiTheft</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 防盗接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AntiTheft</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: FireProof</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 防火接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">FireProof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: WaterProof</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 防水接口</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">WaterProof</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">waterProof</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: CupkSafetyDoor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Cupk品牌安全门</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CupkSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>, FireProof, WaterProof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">waterProof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防水&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: Client</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: 测试类</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Cpuk品牌安全门</span></span><br><span class="line">        <span class="type">CupkSafetyDoor</span> <span class="variable">door</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CupkSafetyDoor</span>();</span><br><span class="line">        <span class="comment">// 调用功能</span></span><br><span class="line">        door.antiTheft();</span><br><span class="line">        door.fireProof();</span><br><span class="line">        door.waterProof();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建Cupker安全门对象</span></span><br><span class="line">        <span class="type">CupkerSafetyDoor</span> <span class="variable">door1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CupkerSafetyDoor</span>();</span><br><span class="line">        <span class="comment">// 调用功能</span></span><br><span class="line">        door1.antiTheft();</span><br><span class="line">        door1.fireProof();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cup.principles.demo4.after;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> v1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ClassName</span>: CupkerSafetyDoor</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span>: Cupker品牌安全门</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span>: humbleyl</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CupkerSafetyDoor</span> <span class="keyword">implements</span> <span class="title class_">AntiTheft</span>, FireProof &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">antiTheft</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防盗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fireProof</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;防火&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105165740100-1699174661510-19.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105165740100-1699174661510-19.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105165740100"></p><h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：<strong>当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等</strong>，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>下面看一个例子来理解接口隔离原则</p><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人来负责处理，如和粉丝的见面会，和媒体公司的业务洽谈等。这里的经纪人是明星的朋友，而粉丝和米欸天公司是陌生人，所以适合使用迪米特法则。</p><p>类图如下：</p>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/2023/11/02/java-ji-chu/"/>
      <url>/2023/11/02/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="1-多行注释"><a href="#1-多行注释" class="headerlink" title="1.多行注释"></a>1.多行注释</h1><ul><li><p>单行注释：&#x2F;&#x2F; 注释文字</p></li><li><p>多行注释： &#x2F;* 注释文字 *&#x2F;</p></li><li><p>细节：（1）被注释的文字，不会被JVM解释执行；（2）多行注释里面不允许多行嵌套注释</p></li><li><p>文档注释：注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式体现的该程序的说明文档，一般写在类前面</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 院龙</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Comment02</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 生成javadoc文档</span><br><span class="line">javadoc -d 文件夹名 -xx -yy Demo3.java</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231103203001632-1699014603805-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231103203001632-1699014603805-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231103203001632"></p><h1 id="2-Java代码规范"><a href="#2-Java代码规范" class="headerlink" title="2.Java代码规范"></a>2.Java代码规范</h1><p>1.类、方法的注释，要以javadoc方式来写</p><p>2.非Java Doc的注释，往往是给代码的维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等</p><p>3.使用tab操作，实现缩进，默认整体向右边移动，用shift+tab整体向左移</p><p>4.运算符和 &#x3D; 两边习惯性各加一个空格</p><p>5.源文件使用utf-8编码</p><p>6.行宽度不要超过80字符</p><p>7.代码编写次行和行尾风格</p><h1 id="7-面向对象编程（基础）"><a href="#7-面向对象编程（基础）" class="headerlink" title="7. 面向对象编程（基础）"></a>7. 面向对象编程（基础）</h1><h2 id="7-1-类与对象"><a href="#7-1-类与对象" class="headerlink" title="7.1 类与对象"></a>7.1 类与对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object01</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 编写一个main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        张老太养了两只猫猫：一只小白，今年3岁，白色</span></span><br><span class="line"><span class="comment">        还有一只小花，今年100岁，花色。程序：</span></span><br><span class="line"><span class="comment">        当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。</span></span><br><span class="line"><span class="comment">        如果输入小猫名称有误，则显示 张老太没有这只猫</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        firstCat = <span class="keyword">new</span> <span class="title class_">Object01</span>();</span><br><span class="line">        secondCat = <span class="keyword">new</span> <span class="title class_">Object02</span>();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类和对象的区别和联系</strong></p><p>1.类是抽象的，概念的，代表一类事物，即它是数据类型</p><p>2.对象是具体的，实际的，代表一个具体事物，即它是实例</p><p>3.类是对象的模板，对象是类的一个个体，对应一个实例</p><p><strong>对象在内存中的样子</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105184116067-1699180877570-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105184116067-1699180877570-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105184116067"></p><p><strong>注意事项</strong></p><p>1.属性定义语法同变量：<code>访问修饰符 属性类型 属性名</code></p><p>​简而言之：控制属性的访问范围</p><p>​有四种访问修饰符 public protected 默认 private</p><p>2.属性定义类型可以为任意类型，包含基本类型（int age）或引类型（String[] args）</p><p>3.属性如果不赋值，有默认值，规则和数组一致。</p><p>​int 0, short 0, byte 0, long 0, float 0.0, double 0.0, char \u0000, boolean false, String null</p><p><strong>如何创建对象</strong></p><p>1.先声明再创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat cat; <span class="comment">// 声明对象cat</span></span><br><span class="line">cat = <span class="keyword">new</span> <span class="title class_">Cat</span>(); <span class="comment">// 创建对象cat</span></span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105215310062-1699192391808-3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105215310062-1699192391808-3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105215310062"></p><p>2.直接创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><p><strong>类和对象的内存分配机制</strong></p><p>一个思考题，下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p1.age = <span class="number">10</span>;</span><br><span class="line">p1.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line">System.out.println(p2.age);</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105220804011-1699193287494-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105220804011-1699193287494-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105220804011"></p><p>Java内存结构分析</p><p>1.栈：一般存放基本数据类型（局部变量）</p><p>2.堆：存放对象（Cat cat, 数组等）</p><p>3.方法区：常量池（常量，比如字符串），类加载信息</p><p>4.示意图 [ Cat (name, age, price) ]</p><p>【例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;Jack&quot;</span>;</span><br><span class="line">p.age = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 1. 先加载Person类信息（属性和方法信息，只会加载一次）</span></span><br><span class="line"><span class="comment">* 2. 在堆中分配空间，进行默认初始化（有特定规则）</span></span><br><span class="line"><span class="comment">* 3. 把地址赋给p, p就指向对象</span></span><br><span class="line"><span class="comment">* 4. 进行指定初始化，比如p.name = &quot;Jack&quot;; p.age = 10;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>【例】</p><h2 id="7-2-overload"><a href="#7-2-overload" class="headerlink" title="7.2 overload"></a>7.2 overload</h2><h2 id="7-3-可变参数"><a href="#7-3-可变参数" class="headerlink" title="7.3 可变参数"></a>7.3 可变参数</h2><h2 id="7-4-作用域"><a href="#7-4-作用域" class="headerlink" title="7.4 作用域"></a>7.4 作用域</h2><h2 id="7-5-this"><a href="#7-5-this" class="headerlink" title="7.5 this"></a>7.5 this</h2>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>情境学习创建任务向量</title>
      <link href="/2023/11/02/qing-jing-xue-xi-chuang-jian-ren-wu-xiang-liang/"/>
      <url>/2023/11/02/qing-jing-xue-xi-chuang-jian-ren-wu-xiang-liang/</url>
      
        <content type="html"><![CDATA[<h1 id="情境学习创建任务向量"><a href="#情境学习创建任务向量" class="headerlink" title="情境学习创建任务向量"></a>情境学习创建任务向量</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>大型语言模型 (LLM) 中的上下文学习 (ICL) 已成为一种强大的新学习范式。然而，其基本机制仍不清楚。<strong>特别是，将其映射到“标准”机器学习框架具有挑战性，在该框架中，人们使用训练集 S 在某个假设类中找到最佳拟合函数 f (x)<strong>。在这里，我们在这个问题上取得了进展，表明 ICL 学习的函数通常具有非常简单的结构：</strong>它们对应于变压器 LLM，其唯一输入是查询 x 和从训练集计算出的单个“任务向量”</strong>。因此，<strong>ICL 可以看作是将 S 压缩为单个任务向量 θ(S)，然后使用该任务向量来调制变压器以产生输出</strong>。我们通过一系列模型和任务的综合实验来支持上述主张。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>大型语言模型在过去几年中得到了显着改进。这些模型的一个<strong>显着特性是它们可以从很少的演示中学习新规则</strong>。例如，可以使用输入“Apple → Red、Lime → Green、Corn →”提示模型并生成输出“Yellow”。因此，<strong>该模型仅基于两个示例就学习了映射，并且可以将其正确应用于新示例</strong>。这种能力被称为 InContext Learning (ICL)，已被广泛使用，产生了令人印象深刻的实证结果（Brown 等人，2020；Liu 等人，2023；Dong 等人，2022）。</p><p>​       鉴于这一成功，人们自然会问 ICL 背后的根本机制是什么。即，模型内部如何使用演示 S 和查询 x 来产生所需的输出？在这里，我们利用统计学习理论中的假设类概念（Shalev-Shwartz 和 Ben-David，2014）。在学习理论公式中，人们通常考虑假设类 H，其中 H 的每个元素都是函数 h(x; θ)，对输入 x 进行运算，并由参数向量 θ 指定。例如，如果 x ∈ Rd，则类 H 可以是线性分类器的集合，由系数向量 θ 定义为 h(x; θ) &#x3D; θ · x。学习算法寻找一个能很好地拟合训练集的元素 h ∈ H。这称为经验风险最小化。</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105171853641-1699175934785-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105171853641-1699175934785-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105171853641"></p><p>​       目前尚不清楚 ICL 是否以这种方式运行，<font color="red" size="4.5"> 因为预测是通过 T ([S, x]) 执行的，其中 T 通常是自回归变压器和[S, x] 是 S 和 x 中标记的串联 </font>*<em><strong>。因此，在一般情况下，</strong></em>它可以是对 S 和 x 进行运算以产生输出的任意函数**。这可以包括“非参数”方法，例如最近邻法。最近的工作已经开始探索这个问题。例如，研究表明，当从头开始训练 Transformer 以在上下文中执行线性回归时，新兴的学习算法类似于随机梯度下降（Akyürek 等人，2022 年；von Oswald 等人，2022 年）。然而，对于执行更复杂的自然语言任务的法LLMs来说，根本不清楚假设空间可能是什么。</p><p>​在这项工作中，我们表明，<strong>在广泛的任务中，LLMs中的 ICL 可以被视为在非常自然的假设空间上工作</strong>。我们认为，<strong>给定训练集 S，变压器将其映射到“任务向量”θ(S)，该向量本质上表示 S.2 中描述的映射&#x2F;规则</strong>。即，<strong>给定变压器 T 和向量 θ，我们可以构造实现该任务的新函数 f (x; θ)<strong>。</strong>函数 f 与应用于 x 的原始变换器非常相似，但没有演示，而是通过 θ 进行调制</strong>（见图 2）。</p><p>​我们的观点也与<strong>软提示</strong>有关（Lester et al., 2021），因为这两种方法都会<strong>针对特定任务调节变压器的功能</strong>。然而，<strong>在 ICL 中，任务向量是在前向传递中计算的，而不是进行微调的。</strong></p><p>​我们的贡献包括<strong>提出基于假设类的 ICL 机械观点</strong>，并进行实验来验证我们对一系列公开可用的LLMs和各种任务的观点。我们的结果进一步加深了对 ICL 的理解，并可能对LLMs有效适应执行特定任务具有实际意义。</p><h2 id="2-A-Hypothesis-Class-View-of-ICL"><a href="#2-A-Hypothesis-Class-View-of-ICL" class="headerlink" title="2 A Hypothesis Class View of ICL"></a>2 A Hypothesis Class View of ICL</h2><p>受学习理论的假设类视图的启发，我们的目标<strong>是了解 ICL 是否将演示集 S 映射到查询 x 上的函数以及这种映射是如何发生的</strong>。具体来说，我们<strong>试图看看 ICL 是否将 S 转换为 θ——某个假设空间内函数的“参数”</strong>。我们的实证研究结果表明这种观点是适用的，揭示了 ICL 运行的假设空间的结构。</p><h3 id="2-1Theoretical-Framework"><a href="#2-1Theoretical-Framework" class="headerlink" title="2.1Theoretical Framework"></a>2.1Theoretical Framework</h3><p>我们使用 <em>T</em> 表示仅解码器变压器 LLM，<em>S</em> 表示用作 ICL 输入的演示集（即训练示例），x 表示要求 ICL 提供输出的查询。我们使用 <em>T</em> ([<em>S</em>, x]) 表示 ICL 对 <em>S</em> 和 x 串联的输出。</p><p>​为了证明 ICL 在假设空间内运行，我们的目标是证明其基本机制可以分为两部分：</p><ul><li>一种“学习算法”（用 <em>A</em> 表示），将 <em>S</em> 映射到“任务向量”<em>θ</em>，独立于查询 x。鉴于注意力层可以访问 S 和 x，这种独立性并非微不足道。</li><li>一个“规则应用”（用<em>f</em>表示），它基于<em><strong>θ</strong></em> ≡ <em><strong>A</strong></em>(<em><strong>S</strong></em>) 将查询x 映射到输出，而不直接依赖于<em>S</em>。同样，这种独立性并非微不足道。</li></ul><p>因此，我们考虑以下从一组演示和查询到预测输出的映射<em>：T</em> ([S, x]) &#x3D; f (x; A(S))。如果我们可以将 LLM 的前向传递分解为上述两个部分，我们可以将 ICL 视为在以下假设类上运行： H &#x3D; {f (·; θ) | θ}。在下一节中，我们提出这样一个类的实现。</p><h3 id="2-2-A-proposed-Hypothesis-Class"><a href="#2-2-A-proposed-Hypothesis-Class" class="headerlink" title="2.2 A proposed Hypothesis Class"></a>2.2 A proposed Hypothesis Class</h3><p>上述框架有多种可能的实现，对应于 A 和 f 的不同选择。接下来我们描述我们关注的实现，这自然是从变压器架构中得出的。我们<strong>考虑如图 1 所示的 ICL 设置，其中输入以查询 x（即 Corn）结尾，后跟“→”符号</strong>。如上所述，我们将学习视为由两个步骤组成：<strong>根据训练样本 S 计算参数向量 θ，并将该参数向量定义的规则应用于查询 x</strong>。变压器执行此操作的一个简单方法<strong>可能是让 → 表示的前 L 层计算 θ，然后让其余层将 θ 和 x 作为输入并产生输出</strong>。参见图 1。回想一下，变压器在任何层都可以访问 S 和 x，这对我们的观点提出了挑战。</p><p>​在以下部分中，我们将解决这一挑战并提出验证我们观点的实验。也就是说，我们证明<strong>我们可以在执行 ICL 的 LLM 的前向传播中分离出我们提出的 A 和 f。我们还表明 θ 向量是可解释的并且对应于学习任务。</strong></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105174538487-1699177540536-5.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105174538487-1699177540536-5.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105174538487"></p><h2 id="3-Validity-of-the-Hypothesis-Class-View"><a href="#3-Validity-of-the-Hypothesis-Class-View" class="headerlink" title="3 Validity of the Hypothesis Class View"></a>3 Validity of the Hypothesis Class View</h2><p>我们首先证明，<strong>将前向传播分成两个不同的分量 A 和 f（在第 2.2 节中定义）可以保持 ICL 的高精度。</strong></p><h3 id="3-1-Separating-A-and-f"><a href="#3-1-Separating-A-and-f" class="headerlink" title="3.1 Separating A and f"></a>3.1 Separating A and f</h3><p>我们在常规前向传递中面临一些挑战：<strong>首先，对应于 A 的初始 L 层，更新 → 的表示以创建 θ，可以处理查询 x。因此，它们可能依赖于 x，从而产生 θ 对 x 的不必要的依赖。</strong>其次，与 f 相对应的其余层可以直接访问 S，而不是仅使用 x 和 θ。</p><p>​我们提出以下过程来解决这些挑战：<strong>为了解决第一个问题，我们引入一个“虚拟查询”x′并使用该查询计算→的表示。我们使用前 L 层之后的 → 表示（使用 x′ 计算）作为向量 θ（如图 2 左侧所示）。另一种方法是阻止对 x 的关注，但这会导致性能不佳。为了解决在不允许直接依赖于 S 的情况下计算 f (x, θ) 的第二个问题，我们仅对 x 和 →,3 执行变换器的前向传递，并对我们之前在第 L 层提取的 θ 进行“修补”。</strong> →（图2右侧）.4</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105175112562-1699177874552-7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105175112562-1699177874552-7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105175112562"></p><p>3.2</p><h2 id="8-Conclusions"><a href="#8-Conclusions" class="headerlink" title="8 Conclusions"></a>8 Conclusions</h2><p>通过LLMs对 ICL 的探索，我们揭示了 ICL 学习机制的新视角。我们揭示了一个简单而优雅的结构：<strong>ICL 通过将给定的训练集压缩为单个任务向量来发挥作用，然后引导变压器根据给定的查询生成适当的输出</strong>。我们的工作为了解LLMs如何进行 ICL 奠定了基础。根据我们的发现，未来的工作可以集中于理解任务向量是如何构建的以及如何使用它来计算输出。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多语言模型中事实知识的跨语言一致性</title>
      <link href="/2023/11/02/duo-yu-yan-mo-xing-zhong-shi-shi-zhi-shi-de-kua-yu-yan-yi-zhi-xing/"/>
      <url>/2023/11/02/duo-yu-yan-mo-xing-zhong-shi-shi-zhi-shi-de-kua-yu-yan-yi-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="多语言模型中事实知识的跨语言一致性"><a href="#多语言模型中事实知识的跨语言一致性" class="headerlink" title="多语言模型中事实知识的跨语言一致性"></a>多语言模型中事实知识的跨语言一致性</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p><span style="background-color: #2ea8e580">多语言大规模预训练语言模型（PLM）已被证明可以存储大量的事实知识，但观察到语言之间存在很大差异</span>。为了确保具有不同语言背景的用户从同一模型获得一致的反馈，我们研究了各种多语言PLM中事实知识的跨语言一致性（CLC）。为此，我们<span style="background-color: #2ea8e580">提出了一个基于排名的一致性（RankC）指标，以独立于准确性来评估跨语言的知识一致性</span>。使用这个指标，我们在模型级别和语言对级别对CLC的决定因素进行了深入分析。在其他结果中，我们发现<span style="background-color: #ff666680">增加模型大小会导致大多数语言中更高的事实探测准确性，但不会提高跨语言的一致性</span>。最后，我们进行了关于CLC的案例研究，当通过模型编辑在PLM中插入新的事实关联时。英<span style="background-color: #ff666680">语插入的一小部分事实样本的结果揭示了一个清晰的模式，即新知识仅转移到英语具有高 RankC 分数的语言。</span></p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>     大规模预训练语言模型 （PLM） 在事实知识发挥重要作用的任务中展示了强大的能力（Roberts 等人，2020 年;秦等人，2022 年）。虽然以前大多数关于探索 PLM 中事实知识的工作都集中在英语上（Davison 等人，2019 年;布拉维等人，2020 年;申等人，2020;布朗等人，2020 年;阿尔甘米等人，2021 年;Peng 等人，2022 年），一些值得注意的研究已将评估扩展到许多其他语言（Jiang 等人，2020 年;卡斯纳等人，2021 年;尹等人，2022 年）。这些研究结果表明事实知识在多大程度上跨语言泛化，揭示了现代 NLP 技术中语言不平等的另一个方面（Hupkes 等人，2022 年）。</p><p><img src="/../imgs/$%7Bfiilename%7D/JTY72Y4D-1698899470325-23.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/JTY72Y4D-1698899470325-23.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;JTY72Y4D&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%225VBT7M5M%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B293.654%2C401.698%2C529.038%2C631.313%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%221%22%7D%7D&quot; width=&quot;392&quot; height=&quot;382&quot; src=&quot;attachments/JTY72Y4D.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>     然而，<span style="background-color: #5fb23680">评估跨语言的事实知识并非易事。确保结果的可比性要求以所有语言查询一组“普遍”事实，但该集合的选择可能偏向于在维基数据等流行知识库中代表性更高的特定世界区域.2相反，在世界其他地区更相关的事实（例如， 关于某一特定区域的地点或重要人物的信息）不太可能出现在基准中，这使得难以解释这种评估的结果</span>。</p><p>     在这项工作中，我们采取了不同的立场：我们没有衡量PLM在每种语言中编码的事实知识量，而是关注其跨语言的一致性。如图 1 所示，多语言 BLOOM-3b 模型当以英语、西班牙语和越南语查询时，输出始终正确完成第一个提示，但不是匈牙利语和希腊语。该模型还以英语、西班牙语和越南语（但不是匈牙利语和希腊语）对第二个查询输出一致但错误的答案，这表明前三种语言在模型中共享相关的知识表示。</p><p>     跨语言一致性 （CLC） 的研究很重要，至少有两个原因：首先，对事实的真正了解意味着无论给定的表面形式如何，都要对其含义进行编码（Ohmer 等人，2023 年）。因此，如果模型知道北京市是中国的首都，那么当用不同的语言询问相同的问题时，它应该返回相同的答案。从实际的角度来看，CLC 对于确保用户在不同语言与同一模型交互时具有相似的体验至关重要。其次，研究CLC对于了解在多语言PLM中以一种语言获得的知识是否以及如何隐含地转移到另一种语言非常重要。除了科学相关性外，这对将外部知识纳入多语言PLM具有实际意义。事实上，虽然多产的工作线侧重于模型编辑，作为以各种数据和计算效率的方式在 PLM 中插入新事实关联的一种方式（De Cao 等人，2021 年;侯等人，2022;Meng 等人，2022 年），据我们所知，还没有人研究过这如何影响直接应用编辑的语言以外的语言中的事实知识。</p><p>      我们对多语言PLM中的事实知识CLC进行了首次深入研究，并做出了以下贡献：（i）我们提出了一种新的基于排名的一致性（RankC）指标，该指标独立于准确性评估知识的一致性。（ii） 我们过滤现有的不平衡数据集（Jiang 等人，2020 年;Kassner 等人，2021 年）形成多并行 CLC 基准，平衡多语言模型分析 （BMLAMA），该基准将相同的一组提示翻译成所有语言。（iii）我们将新指标应用于BMLAMA，以评估各种仅编码器，仅解码器和编码器解码器PLM中的CLC，包括XLM-RoBERTa-large，mT5-large和BLOOM系列。我们分析了许多与CLC相关的语言属性，并为事实知识如何在语言之间渗透提供了新的见解。最后（iv）我们使用基于神经元可解释性的最先进的模型编辑技术（Meng 等人，2022 年）提供案例研究，提供初步证据，证明 CLC 可以预测插入语言 X 的事实是否会转移到语言 Y 中。</p><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2.Related Work"></a>2.Related Work</h2><p><strong>探索 PLM 中的事实知识</strong> 自 LAMA 首次提出以来（Petroni 等人，2019 年），基于提示的探测已成为评估 PLM 中事实知识的主要技术（Davison 等人，2019 年;布拉维等人，2020 年;申等人，2020;布朗等人，2020 年;阿尔甘米等人，2021 年;彭等人，2022 年）。给定元组（主体、关系、对象）中表示的知识，通过将主题填充到特定于关系的模板中来形成查询 q，该模板被馈送到 PLM 中。如果预测与对象一致，则认为模型具有此知识。例如，给定一组候选城市名称，当查询“中华人民共和国的首都是_”时，如果PLM在所有候选城市中正确答案“北京”的概率最高，则认为PLM捕获了这条知识。</p><p><strong>事实知识的多语言探索</strong> 除了大量关注英语的著作外，一些著名的研究通过将英语提示-对象对翻译成多种语言来多语言探索事实知识。X-FACTR（Jiang 等人，2020 年）和 MLAMA（Kassner 等人，2021 年）表明，由于其培训语料库的大小，不同语言的知识量之间存在很大差异。除了英语和少数其他高资源欧洲语言外，总体上报告的探测准确性非常低（即&lt;10%）。另一项相关工作， GeoMLAMA（Yin 等人，2022 年）专门探测了在不同地区可能有所不同的常识性知识，导致相当令人惊讶的发现，即探索某个国家（例如中国）知识的最佳语言通常不是给定国家的母语（例如中文）。所有这些研究的主要重点是评估每种语言编码的事实知识的数量，而不是了解这些知识如何在语言之间渗透。</p><p><strong>自洽性</strong> 自洽性是指 PLM 对同一查询的保留含义的释义输出相同答案的能力。英语PLM的自洽性在不同任务中都受到了关注（Li等人，2019;米切尔等人，2022 年;王等人，2023 年）。Fierro和Søgaard（2022）通过将自洽性的研究扩展到多语言PLM，方法是在每种语言中单独测量自洽性。他们的结果显示，所有语言的自洽性都很差。</p><p><strong>跨语言一致性</strong> 据我们所知，我们是第一个对多语言PLM中事实知识的跨语言一致性进行系统分析的公司，即PLM对不同语言提出的相同问题返回相同答案的程度。作为探索研究的一部分，Jiang等人（2020）计算了mBERT中两种语言之间重叠的正确预测的比例（参见第3.1节）。他们报告的总体比率较低，在最相似的对（英语 - 荷兰语）中只有34%的峰值，但没有进一步调查决定一致性的因素。此外，他们将这种分析限制在一个（仅编码器）模型，同时我们还检查了编码器-解码器和一系列仅解码器模型（参见第5.1节）。另一个区别是，<span style="color: #ff2020"><span style="background-color: #ff666680">我们对一致性采取了更全面的观点，即不正确但跨语言引用同一实体的预测也应被视为一致。</span></span>有趣的是，Ohmer 等人（2023 年）的并行工作建议使用模型预测的跨语言一致性作为评估其对特定单词形式之外的含义的理解的一种手段。他们在两个语言理解任务（释义识别和自然语言推理）中展示了他们的方法。尽管范围不同，但他们使用英语、德语和中文翻译对 ChatGPT 的评估表明，模型响应的一致性有限，这与我们的事实调查结果一致（参见第 5 节），并进一步表明这个问题在非常大规模的上一代 PLM 中仍然存在</p><h2 id="3-Measuring-Cross-Lingual-Consistentcy"><a href="#3-Measuring-Cross-Lingual-Consistentcy" class="headerlink" title="3.Measuring Cross-Lingual Consistentcy"></a>3.Measuring Cross-Lingual Consistentcy</h2><p><strong>任务定义</strong> 每种语言l ∈ L有一组定义为 Ql 的查询（即提示）。对于每个查询 qi ∈ Ql，有Ni对应候选项，例如，查询“史蒂夫乔布斯为 __ 工作”有 10 个候选者：苹果、任天堂、谷歌、WWE、亚历山大、德国、雅虎、柏林、BBC、Microsoft。每个查询都会馈送到 PLM，返回的概率用于计算每个候选单词的排名分数。分数计算取决于模型的类型（仅编码器、编码器解码器或仅解码器）以及候选单词分割为子单词的方式（请参阅附录 B 中的详细信息）。按排名分数排序后，Qi 的候选集表示为 {ci1， . . . ， cNi i }，其中 ci1 的预测概率最高，cNi i 的预测概率最低。请注意，现有的用于知识探测的多语言数据集（X-FACTR（Jiang 等人，2020 年）和 MLAMA（Kassner 等人，2021 年））在不同语言中具有不同数量的查询，这对于衡量一致性是有问题的。</p><h3 id="3-1Prioions-Work-Correct-Predictions-Overlap"><a href="#3-1Prioions-Work-Correct-Predictions-Overlap" class="headerlink" title="3.1Prioions Work:Correct Predictions Overlap"></a>3.1Prioions Work:Correct Predictions Overlap</h3><p>     基于每个 qi 和 q′ i 的预测 ci1 和 c′1 i（即排序候选列表的第一个元素），Jiang 等人 （2020） 计算正确预测的平均重叠率如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/UTGQ3CDQ-1698899466973-21.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/UTGQ3CDQ-1698899466973-21.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;UTGQ3CDQ&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22BSQLBJQX%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B303%2C459.39%2C527.5%2C518.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;374&quot; height=&quot;98&quot; src=&quot;attachments/UTGQ3CDQ.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 1（·) 是指示函数，oi 和 o′i 分别是 qi 和 q′ i 的正确答案。</p><p>     由于他们的基准测试包含不同语言的不同数量的查询，因此它们通过丢弃 l 或 l′ 中不可用的样本来过滤每个语言对 （l， l′） 的查询集：</p><p><img src="/../imgs/$%7Bfiilename%7D/CKJAUHAN-1698899465379-19.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/CKJAUHAN-1698899465379-19.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;CKJAUHAN&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22GIHZDH3X%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B307.5%2C333.39%2C526.5%2C367.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;365&quot; height=&quot;57&quot; src=&quot;attachments/CKJAUHAN.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p> <span style="background-color: #2ea8e580">由于筛选是分别对每个语言对完成的，因此这会导致不同的查询集，这限制了它们的结果在具有非常不同的筛选集的语言对之间的可比性。</span></p><h3 id="3-2This-Work-RankC-Metric"><a href="#3-2This-Work-RankC-Metric" class="headerlink" title="3.2This Work:RankC Metric"></a>3.2This Work:RankC Metric</h3><p><span style="background-color: #2ea8e580">为了确保不同语言对之间的可比性，我们要求基准测试中的所有查询及其相应的候选查询都翻译成所有语言。</span>因此，对于任何语言对 （l， l′），查询集的长度始终相等 |Ql|&#x3D; |Ql′|，第 i 个查询 Ni &#x3D; N ′ i 的候选项数也是如此。基于这些假设，我们提出了一种新的基于排名的一致性（RankC）指标，以有效地评估PLM中知识的跨语言一致性，而与准确性无关。<span style="background-color: #2ea8e580">我们不只是关注正确的预测，而是将所有候选的排名纳入考虑。</span>RankC的灵感来自信息检索的K（MAP@K）指标的平均平均精度（Schutze等人，2008）。与原版MAP@K不同，在 RankC K 中因查询而异。qi 的值 K 等于 Ni，即其候选者的数量。给定语言 l 和 l′，两种语言之间的一致性分数定义为所有翻译查询对 （qi， q′ i） ∈ （Ql， Ql′） 的一致性平均值：</p><p><img src="/../imgs/$%7Bfiilename%7D/4BUNNT2A-1698899462448-17.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/4BUNNT2A-1698899462448-17.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;4BUNNT2A&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22UWV6KRQ7%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B72%2C596.89%2C292.5%2C645.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;368&quot; height=&quot;81&quot; src=&quot;attachments/4BUNNT2A.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>每个查询对的一致性是通过加权平均 P @j 函数计算的，该函数输出具有前 j 个最高概率的候选函数之间的重叠比率3：</p><p><img src="/../imgs/$%7Bfiilename%7D/9E3DW5HT-1698899458937-15.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/9E3DW5HT-1698899458937-15.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;9E3DW5HT&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22IP7IB4WX%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B71.5%2C453.39%2C291%2C536.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;366&quot; height=&quot;139&quot; src=&quot;attachments/9E3DW5HT.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>每个 P @j的权重 wj 定义如下。</p><p><strong>基于排名的权重</strong> 直观地说，排名较高的候选人应该对一致性分数产生更大的影响。为了实现这一目标，RankC 对所有 P @js采用加权平均值，其中 j 较小的 P @j被赋予较高的权重 wj，以强调具有高概率的候选人的影响。但是，预测概率不能直接使用，因为它们对于 qi 和 q′ i 的候选者是不同的。为了解决这个问题，我们引入了基于softmax的归一化权重，而不是值j：</p><p><img src="/../imgs/$%7Bfiilename%7D/SGCTJSZD-1698899456427-13.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/SGCTJSZD-1698899456427-13.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;SGCTJSZD&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22B2LWRTBH%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B71.5%2C223.39%2C292%2C274.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;368&quot; height=&quot;86&quot; src=&quot;attachments/SGCTJSZD.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 Ni 是查询 qi 和 q′ i.4 的候选数量 结合等式 3、4 和 5，RankC 指标变为：</p><p><img src="/../imgs/$%7Bfiilename%7D/ML4DE4BX-1698899454568-11.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/ML4DE4BX-1698899454568-11.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;ML4DE4BX&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22UUK6AGQ7%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B69.5%2C92.89%2C291.5%2C180.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;370&quot; height=&quot;147&quot; src=&quot;attachments/ML4DE4BX.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>附录D给出了RankC计算示例，以及高&#x2F;低RankC的解释</p><p><img src="/../imgs/$%7Bfiilename%7D/UNBA9DMX-1698899452209-9.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/UNBA9DMX-1698899452209-9.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;UNBA9DMX&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22JHHBPXWD%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B299%2C662.89%2C527.5%2C774.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;381&quot; height=&quot;187&quot; src=&quot;attachments/UNBA9DMX.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>     我们在同一数据集上对RankC与以前使用的指标（COverlap，参见公式1)进行了实证比较。附录F中的结果表明，<span style="background-color: #2ea8e580">几乎所有具有高COVERLAP分数的语言对也获得了较高的RankC分数。此外，RankC揭示了一些新的高一致性对，由于探测精度低，它们的COverlap评分较低。</span></p><h2 id="4-Experimental-Setup"><a href="#4-Experimental-Setup" class="headerlink" title="4.Experimental Setup"></a>4.Experimental Setup</h2><p><strong>数据集</strong> 如第 3.2 节所述，RankC 要求将查询及其候选语言翻译成所有评估语言。因此，我们从 X-FACTR（Jiang 等人，2020 年）和 MLAMA（Kassner 等人，2021 年）中提取所有满足此标准的查询。我们将生成的多并行数据集称为平衡多语言模型分析（BMLAMA），并以两个版本发布：BMLAMA-17，包括17种语言的6.7k查询（接近X-FACTR，包括23种语言），BMLAMA-53包括53种语言的3k查询（与MLAMA相同）。详细统计数据如表1所示。</p><p><strong>模型</strong> 多语言知识探索的先前工作（Jiang等人，2020;Kassner 等人，2021 年）专注于仅编码器的 PLM，例如 mBERT（Devlin 等人，2019 年）或 XLM-RoBERTa（Liu 等人，2019 年）。然而，由于纯解码器 PLM 已成为当前 NLP 时代的主流，我们的实验还包括仅解码器的 BLOOM 系列（560m、1.1b、1.7b、3b 参数）（Scao 等人，2022 年）和编码器-解码器 mT5large （1.2b）（Xue 等人，2021 年），此外还包括仅编码器的 XLM-RoBERTa-large（354m）。</p><h2 id="5-Main-Consistency-Result"><a href="#5-Main-Consistency-Result" class="headerlink" title="5.Main Consistency Result"></a>5.Main Consistency Result</h2><p>在查看一致性之前，我们在图 2 中展示了 BMLAMA-17.5 上三个 PLM 的实际探测精度结果，我们首先注意到，<span style="background-color: #2ea8e580">仅编码器 XLM-RoBERTa-large 和编码器解码器 mT5-large 模型在平均探测精度方面优于整个仅解码器的 BLOOM 系列。三种型号的跨语言趋势相似，但是，BLOOM以远高于所有其他语言的英语准确性脱颖而出。</span><span style="background-color: #ff666680">关于模型大小（BLOOM 系列，绿条），我们发现增加参数数量会导致事实探测精度的轻微但一致的提高，</span>这与以前的工作一致（Petroni 等人，2019 年）。</p><p>    我们的XLM-RoBERTa-large结果与Jiang等人（2020）在XFACTR上报告的结果一致，证明了我们的多并行数据集BMLAMA的可靠性。</p><h3 id="5-1Consistency-in-Different-PLMs"><a href="#5-1Consistency-in-Different-PLMs" class="headerlink" title="5.1Consistency in Different PLMs"></a>5.1Consistency in Different PLMs</h3><p>图 3 显示了三种 PLM 的 RankC 结果。第一个观察结果是，所有模型的平均一致性6都相低，BLOOM3b（25%）最低。这一阴性结果与Jiang等人（2020）在mBERT上观察到的正确预测的低重叠率一致。</p><p>     <span style="background-color: #ff666680">我们现在放大了不同语言对之间的比较，这是通过新的RankC指标和平衡数据集BMLAMA实现的。在这里，我们发现欧洲语言英语，法语，荷兰语，西班牙语和加泰罗尼亚语在mT5-large和XLM-RoBERTa-large方面共享了相当多的知识。类似的模式适用于BLOOM-3b，但荷兰语除外，这是意料之中的，因为该语言未包含在此模型的训练语料库中。此外，越南语和土耳其语在所有PLM中都与上述欧洲语言实现了显着的一致性。这些语言的一个共同特点是它们都使用相同的脚本（拉丁语）。另一个值得注意的高一致性对是俄语和乌克兰语，使用相同脚本（西里尔文）并且也密切相关的两种语言。这些观察表明，各种语言属性会影响多语言知识的CLC。我们将在第 6.1 节中检查许多此类属性。</span></p><h3 id="5-2Effect-of-Model-Size"><a href="#5-2Effect-of-Model-Size" class="headerlink" title="5.2Effect of Model Size"></a>5.2Effect of Model Size</h3><p>如上所述（图 2 中的绿条）和之前的工作（Petroni 等人，2019 年）所观察到的，<span style="background-color: #ff666680">当其他因素固定时，检索正确知识的能力会随着模型大小的增长而增长。</span>我们问CLC是否也是如此。<span style="background-color: #5fb23680">然而，图4中的BLOOM结果显示，从我们系列中最小的模型移动到最大的模型时，平均RankC（+2%）只有很小的变化，即参数增加了5倍。</span>虽然这种模式不能安全地推广到其他模型，但它确实表明，在非常大规模的PLM中，跨语言一致性可能仍然是一个问题8。</p><h2 id="6-Typological-Similarity"><a href="#6-Typological-Similarity" class="headerlink" title="6.Typological Similarity"></a>6.Typological Similarity</h2><p>类型学特征已被证明可用于模拟语言之间的细粒度相似性，并指导各种多语言 NLP 任务的迁移学习技术（Ponti 等人，2019 年;尤斯图恩等人，2022 年）。这些特征是否也能解释在多语言PLM中观察到的事实知识一致性的一些差异？<span style="background-color: #2ea8e580">例如，我们可能期望具有相似语法和词序或具有相关词汇的语言共享更高的语言程度。在多语言模型中。我们可能还期望在同一世界地区使用的语言更有可能在训练数据中遇到相同实体和事件的提及。</span></p><p>     为了回答这个问题，我们从lang2vec（Littell等人，2017）获得了四种类型的<span style="background-color: #2ea8e580">类型相似性（句法，遗传，地理和语音）</span>，这是一个开源库，提供基于各种类型学数据库的预先计算的相似性.9接下来，我们计算RankC分数与BMLAMA中所有语言对的类型相似性之间的皮尔逊相关系数（Cohen等人，2009）。</p><p>     表2显示了BMLAMA-17和较小但多语言的BMLAMA-53.10的结果 对于BMLAMA-17，<span style="background-color: #ff666680">我们发现RankC与遗传相似性具有中等相关性，与地理相似性具有弱相关性，但与句法相似性没有显着相关性。正如预期的那样，没有观察到与语音相似性的相关性。更全面的数据集BMLAMA-53上的相关性结果相似，除了句法相似性获得弱正相关。</span>有点令人惊讶的是，在这个更大的数据集中，<span style="background-color: #5fb23680">遗传和地理上的相似性使它们的相关性略有下降，这可能是由于低资源语言的类型向量中存在噪声。</span></p><p>     遗传相关语言的一个重要特征是它们往往有很多单词共同或具有共同祖先。<span style="background-color: #ff666680">因此，RankC与遗传相似性的中等相关性，加上与句法和地理相似性的弱相关性，表明词汇重叠可能是CLC比具有相似的语法和词序或在附近地区使用更重要的因素。</span></p><h3 id="6-2Subword-Vocabulary-Overlap"><a href="#6-2Subword-Vocabulary-Overlap" class="headerlink" title="6.2Subword Vocabulary Overlap"></a>6.2Subword Vocabulary Overlap</h3><p>基于上述观察结果，我们研究了词汇重叠的粗略测量是否也可以很好地预测CLC。具体来说，我们提取了我们评估语言中严格平行语料库的词汇表，并测量它们的成对重叠：</p><p><img src="/../imgs/$%7Bfiilename%7D/9DVJYQ7U.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/9DVJYQ7U.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;9DVJYQ7U&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22Q2E54XNM%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%227%22%2C%22position%22%3A%7B%22pageIndex%22%3A6%2C%22rects%22%3A%5B%5B70.385%2C344.005%2C291.923%2C381.505%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%227%22%7D%7D&quot; width=&quot;369&quot; height=&quot;62&quot; src=&quot;attachments/9DVJYQ7U.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>我们考虑两个语料库：BMLAMA 本身和 Flores-200（Costa-jussà 等人，2022 年)。前者预计非常相关，但由此产生的相关性可能不太可推广，因为它是衡量一致性本身的同一语料库。相比之下，后者是一组混合域的 2k 个句子，从英语翻译成 200 种语言，用于机器翻译评估。因为我们对不同语言使用完全相同的单词表示的程度感兴趣，所以我们在测量词汇重叠之前用模型的分词器对语料库进行分割，这使得这个指标模型依赖于。</p><p>     如表2（右）所示，BMLAMA上的皮尔逊相关分数证明，<span style="background-color: #ff666680">子词词汇重叠对PLM中知识的跨语言一致性有显著的强烈影响，掩盖了遗传的影响</span></p><p><img src="/../imgs/$%7Bfiilename%7D/7UYEHQJN.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/7UYEHQJN.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;7UYEHQJN&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22I4F9IANM%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%227%22%2C%22position%22%3A%7B%22pageIndex%22%3A6%2C%22rects%22%3A%5B%5B294.808%2C500.928%2C528.462%2C596.698%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%227%22%7D%7D&quot; width=&quot;389&quot; height=&quot;159&quot; src=&quot;attachments/7UYEHQJN.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>相似。<span style="background-color: #ff666680">这表明事实知识可能主要以相当肤浅的方式（通过共享使用一些子词嵌入）渗透到语言之间，相反，即使语言相关，在没有这种锚点的情况下，它也可能受到阻碍。</span>例如，<span style="background-color: #2ea8e580">BLOOM-3b中一致性最高的对是乌克兰语-俄语，它们位于语言树中（遗传相似性：0.8），并且总体上共享大量子词词汇（词汇重叠：0.76）。然而，在查询大卫·卡梅伦的工作地点时，BLOOM-3b预测的是俄语查询（“伦敦”）中的正确答案，但乌克兰语（“莫斯科”）中的错误答案。</span>这表明<span style="background-color: #2ea8e580">正确的知识没有从俄语转移到乌克兰语，因为这两个查询之间的子词重叠有限（0.17）。</span>当在Flores上测量词汇重叠时（表2的最后一列），相关性较低，但仍然显着为正，表明我们的发现不仅限于我们的基准。跨语言知识一致性与词汇重叠之间的相关性如图5所示。<span style="background-color: #2ea8e580">CLC对浅词汇重叠的强烈依赖部分解释了为什么增加模型大小没有积极的影响</span>（参见第5.2节)。<span style="background-color: #5fb23680">我们推测，较大的子单词词汇实际上可能导致较低的一致性，因为在任何两种语言之间共享部分单词的机会会降低。我们将对这一假设的进一步调查留给未来的工作。</span></p><h2 id="7-Case-Study-Cross-Lingual-Consistency-and-Knowledge-Incorporation"><a href="#7-Case-Study-Cross-Lingual-Consistency-and-Knowledge-Incorporation" class="headerlink" title="7.Case Study: Cross-Lingual Consistency and Knowledge Incorporation"></a>7.Case Study: Cross-Lingual Consistency and Knowledge Incorporation</h2><p>之前的工作（Jiang et al., 2020；Kassner et al., 2021；Artetxe et al., 2022）和我们的探索结果表明，低资源语言的知识量是有限的。简单地在更大的非英语语料库上训练新的 PLM 非常耗时，而且大多数大学和其他研究机构都无法承担其成本（Ding 等人，2022）。<span style="background-color: #2ea8e580">一个有前景的解决方案是通过微调方法整合外部知识（Hu et al., 2022）或以非常有针对性的方式直接编辑 PLM 的权重</span>（De Cao et al., 2021；Meng et al., 2022）。<span style="background-color: #2ea8e580">为了使该过程在多语言场景中可行并避免意外影响，重要的是要了解以一种语言插入知识是否以及如何影响 PLM 中的其他语言，包括最易受影响和最不易受影响的语言</span>。在本节中，我们将针对这个问题及其与 CLC 的相互作用进行第一个案例研究。</p><p><strong>Rank-One 模型编辑（ROME）</strong>由Meng 等人提出。 (2022)，这种基于神经元可解释性的最先进的模型编辑技术在特异性和泛化方面都优于其他几种编辑技术。简而言之，<span style="background-color: #2ea8e580">该技术直接修改 PLM 早期前馈层中的权重，其中事实关联已通过因果干预找到。</span></p><p>**反事实知识 **遵循孟等人。 （2022），我们考虑将反事实知识插入 PLM 的任务，例如事实上错误的“史蒂夫·乔布斯曾为微软工作”。由于在预训练期间从未观察到此类事实关联，因此这种方法避免了插入模型已认为可能的事实的风险。</p><p><strong>案例研究</strong> 我们研究了 BLOOM-3b，因为 ROME 目前仅适用于仅解码器模型。选择英语作为插入事实的源语言。作为目标语言，我们选择两种与英语具有高度一致性（RankC）的语言（西班牙语和越南语）和两种RankC 较低（匈牙利语和希腊语）。这些语言在脚本和与英语的相关性方面也各不相同。通过确保 PLM 在编辑之前选择最有可能的最初正确答案来挑选六个查询。我们还确保，对于每个编辑的知识，主题和客体实体在所有语言中都是相同的标记。这消除了这样的担忧：例如，西班牙语和越南语仅仅因为所评估的查询中主语和宾语标记的词汇共现而获得与英语一致的预测。对于评估，我们遵循孟等人的设置。 （2022）并将候选集缩小为两个单词——一个正确，一个错误。后者是ROME的编辑目标。根据每个查询，PLM 计算正确和错误答案的 logit 值，分别为 logitC 和 logitW。这些 logits 在不同语言之间差异很大。为了关注原始事实和编辑事实之间的关系，我们按照之前的工作（Sarti et al., 2023）将 logits 标准化为</p><p><img src="/../imgs/$%7Bfiilename%7D/JTSVCJAA.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/JTSVCJAA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;JTSVCJAA&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRSQJFTAR%22%2C%22annotationKey%22%3A%22LQTSE2UG%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B300.577%2C424.775%2C526.731%2C775.544%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FRHFZGHTF%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;377&quot; height=&quot;585&quot; src=&quot;attachments/JTSVCJAA.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>     表 3 显示了三个查询的结果。一个非常清晰的模式出现了：<span style="background-color: #ff666680">当一个事实被插入到英语中时，它会一致地传播到高 CLC 语言（即西班牙语和越南语）。相反，低 CLC 语言（匈牙利语和希腊语)受到的影响要小得多，即使在模型编辑后，仍然会输出更高的正确答案概率。</span>附录 J 中给出的其余三个查询显示了相同的模式。</p><p>    尽管我们的研究规模较小，但结果表明，<span style="background-color: #5fb23680">CLC 不仅是 PLM 中现有知识的副产品，而且还代表了在将新知识融入其他语言时对语言扰动的敏感性。</span>我们认为这是增强多语言场景中模型编辑优势的一个有前途的方向。</p><h2 id="8-Conclusion"><a href="#8-Conclusion" class="headerlink" title="8.Conclusion"></a>8.Conclusion</h2><p>我们分析了多语言大型 PLM 中事实知识的跨语言一致性 (CLC)。我们提出了一个新的指标 RankC，用于独立于准确性来量化一致性，并将其应用于跨语言平衡的事实知识基准。我们的综合分析表明，<span style="background-color: #ff666680">(i) 不同 PLM 的平均 CLC 较低，并且不受模型大小的明显影响；</span> <span style="background-color: #ff666680">(ii) PLM 内不同语言对的 CLC 与遗传相似性显着相关，但与词汇重叠的相关性明显更强；</span> <span style="background-color: #ff666680">(iii) 通过模型编辑插入到语言 X 中的新事实更有可能传播到具有 X 的 CLC 分数较高的语言。</span></p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>由于 GPU 资源的限制，我们无法测试大于 BLOOM-7.1b 的模型。鼓励在未来的工作中将我们的分析扩展到更大规模的模型，看看是否得出相同的结论。<span style="background-color: #5fb23680">然而，图4的结果表明，随着模型规模的增加，平均CLC增长极其缓慢。 BMLAMA 中包含的事实虽然被认为具有普遍性，但可能与西方世界更相关，这可能会在评估中引入偏见。我</span>们从 BMLAMA 所建立的基准中继承了这个问题。解决这个问题并非易事，特别是在比较工作中，需要探究跨语言的确切事实集，并且应该在未来的工作中予以关注。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们可以编辑多模态大型语言模型吗？</title>
      <link href="/2023/11/02/wo-men-ke-yi-bian-ji-duo-mo-tai-da-xing-yu-yan-mo-xing-ma/"/>
      <url>/2023/11/02/wo-men-ke-yi-bian-ji-duo-mo-tai-da-xing-yu-yan-mo-xing-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="我们可以编辑多模态大型语言模型吗？"><a href="#我们可以编辑多模态大型语言模型吗？" class="headerlink" title="我们可以编辑多模态大型语言模型吗？"></a>我们可以编辑多模态大型语言模型吗？</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在本文中，我们重点关注编辑多模态大型语言模型（MLLM）。与编辑单模态LLMs相比，多模态模型编辑更具挑战性，需要在编辑过程中进行更高水平的审查和仔细考虑。为了促进这一领域的研究，我们<span style="background-color: #ff666680">构建了一个名为 MMEdit 的新基准，用于编辑多模式LLMs并建立一套创新的评估指标</span>。我们进行了涉及各种模型编辑基线的综合实验，并分析了编辑不同组件对多模式LLMs的影响。根据经验，我们注意到<span style="background-color: #ff666680">以前的基线可以在一定程度上实现多模态 LLM 的编辑，但效果仍然差强人意，这表明这项任务的潜在难度。</span>我们希望我们的工作能够为 NLP 社区提供见解1。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>随着大型语言模型 (LLM) 的广泛部署（Zhao 等人，2023），在不产生大量再培训成本的情况下保持其知识准确和最新的必要性变得越来越重要（Sinitsin 等人，2020）。<span style="background-color: #2ea8e580">先前的研究引入了知识编辑方法，旨在逐步向语言模型注入一组新的事实</span>（Mitchell 等人，2022a；Han 等人，2023；Hartvigsen 人，2022；Zhong 等人，2023；Gandikota等人，2023；姚等人，2023）。</p><p>      与单模态模型编辑不同，多模态LLMs的编辑任务因其固有的多样性和复杂性而面临相当大的挑战。具体来说，<span style="background-color: #5fb23680">多模式模型的错误输出可能源于各种模式的协同效应。输出不正确可能不仅仅源于LLMs，类似于误读或误识别等人为错误</span>（例如，色盲影响图像中的颜色识别）。如图1所示，在编辑之前，模型将物体错误地识别为“梯子”而不是正确的“障碍物”，从而导致错误的预测。编辑后，模型准确识别了“障碍”。请注意，多模态LLMs（Yin et al., 2023）的效用正在增加，<span style="background-color: #5fb23680">但缺乏相应的数据集资源和用于编辑多模态大语言模型的基准。</span></p><p>     为了促进这一领域的研究，我们第一步构建了一个多模态模型编辑基准：<span style="background-color: #ff666680">称为 MMEdit，它包含两个子任务：编辑 VQA 和编辑图像标题。</span>具体来说，我们<span style="background-color: #ff666680">遵循单模态模型编辑方法（Mitchell et al., 2022a；Cao et al., 2021；Mitchell et al., 2022b）来构建数据集，这扩展了之前的评估原则，即 Reliability2、Locality3 和通用性4，多模式设置。对于可靠性评估，我们从严格的数据收集开始，收集表现不佳的多模态模型数据来创建专用的可靠性编辑数据集（§3.2.1）。对于局部性评估，我们将其分为文本局部性和多模态局部性，以评估多模态 LLM 的稳定性（第 3.2.2 节）。对于通用性评估，与局部性类似，我们将其分为文本通用性和多模态通用性，并利用 ChatGLM (Du et al., 2022) 和稳定扩散 (Rombach et al., 2022) 生成重新措辞的文本以及重新措辞的图像进行评估（第 3.2.3 节）。我们评估了 MMEdit 上的几种知识编辑方法。</span>根据经验，我们注意到<span style="background-color: #5fb23680">当前的编辑方法对于编辑多模态语言模型中的文本模型有效，但对于编辑视觉模块则不那么有效</span>。例如，在编辑BLIP-2模型的语言模块时，MEND的可靠性可以达到92.6%，但在编辑视觉模块时只能达到14.1%，表明该任务的潜在难度和机遇。总的来说，我们的主要贡献如下：</p><ul><li>我们迈出了第一步，研究编辑多模态LLMs，将模型编辑扩展到多模态设置。</li></ul><!----><ul><li>我们提出了MMEdit，一个新的基准，用于评估多模态模型编辑方法的可靠性、局部性和通用性。</li></ul><!----><ul><li>我们使用各种基线进行实验，证明虽然当前的方法可以在一定程度上帮助多模式编辑，但结果仍然达不到完全满意的程度。我们将公开代码和数据集以用于未来的研究目的。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><h3 id="2-1-Multimodal-Language-Models"><a href="#2-1-Multimodal-Language-Models" class="headerlink" title="2.1 Multimodal Language Models"></a>2.1 Multimodal Language Models</h3><p>     多模态学习 (MML)（Xu 等人，2022a；Yin 等人，2023）提供了一种构建 AI 模型的整体方法，该模型可以从各种数据模态中提取和关联信息。由于其社会意义，MML 在研究界站稳了脚跟，在过去十年中巩固了自己作为一个重要研究领域的地位。视<span style="background-color: #2ea8e580">觉语言预训练是MML的重要分支之一，旨在学习在各种视觉和语言任务上具有改进性能的多模态基础模型</span>。 Vision Transformer (ViT)（Dosovitskiy et al., 2021）<span style="background-color: #2ea8e580">是一项开创性的工作，贡献了端到端将 Transformers 的编码器应用于图像的解决方案。</span> CLIP（Radford et al., 2021）<span style="background-color: #2ea8e580">提出了一种方法，使用多模态预训练将分类转换为检索任务，使预训练模型能够解决零样本识别问题</span>。最近，LLaMA (Touvron et al., 2023)、BLOOM (Scao et al., 2022) 和 ChatGPT (OpenAI, 2022) 等 LLM 的进步得到了扩大训练数据和增加参数的支持，最近取得了重大成功。这些模型展示了令人印象深刻的语言理解、生成和知识推理能力，增强了它们理解自然语言和生成高质量、基于上下文的文本的能力。大型语言模型的发展刺激了自回归语言模型作为视觉语言任务中的解码器的广泛使用。<span style="background-color: #2ea8e580">利用跨模态迁移，这种方法可以实现语言和多模态领域之间的知识共享</span>（Gao et al., 2023; Liu et al., 2023; Li et al., 2023a; Ye et al., 2023; Zhu et al., 2023；Li 等人，2023b；Zhang 等人，2023）。</p><h3 id="2-2-Model-Editing"><a href="#2-2-Model-Editing" class="headerlink" title="2.2 Model Editing"></a>2.2 Model Editing</h3><p>     LLMs（Zhao et al., 2023）主要从训练语料库中获取知识。然而，数据集的质量并不总是得到保证，可能会将有害或不正确的信息集成到模型中（Hernandez 等人，2023）。<span style="background-color: #2ea8e580">一种解决方案是使用更新的知识重新训练模型，尽管这可能成本高昂且难以实施</span>。或者，<span style="background-color: #2ea8e580">可以考虑使用一些更新的事实进行微调，但它存在过度拟合和灾难性遗忘的风险</span>（Zhai et al., 2023）。为了解决这些问题，（Sinitsin et al., 2020）提出了模型编辑，旨在高效、准确地改变模型中存储的事实知识。这种方法应用于各个领域（Mao et al., 2023; Onoe et al., 2023; Xu et al., 2022b; Wang et al., 2023a; Li et al., 2023c），并且研究数量不断增加调查编辑的影响（Ilharco 等人，2023；Gupta 等人，2023；Hase 等人，2023；Cohen 等人，2023；Wu 等人，2023；Wang 等人，2023b；Gandikota 等人等人，2023；Li 等人，2023d）。目前，模型编辑方法主要有三种类型：<span style="background-color: #2ea8e580">1）元学习方法，2）定位然后编辑方法，3）上下文知识编辑方法。</span></p><p><strong>元学习方法</strong>。 MEND（Mitchell 等人，2022a）和知识编辑器 (KE)（Cao 等人，2021）提出了<span style="background-color: #2ea8e580">涉及外部编辑器的方法，能够学习用于知识更新的最佳参数集 θ，同时施加约束以保持模型稳定性。</span> CaliNET (Dong et al., 2022) 和 T-Patcher (Huang et al., 2023) 从 (Dai et al., 2022) 中汲取灵感，<span style="background-color: #2ea8e580">将额外的可训练参数引入到预训练语言模型的前馈模块中。</span> SERAC（Mitchell 等人，2022b）<span style="background-color: #2ea8e580">利用显式记忆来存储编辑，并学习对它们进行推理，以根据需要调整基本模型的预测。</span></p><p><strong>定位然后编辑方法</strong>。 ROME（Meng et al., 2022a）<span style="background-color: #2ea8e580">提出了采用因果中介分析来识别编辑区域的方法。</span> ROME 发现记忆的事实关联可以精确定位到 GPT 模型中的特定位置。然而，ROME 的一个显着限制是它一次只能编辑一个事实。为了解决这个问题，Meng 等人。 (2022b)提出了一种称为MEMIT的新方法，<span style="background-color: #2ea8e580">它是之前工作ROME的继承者，它对单层的MLP权重进行rankone修改，以将内存直接写入模型中。</span></p><p><strong>上下文知识编辑方法</strong>。 InContext Learning (ICL)（Brown et al., 2020）<span style="background-color: #2ea8e580">表示一种免训练范式，其中知识是从输入上下文中直接串联的演示中获取的</span>。最近出现了一种新颖的编辑范式，它<span style="background-color: #2ea8e580">利用LLMs理解上下文的能力（Zheng et al., 2023），从而实现基于上下文的模型编辑，指导模型的生成过程，并提供高效、轻量级的模型方法编辑</span>。迄今为止的模型编辑方法主要迎合单模态场景，在多模态编辑方面留下了空白。据我们所知，我们是第一个研究LLMs多模式模型编辑的人，并为促进该领域的研究提供了新的基准。</p><h2 id="3-Editing-Multimodal-LLMs"><a href="#3-Editing-Multimodal-LLMs" class="headerlink" title="3 Editing Multimodal LLMs"></a>3 Editing Multimodal LLMs</h2><p>我们在图 2 中说明了多模态编辑的建议任务。我们将介绍任务定义（§3.1）、（§3.2）中的数据集构建细节、多模态模型（§3.3）以及我们在实验。</p><p><img src="/../imgs/$%7Bfiilename%7D/KQ9KJ8DQ.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/KQ9KJ8DQ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;KQ9KJ8DQ&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22MS6FUQ8I%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B68.654%2C497.467%2C526.731%2C777.852%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;763&quot; height=&quot;467&quot; src=&quot;attachments/KQ9KJ8DQ.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="3-1-Task-Definition"><a href="#3-1-Task-Definition" class="headerlink" title="3.1 Task Definition"></a>3.1 Task Definition</h3><p>假设我们有一个由 *θ <em>参数化的多模态 LLM</em> f *（由两部分组成，由 θ<sub>vision</sub> 和 θ<sub>text</sub> 参数化的 f<sub>vision</sub> 和 f<sub>text </sub>），将输入 i<sub>e</sub> 和 x<sub>e</sub> 映射到 y<sub>o</sub> 的预测，其中 i<sub>e </sub>指的是编辑图像输入，xe 指的是编辑文本提示输入和 y<sub>o</sub> 表示为原始输出。我们将 M 表示为特定指标的符号表示，下标表示特定度量，上标表示变化编辑数据。我们准备第 3.2.1 节中所述的编辑数据集，其表示为 Dedit。受到姚等人的启发。 （2023），我们引入了一系列多模式模型编辑指标。</p><p><img src="/../imgs/$%7Bfiilename%7D/ZFVB46CA.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/ZFVB46CA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;ZFVB46CA&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22MJQK4385%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B64.853%2C526.008%2C292.5%2C791.596%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;379&quot; height=&quot;442&quot; src=&quot;attachments/ZFVB46CA.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><strong>可靠性</strong>。需要编辑可靠性才能将预测从 y<sub>o</sub> 更改为 y<sub>e</sub>。直观上，我们需要的是更新后的 θe，其中 f（即 x<sub>e</sub>;θ<sub>e</sub>）&#x3D; y<sub>e</sub>。为了衡量可靠性，我们使用编辑准确性，如下所述：</p><p><img src="/../imgs/$%7Bfiilename%7D/HSTRNPML.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/HSTRNPML.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;HSTRNPML&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22NS7JGJWI%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B68.824%2C342.919%2C292.059%2C378.214%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;372&quot; height=&quot;59&quot; src=&quot;attachments/HSTRNPML.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中θ<sub>e</sub>指的是编辑后的参数。</p><p><strong>局部性</strong>。为了保持模型的稳定性，必须最大限度地减少编辑对模型更广泛的知识库造成的意外副作用。为了实现这一目标，我们引入了两个指标：M <sup>Text</sup> <sub>loc</sub> (T-Locality) 和 M<sup>Image</sup> <sub>loc</sub> (M-Locality)，这两个指标都是为了在编辑过程中保持模型的稳定性。鉴于多模态语言模型中的知识是从LLMs继承的，保护这些知识至关重要。考虑到这一目标，我们搁置了模型的视觉辨别模块，而是采用基本的问答数据集 D<sub>loc-t</sub>，如第 3.2.2 节中所述。我们定义问题为x，答案为y，如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/J24EN8UP.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/J24EN8UP.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;J24EN8UP&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22M2ZHI4QM%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B67.941%2C93.214%2C292.941%2C133.361%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;375&quot; height=&quot;67&quot; src=&quot;attachments/J24EN8UP.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>视觉编码器在多模态语言模型中发挥着关键作用，将将图像转换为矢量表示，以便与自然语言文本共同编码。</p><p><img src="/../imgs/$%7Bfiilename%7D/IPZFZHUW.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/IPZFZHUW.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;IPZFZHUW&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22ZIQHSJG7%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B301.765%2C653.066%2C528.529%2C777.919%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;378&quot; height=&quot;208&quot; src=&quot;attachments/IPZFZHUW.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>因此，我们必须考虑对该模块进行任何修改的潜在后果。我们构建表示为 D<sub>loc-v</sub> 的数据集用于测试 MImage loc ，并计算如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/4NC86SS7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/4NC86SS7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;4NC86SS7&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22K2BYGI7E%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B302.647%2C522.478%2C532.941%2C557.772%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;384&quot; height=&quot;59&quot; src=&quot;attachments/4NC86SS7.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中（iv，xv，yv）是范围外数据，θe表示编辑数据更新的参数（即xe，ye)。</p><p><strong>泛化性</strong>。在整个编辑过程中，仅仅修改个别错误的输入是不够的。修订后的模型还应保留泛化能力，并始终为等效输入（例如改写的句子）生成一致的输出，如图 3 所示。虽然以前的单模态模型编辑任务仅需要考虑改写的文本，但多模态场景需要泛化以及图像。为了解决这个问题，我们引入了两个泛化考虑因素：MText gen (TGenerality) 和 MImage gen (M-Generality)，其表示如下：</p><p><img src="/../imgs/$%7Bfiilename%7D/BS3DHYZH.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/BS3DHYZH.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;BS3DHYZH&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%22SSPQQ5PC%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B303.088%2C236.596%2C527.206%2C296.596%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;374&quot; height=&quot;100&quot; src=&quot;attachments/BS3DHYZH.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 ir 表示重新表述的图像，xr 指重新表述的文本提示，N (x) 表示 x 范围内的对象。</p><h3 id="3-2-Datasets"><a href="#3-2-Datasets" class="headerlink" title="3.2 Datasets"></a>3.2 Datasets</h3><p>我们构建的数据集MMEdit主要包含两个子任务：编辑VQA（E-VQA）和编辑图像标题（E-IC）。</p><h4 id="3-2-1-Reliability-Dataset-Construction"><a href="#3-2-1-Reliability-Dataset-Construction" class="headerlink" title="3.2.1 Reliability Dataset Construction"></a>3.2.1 Reliability Dataset Construction</h4><p>为了对我们的实验进行基准测试，我们选择了两个常见的多模态任务：视觉问答（VQA）（Antol et al., 2015）和图像</p><p><img src="/../imgs/$%7Bfiilename%7D/TT279E4N.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/TT279E4N.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;TT279E4N&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%229KCXYY3D%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%225%22%2C%22position%22%3A%7B%22pageIndex%22%3A4%2C%22rects%22%3A%5B%5B60%2C488.39%2C297%2C778.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%225%22%7D%7D&quot; width=&quot;395&quot; height=&quot;483&quot; src=&quot;attachments/TT279E4N.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>字幕（Herdade 等人，2019）。 <span style="background-color: #2ea8e580">VQA 旨在设计一种算法，不仅可以理解图像中的视觉内容，还可以理解用于查询该图像的自然语言，并随后生成这些查询的精确答案</span>。<span style="background-color: #2ea8e580">图像字幕是设计能够理解图像视觉内容的算法，随后用自然语言生成连贯且精确的图像描述</span>。在本研究中，我们选择 BLIP-2 OPT。我们的基础编辑数据源自两个评估数据集的次优条目，即 VQAv2（Goyal 等人，2017）和 COCO Caption（Chen 等人，2015)。</p><p>     除了基本的编辑数据之外，利用其他数据也至关重要。这些数据不仅有助于编辑过程，还验证更改的有效性，评估模型编辑的稳定性和通用性。</p><h4 id="3-2-2-Locality-Dataset-Construction"><a href="#3-2-2-Locality-Dataset-Construction" class="headerlink" title="3.2.2 Locality Dataset Construction"></a>3.2.2 Locality Dataset Construction</h4><p>我们必须仔细考虑多模态模型中编辑对语言功能的影响，<span style="background-color: #5fb23680">类似于我们如何评估手术后个体大脑的各个认知区域。</span></p><p><strong>文本局部性数据集</strong>。为了评估语言模型的稳定性，我们利用之前在 MEND 中使用的 NQ 数据集（Kwiatkowski 等人，2019）作为模型内 LLM 组件稳定性的基准。我们专门使用模型的输出预编辑和后期编辑来构建 KL 散点图，从而促进对模型编辑的约束。此外，我们还计算了保持 top-1 状态的实例比例，进一步量化了模型的稳定性。</p><p><strong>多模态局部性数据集</strong>。同样，验证编辑对视觉模块的影响也至关重要。因此，我们在多模态领域使用简单的数据集 OK-VQA（Marino 等人，2019），作为多模态视觉模块局部性的度量。我们再次在编辑过程之前和之后使用 logits 更新 KL 离散度约束。</p><h4 id="3-2-3-Generality-Dataset-Construction"><a href="#3-2-3-Generality-Dataset-Construction" class="headerlink" title="3.2.3 Generality Dataset Construction"></a>3.2.3 Generality Dataset Construction</h4><p>我们在多模态模型中提出了两种形式的通用性。共性数据集构建的整体流程如图4所示。</p><p><strong>文本泛化数据集</strong>。值得注意的是，LLMs表现出强大的会话能力和强大的解决问题的能力，这使我们能够制定任务指令，从而指导模型生成类似的文本输入。对于 E-VQA 任务，我们利用 ChatGLM（Du et al., 2022；Zeng et al., 2022）生成类似的查询。然而，对于E-IC任务，由于提示的简洁和相对直接，模型生成的输出质量并不令人满意。因此，我们采用手动编写的包含20条提示的模板来随机替换原来的提示。</p><p><strong>视觉泛化数据集</strong>。近年来，<span style="background-color: #2ea8e580">扩散模型（Ho et al., 2020）在图像生成领域取得了巨大成功。超越最初最先进的模型</span>：生成对抗网络（GAN）模型（Goodfellow 等人，2014）。扩散模型在许多图像生成任务中表现出色，并在各个应用领域中表现出了值得称赞的性能。<span style="background-color: #2ea8e580">稳定扩散（Rombach 等人，2022）是一种潜在的文本到图像扩散模型，能够根据给定的文本输入生成逼真的图像</span>。我们利用稳定扩散 2.1 来生成重新解释的图像。该数据集利用 COCO 数据集的标题描述来评估模型的图像泛化能力。</p><h3 id="3-3-Multimodal-Language-Models"><a href="#3-3-Multimodal-Language-Models" class="headerlink" title="3.3 Multimodal Language Models"></a>3.3 Multimodal Language Models</h3><p><strong>BLIP-2 OPT</strong>。 BLIP-2（Li et al., 2023b）<span style="background-color: #2ea8e580">是一种通用且高效的预训练策略，可从现成的冻结预训练图像编码器和冻结大型语言模型引导视觉语言预训练。该模型利用轻量级查询转换器来弥合视觉模态和文本模态之间的差距，并在各种视觉语言任务上实现最先进的性能</span>。我们选择 BLIP-2 OPT 作为基本编辑模型，它在视觉模块中利用 ViT-L，并选择无监督训练的 OPT 模型用于基于解码器的 LLM。迷你GPT-4。</p><p><strong>MiniGPT-4</strong>（Zhu et al., 2023）是一种类似于 BLIP-2 的有效视觉语言模型，利用冷冻视觉编码器与冷冻 Vicuna（Chiang et al., 2023）相结合。据报道，基于 LLaMA 构建的 Vicuna 根据 GPT-4 的评估标准达到了 ChatGPT 90% 的性能。 MiniGPT-4 添加了一个投影层，以使编码的视觉特征与 Vicuna 语言模型保持一致。 MiniGPT-4 采用与 BLIP-2 相同的预训练视觉组件，由 EVA-CLIP（Sun 等人，2023）的 Vit-G&#x2F;14 和 Q-Former 组成。</p><h3 id="3-4-Baselines"><a href="#3-4-Baselines" class="headerlink" title="3.4 Baselines"></a>3.4 Baselines</h3><p><strong>Finetune</strong>。微调已成为一种广泛采用的策略，用于使预训练的语言模型适应特定任务或领域（Cortes 等人，2015）。在我们的探索中，我们深入研究了两种不同的微调方法：一种专注于语言模型的最后一层。以BLIP-2 OPT模型为例，我们对OPT模型的第31个解码器层进行微调。另一个目标是多模态语言模型中的视觉块，具体来说，我们微调 Q-former 模型以过度拟合编辑数据集。</p><p><strong>MEND</strong>。具有梯度分解的模型编辑器网络（Mitchell 等人，2022a）使用单个输入输出对对语言模型进行高效的本地编辑。本质上，MEND 学习转换微调 LLM 的梯度，它利用梯度的低秩分解。</p><p><strong>KE</strong>。 KE（Cao et al., 2021）是一种可以编辑语言模型中错误知识而无需重新训练整个模型的方法。 KE 利用具有约束优化的超网络（双向 LSTM），用于预测推理过程中的权重更新。</p><p><strong>SERAC</strong>。 SERAC（Mitchell 等人，2022b）引入了一种基于内存的模型编辑方法，该方法利用显式内存系统来缓存编辑。该内存随后用于在推理过程中调整基本模型的输出。该系统利用一个小型辅助范围分类器和反事实模型。范围分类器的作用是确定输入是否在内存缓存的范围内。如果在此范围内找到输入，则会将其与最相关的缓存项结合起来，并输入到反事实模型中进行预测。</p><p>**In-Context Knowledge Editing.**。上下文知识编辑（IKE）（Zheng et al., 2023）构造 k 个演示 C &#x3D; {c1, . 。 。 , ck }，遵循 Liu 等人中概述的方法。 （2022）。该方法采用基于余弦相似度的无监督检索器，在将事实 f &#x3D; (x*, y*) 注入语言模型之前从训练集中获取演示。 x* 是探索模型中事实知识的提示（例如，美国总统是），y* 将是编辑目标乔·拜登。上下文演示的排名也取决于余弦相似度：cos(c1, f ) &lt; cos(c2, f ) &lt; · · · &lt; cos(ck, f )。其中 c1, . 。 。 , ck 在上下文中从左到右顺序排列。演示 C 可以被视为外部增强的知识库，主要设计用于指导 LM 内的生成。其最终目标是当提示符x落在目标提示符x*的编辑范围内时，最大化P(y|x,f,C)。</p><h2 id="4-Experiments"><a href="#4-Experiments" class="headerlink" title="4 Experiments"></a>4 Experiments</h2><h3 id="4-1-Results"><a href="#4-1-Results" class="headerlink" title="4.1 Results"></a>4.1 Results</h3><p>在这一部分中，我们对 MMEdit 上的多种编辑方法进行了比较分析。这些比较的结果如表2所示。之后，我们深入研究了实验结果的三个指标，包括可靠性、局部性和通用性三个方面。此外，我们通过文本和视觉方式分析局部性和通用性，并在图 6 中提供了几个编辑案例。</p><p><strong>可靠性</strong>。从结果来看，<span style="background-color: #ff666680">所有模型编辑方法在可靠性方面均优于基本方法</span>。特别是，<span style="background-color: #ff666680">利用外部存储器进行编辑的 IKE 和 SERAC 方法在多模态语言中表现出了值得称赞的性能楷模</span>。我们<span style="background-color: #ff666680">观察到微调方法的性能比模型编辑方法差</span>。请注意，<span style="background-color: #5fb23680">仅微调 LLM 或模态融合模块的参数并不能充分捕获多模态数据的特征</span>。我们分析原因为如下：<span style="background-color: #5fb23680">用于微调的数据与原始模型有较大差异，例如Q-former和OPT模型，需要有效协作。简单地微调这些模块之一可能无法准确捕获特定于任务的特征。另一方面，微调所有模块会产生大量的资源开销</span>。此外，<span style="background-color: #ff666680">根据我们的实验结果，我们观察到微调可能会导致原始模型发生重大变化，通常会导致其他知识的丢失，在多模式数据集中尤其明显。</span></p><p><img src="/../imgs/$%7Bfiilename%7D/WSEXRRE8.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/WSEXRRE8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;WSEXRRE8&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%229DEQKYBI%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%227%22%2C%22position%22%3A%7B%22pageIndex%22%3A6%2C%22rects%22%3A%5B%5B68.077%2C533.813%2C530.769%2C783.044%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%227%22%7D%7D&quot; width=&quot;771&quot; height=&quot;415&quot; src=&quot;attachments/WSEXRRE8.png&quot; ztype=&quot;zimage&quot;&gt;"><br><strong>局部性</strong>。<span style="background-color: #ff666680">几种传统的编辑方法仍然适用于多模式编辑</span>，这对于有效修改模型内的知识并纠正其输出很有价值。然而，IKE和SERAC尽管在可靠性方面表现出色，但由于缺乏对M-Locality的约束而在M-Locality上表现不佳，<span style="background-color: #5fb23680">这表明尽管这些基于外部存储器的编辑技术无疑成功地修复了输出，但它们在稳定内部模型中的知识还有改进的空间。</span>对于T-Locality，大多数模型编辑方法都获得了良好的性能，而IKE再次表现不佳。根本原因是其他三种方法对T-Locality施加了约束，而IKE作为InContext Learning方法缺乏鲁棒的约束机制，导致性能不佳。</p><p><strong>泛化</strong>。我们在 E-VQA 中与 MiniGPT-4 进行了各种方法的文本和图像泛化能力的比较探索。请注意，<span style="background-color: #ff666680">KE 往往表现出较低程度的图像泛化，这主要是由于其在训练阶段对 M 局部性的固有考虑。</span>因此，<span style="background-color: #ff666680">与基于记忆的方法相比，元学习方法的图像泛化效率往往较低。另一方面，基于内存的方法所表现出的卓越图像泛化能力是以牺牲 M-Locality 为代价实现的，导致 M-Locality 水平显着降低。</span>通过对各种编辑方法的评估，<span style="background-color: #5fb23680">我们经常发现图像泛化性能往往不如文本泛化性能强大。</span></p><p><img src="/../imgs/$%7Bfiilename%7D/QNQGNXI7.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/QNQGNXI7.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;QNQGNXI7&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%227YT8KPYF%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B54.231%2C457.659%2C540.577%2C782.467%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;811&quot; height=&quot;542&quot; src=&quot;attachments/QNQGNXI7.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><img src="/../imgs/$%7Bfiilename%7D/CPEZX96N.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/CPEZX96N.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;CPEZX96N&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F5LR2L362%22%2C%22annotationKey%22%3A%2293WRHX5J%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B55.962%2C212.467%2C303.462%2C451.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEQHAEIP8%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;413&quot; height=&quot;400&quot; src=&quot;attachments/CPEZX96N.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="4-2-Editing-Different-Component"><a href="#4-2-Editing-Different-Component" class="headerlink" title="4.2 Editing Different Component"></a>4.2 Editing Different Component</h3><p>我们进一步分析了编辑多模态模型不同区域的变化。与编辑单模态模型相比，由于多模态模型的复杂性和多样性，我们可以尝试编辑更多模块并分析它们对视觉和文本知识的影响。结果如图 7 所示。对于 BLIP-2 OPT 模型，我们研究了在 VQA 数据集上编辑 Q-former 和 OPT 的区别。关于MiniGPT4模型，我们主要关注llama_proj和Vicuna模型在编辑最后几层的区别。选择的分析编辑方法有 MEND、KE 和 FT，这使我们能够指定编辑区域。</p><p>     结果表明，<span style="background-color: #5fb23680">编辑视觉模块比编辑语言模块更具挑战性（另请参阅图 6 中的失败编辑）。我们认为这种困难可能归因于模型的架构</span>。<span style="background-color: #ff666680">编辑LLM的最后一层可以直接修改输出，而修改视觉模块只影响LLM的输入，对模型的影响相对较小</span>。具体来说，<span style="background-color: #5fb23680">各种模态驻留在不同的空间中，这意味着事实知识可以存储在模型内的单独参数中</span>。考虑到LLMs拥有大量参数，这一点对于多模态模型变得更加重要。因此，编辑语言模型可以显着提高性能。值得注意的是，模型中的视觉模块在图像理解中起着至关重要的作用，<span style="background-color: #5fb23680">因此表明未来的工作需要同时考虑来自不同模式的信息。</span></p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>在本文中，我们介绍了多模式模型编辑，以及新的基准 MMEdit。根据经验，我们分析了各种模型编辑基线的有效性，并探索它们对不同组件（例如视觉和文本）的影响。</p><h2 id="6-Limitations"><a href="#6-Limitations" class="headerlink" title="6 Limitations"></a>6 Limitations</h2><p><strong>楷模</strong>。我们只编辑几个基本的多模式LLMs，留下许多其他的。此外，由于资源限制，我们编辑的多模态LLM的参数数量低于10B，我们无法编辑具有更多参数的LLM，例如65B LLaMA Adapter V2（Gao et al., 2023） 。</p><p><strong>高效的视觉编辑</strong>。在本文中，我们的分析主要集中于比较不同模式模块中现有编辑方法的不同效果。然而，结果并不令人满意。展望未来，我们的主要目标是探索如何跨其他模式高效、准确地编辑信息。这包括研究技术，<span style="background-color: #5fb23680">例如通过查明多模态模型内的知识并识别需要修改的内容来在不同模态之间进行共同编辑。</span></p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我们可以通过情景学习来编辑事实知识吗？</title>
      <link href="/2023/11/02/wo-men-ke-yi-tong-guo-qing-jing-xue-xi-lai-bian-ji-shi-shi-zhi-shi-ma/"/>
      <url>/2023/11/02/wo-men-ke-yi-tong-guo-qing-jing-xue-xi-lai-bian-ji-shi-shi-zhi-shi-ma/</url>
      
        <content type="html"><![CDATA[<h1 id="我们可以通过情景学习来编辑事实知识吗？"><a href="#我们可以通过情景学习来编辑事实知识吗？" class="headerlink" title="我们可以通过情景学习来编辑事实知识吗？"></a>我们可以通过情景学习来编辑事实知识吗？</h1><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>之前的研究表明，像 GPT 这样的大型语言模型 (LLM) 在其参数中存储了大量事实知识。然而，存储的知识可能是错误的或过时的。传统的知识编辑方法通过对包含特定知识的文本进行微调来完善LLMs。然而，随着LLMs规模的不断扩大，这些基于梯度的方法带来了巨大的计算成本。模型即服务的趋势也使得修改黑盒 LM 中的知识变得不可能。<span style="background-color: #ff666680">受到上下文学习（ICL）这种基于演示上下文而无需参数更新的新范式的启发</span>，我们探索 ICL 是否可以编辑事实知识。为了回答这个问题，我们对 ICL 策略进行了全面的实证研究。实验表明，<span style="background-color: #ff666680">与 GPT-J (6B) 上基于梯度的方法相比，上下文知识编辑 (IKE) 在没有任何梯度和参数更新的情况下实现了有竞争力的成功率，但副作用要少得多，包括减少对相似但不相关事实的过度编辑以及更少的对先前存储的知识的遗忘</span>。我们还将该方法应用于具有数十或数百个参数的大型 LM，例如 OPT-175B，这显示了我们方法的可扩展性。该代码可在<span class="highlight" data-annotation="%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B233.271%2C260.191%2C273.121%2C269.098%5D%2C%5B87.874%2C248.236%2C225.359%2C257.143%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%221%22%7D%7D" ztype="zhighlight"><a href="zotero://open-pdf/library/items/LB4642KE?page=1">“https:&#x2F;&#x2F; github.com&#x2F;PKUnlp-icler&#x2F;IKE.”</a></span></p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>预训练语言模型 (LM) 为 NLP 研究树立了新范式，并席卷了所有现有的 NLP 基准。由于取得了令人鼓舞的成果，研究人员为 LM 赋予了满足现实世界需求的新技能，例如使用网络浏览器（Nakano 等人，2021）、编码（Chen 等人，2021）、玩策略游戏（FAIR 等人） al.，2022）和对话人才（OpenAI，2022、2023）。然而，语言模型的广泛应用也引发了人们对其生成虚假内容的陷阱的日益关注（Elazar et al., 2021；Cao</p><p><img src="/../imgs/$%7Bfiilename%7D/M6YKHBS2.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/M6YKHBS2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;M6YKHBS2&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22FY8NBQWF%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B302.763%2C474.785%2C526.974%2C629.522%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%221%22%7D%7D&quot; width=&quot;374&quot; height=&quot;258&quot; src=&quot;attachments/M6YKHBS2.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>等人，2021a）、过时（Dhingra 等人，2022）、有偏见（Sheng 等人，2019；Zhao 等人，2021）和攻击性（Gehman 等人，2020）。为了缓解这一缺陷，旨在修改语言学习者所学到的知识的知识编辑（图 1）引起了越来越多的关注（Mitchell 等人，2022a；Meng 等人，2022a)。知识编辑的目标有两个：概括性和特异性。前者需要泛化到描述相同知识的各种提示，后者则不需要干扰其他不相关的知识。</p><p>     以往的知识编辑方法主要采用<span style="background-color: #2ea8e580">基于梯度的方法来修改特定的模型参数以获得所需的模型行为</span>（Mitchell等，2021；Meng等，2022a），例如在选举后更新总统。然而，<span style="background-color: #5fb23680">目标知识神经元的识别通常需要计算开销很大的梯度估计</span>（Dai et al., 2022）。此外，<span style="background-color: #2ea8e580">更新的参数本身会导致超出所需版本的副作用，例如忘记以前学到的事实或对不相关事实进行过度编辑</span>。先前的研究表明，当大规模 LM (LLM) 作为黑盒服务部署时（Sun 等人，2022），<span style="background-color: #2ea8e580">对其参数的微小修改可能会极大地影响其最终用户的行为</span>。因此，传统方法仍然受到编辑 LLM arXiv:2305.12740v1 [cs.CL] 202 年 5 月 22 日的困扰，因为这些限制阻碍了可扩展性和通用性。</p><p>     最近，情境学习（ICL）（Brown et al., 2020）已成为指导LLMs执行复杂任务的新范式。在 <span style="background-color: #2ea8e580">ICL 中，任务描述和演示示例以自然语言表示以形成上下文，并且以上下文为条件的 LM 预测根据预定义规则转换为答案</span>（Brown 等人，2020）。通过这种方式，大型 LM 无需对参数进行任何修改即可适应各种下游任务，使其自然适合大型 LM 上的知识编辑。首先，它通过避免修改参数来减少计算开销，并消除参数更新带来的副作用的风险。最重要的是，<span style="background-color: #2ea8e580">ICL 为人类提供了一种可解释的方式来校准 LM 行为</span>。尽管有这些优点，ICL 是否适用于知识编辑仍不清楚。</p><p>     在本文中，我们研究了 ICL 为LLMs进行知识编辑的潜力。我们专注于两个目标：（1）确保泛化，以便大型语言模型可以泛化到多个文本表面以获取更新的知识；（2）通过对目标知识事实进行准确修改，同时保留其他不相关事实，确保特异性。为了同时实现这些目标，我们设计了演示格式和组织策略，以构建合适的上下文学习演示，以指导LLMs的知识编辑。我们定义了三种类型的演示格式化模板，包括<span style="background-color: #ff666680">（i）复制，旨在将新事实注入语言模型； (ii) 更新，提高注入知识事实的泛化能力； (iii) 保留，指导语言模型保留不相关的知识事实。此外，为了充分利用 ICL 进行知识编辑的潜力，我们从训练语料库中检索相关知识事实作为演示输入。</span> GPT-J（6B）知识编辑基准的实验结果表明，所提出的上下文学习知识编辑（IKE）在强基线下实现了整体可比的知识编辑性能。例如，IKE 的编辑成功率绝对优于 MEND（Mitchell 等人，2021）10％，并且在特异性方面比 ROME 获得了 30 分的增益（Meng 等人，2022a）。由于没有参数修改，IKE适用于OPT-175B等LLM，并表现出更好的记忆能力，即编辑后，近50%的知识事实保留了较高的概率。进一步的分析表明，<span style="background-color: #ff666680">演示选择和保留演示有助于特异性，而更新演示则提高泛化能力</span>。最后，我们讨论了IKE在实际场景中应用时可能遇到的潜在挑战，并提供了相应的讨论。总的来说，这项研究的贡献有四个方面：</p><ul><li>据我们所知，这项工作代表了对 ICL 编辑 LM 知识潜力的首次系统探索。</li><li>我们对ICL 策略进行全面的实证研究，并分析这些策略如何影响最终性能。</li><li>通过设计适当的演示格式和组织策略，IKE 可以以更少的计算开销和副作用实现相当的成功率。</li><li>我们研究将IKE 应用到现实场景的可行性并讨论潜在的挑战。</li></ul><h2 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h2><p>**知识编辑方法 **最近关于知识编辑的研究大多是基于炒作网络或基于归因的。基于炒作网络的方法训练超网络以获得某些编辑的梯度变化。例如，曹等人。 （2021b）使用超网络来预测测试时的参数变化，这会改变事实，同时保留不相关的事实。 MEND（Mitchell 等人，2022a）学会了将原始微调梯度转换为梯度的低秩分解。米切尔等人。 （2022b）使用编辑记忆检索器和反事实模型来生成，而不更新基本模型的参数。基于归因的方法定位神经网络中某些知识的神经元激活，仅更新相关参数。戴等人。 （2022）使用基于梯度的归因评估了不同神经元对特定知识的贡献，并通过用缩放的嵌入向量替换多层感知器（MLP）权重矩阵中的列来更新或删除事实。孟等人。 (2022a)定位了表达事实知识的单层，并通过在MLP模块中编写新的键值对来编辑这些事实知识。</p><p><strong>知识编辑基准</strong> 一些知识编辑基准通常用于评估编辑方法的有效性和特异性。对于 BERT 风格的模型，通常采用事实检查数据集 FEVER (Thorne et al., 2018) 和问答数据集 zsRE (Levy et al., 2017)。在 FEVER 中，每个 x 是一个声明，每个 y 表示相应声明的有效性。在 zsRE 中，每个 x 都是关于事实的问题，每个 y 都是答案，而 xloc 询问与 x 无关的事实。对于 GPT 风格的模型，Mitchell 等人。 (2022a) 引入了维基文本编辑数据集，该数据集要求模型完成带有编辑延续的段落，同时每个标记的分布与不相关的段落 xloc 应保持不变。在我们的实验中，我们使用了一个更具挑战性的 QA 数据集，称为 COUNTERFACT（Meng 等人，2022a）。在 COUNTERFACT 中，问题 x 的编辑答案 y 有时可能与现实世界反事实，并且不相关的超出范围的样本 xloc 比 zsRE 中的困难得多，这使得模型更难预测所需的答案。此外，预先训练的LLMs很难捕获这些所需的事实，从而避免了LLMs在编辑之前了解这些知识的影响。</p><p><strong>情境学习</strong> 情境学习 (ICL) 是一种免训练范例，可从输入情境中串联的演示中学习。给定相关示例和查询，模型通过类比学习来做出预测（Brown 等人，2020；Liu 等人，2022）。现有的知识编辑方法需要重新计算梯度或者以廉价的方式计算并执行这样的知识编辑。斯等人。 （2022）首次探讨了情境学习是否可以更新LLMs的知识，并表明结合各种演示可以提高知识编辑的成功率。然而，他们只关注GPT-3，而没有深入探索知识编辑的潜在能力和副作用。</p><h3 id="3-Task-Formulation"><a href="#3-Task-Formulation" class="headerlink" title="3 Task Formulation"></a>3 Task Formulation</h3><p>知识编辑的目标是通过最大化概率 PM(y*|x*) 来将新事实 (x*, y*) 注入到 LMM 中。 x*是探究M中事实知识的提示（例如，美国总统是），y*将是编辑目标乔·拜登。知识编辑还需要概括性和特异性：</p><ul><li><strong>泛化</strong>：对于编辑中的提示x的范围 Dx*（即与新事实相关的提示），x ∈ Dx* 的预测也应该更新为 y*。例如，预测问题：谁是美国总统？答：将更新为乔·拜登。</li><li><strong>特异性</strong>：对于提示x 超出编辑范围，x &#x2F; ε Dx*，x 的预测应该是它原来的预测yo。例如，俄罗斯总统的预测应该保留。</li></ul><h2 id="4-Method-IKE"><a href="#4-Method-IKE" class="headerlink" title="4 Method: IKE"></a>4 Method: IKE</h2><h3 id="4-1-In-Context-Learning"><a href="#4-1-In-Context-Learning" class="headerlink" title="4.1 In-Context Learning"></a>4.1 In-Context Learning</h3><p>情境学习（ICL）是由 Brown 等人提出的。 （2020）用于小样本学习。对于大型语言模型 M，ICL 的目标是根据 k 个演示 C &#x3D; {(x1, y1),… 来预测输入 x 的 ˆ y ∈ Y，而无需进行任何参数更新。 。 。 ，（xk，yk）}。语言模型 M 预测给定 x 的 y ∈ Y 的概率：PM(y | x, C)。更具体地说，ICL 使用模板 T 将输入和标签转换为自然语言文本。以情感分析为例，输入 xi 和标签 yi 的上下文演示将转换为句子：xi。情感：yi，那么语言模型 M 将在给定 T (x1, y1), 的情况下预测 y ∈ Y。 。 。 ，T（xk，yk），T（x，）。</p><h3 id="4-2-In-Context-Knowledge-Editing"><a href="#4-2-In-Context-Knowledge-Editing" class="headerlink" title="4.2 In-Context Knowledge Editing"></a>4.2 In-Context Knowledge Editing</h3><p>当我们将目标事实 f &#x3D; (x*, y*) 注入 LM 时，我们将构造 k 个演示 C &#x3D; {c1,…。 。 。 ，ck}。知识编辑的目标是当提示x在目标提示x*的编辑范围内时最大化P(y*|x,f,C)，并且最小化P(y*|x,f,C)之间的距离。 | x, f, C) 和 P (y | x) 当 x &#x2F; ∈ Dx* （特异性目标）时。 LM 应确定探测提示 x 是否在 x* 的编辑范围内，即 Dx*。为了通过 ICL 实现这些目标，适当的演示输入至关重要。我们进一步将以f为目标的知识编辑演示构建分解为两个子问题：</p><p>（i）如何设计每个演示的格式； (ii) 如何选择上下文演示并对其进行排名（Dong 等人，2023）。</p><h4 id="4-2-1-Demonstration-Formating"><a href="#4-2-1-Demonstration-Formating" class="headerlink" title="4.2.1 Demonstration Formating"></a>4.2.1 Demonstration Formating</h4><p>每个演示 ci 都包含一个新事实 fi &#x3D; (xi*, y* i )、一个探测提示 xi 及其预测 yi。上下文演示应该教会 LM 复制、更新和保留针对不同提示的预测：</p><ul><li><strong>复制</strong>：要将新事实注入 LM，第一步是教他们将目标提示的预测复制到新事实中。在复制演示中，xi &#x3D; xi* 且 yi &#x3D; y* i。</li><li><strong>更新</strong>：知识编辑不仅仅是教语言模型重复新事实。为了知识编辑的泛化，编辑范围内提示的预测也应该更新。在更新演示中，xi ∈ Dx* i 且 yi &#x3D; y* i。</li><li><strong>保留</strong>：出于知识编辑的特殊性，语言模型应在超出范围的提示中保留其原始预测。在保留演示中，xi &#x2F; ∈ Dx* i 和 yi 应该是它的原始答案 yo i。 IKE 的模板 T 将 f 、 x 和 y 转换为自然语言：T (f, x, y) &#x3D; New Fact: f 。提示：xy。详细信息列于§A。</li></ul><h4 id="4-2-2-Demonstration-Organization"><a href="#4-2-2-Demonstration-Organization" class="headerlink" title="4.2.2 Demonstration Organization"></a>4.2.2 Demonstration Organization</h4><p>当我们在 LM 中编辑知识事实 f 时，我们构建 k 个演示 C &#x3D; {c1,… 。 。 , ck} 来自训练语料库。哪些演示适合上下文编辑？我们关注刘等人。 （2022）使用无监督检索器来选择 k 个最近邻居。更具体地说，我们使用预训练的句子编码器 E 对新事实 f 的提示 x* 及其原始答案 yo 和目标预测 y* 进行编码。这</p><p><img src="/../imgs/$%7Bfiilename%7D/ZLL8JITP.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/ZLL8JITP.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;ZLL8JITP&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%228PRW9YFQ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B302.885%2C681.505%2C530.769%2C775.544%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;380&quot; height=&quot;157&quot; src=&quot;attachments/ZLL8JITP.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>训练语料库中的记录将以相同的方式进行编码，并根据余弦相似度检索 k-NN 事实。上下文演示的排名还取决于余弦相似度：cos(c0, f ) &lt; cos(c1, f ) &lt; 。 。 。 &lt; cos(ck, f )，其中 c1, . 。 。 , ck 从左到右放置在上下文中。</p><h3 id="4-3-Discussion-Gradient-based-methods-and-gradient-free-methods"><a href="#4-3-Discussion-Gradient-based-methods-and-gradient-free-methods" class="headerlink" title="4.3 Discussion:Gradient-based methods and gradient-free methods"></a>4.3 Discussion:Gradient-based methods and gradient-free methods</h3><p>之前的参数更新方法会调整LM M的参数θ。它们根据梯度∇θ − log PM(y*|x*)计算Δθ，将基础模型Mθ更新为编辑后的M′θ+Δθ。然后将通过 PM′(y | x) 评估编辑方法。相反，上下文学习通过为新事实 f &#x3D; (x*, y*) 构建演示 C 来修改 M 中的知识事实，然后通过 PM(y | x, f, C) 来评估编辑方法。将 PM(y | x, f, C) 与 PM′(y | x) 进行比较，可以发现： (i) ICL 不需要对目标事实进行梯度估计，并且在知识编辑后保持原始 LM M 不变。这大大减少了计算开销，从而使编辑适用于具有万亿级参数的LM，并消除了修改参数的副作用。 (ii) 演示 C 以自然文本表示，比显着参数更新 Δθ 更容易解释。它提供了一个人类可理解的界面来校准模型行为。我们在表 1 中重点介绍了这两种方法的特点。</p><h2 id="5-Experiment"><a href="#5-Experiment" class="headerlink" title="5 Experiment"></a>5 Experiment</h2><p>在本节中，我们通过实验来回答以下研究问题：</p><ul><li>与基于梯度的方法相比，IKE 的性能如何？</li><li>演示设计策略如何影响IKE 的性能</li><li>LM 的规模如何影响IKE 的性能，IKE 能否扩展到具有数百或数千亿参数的大型语言模型？</li><li>知识编辑有哪些副作用？与其他参数更新方法相比，IKE 产生的副作用是多还是少？</li></ul><p>     我们首先介绍实验设置，包括比较基线方法、评估基准和不同尺度的语言模型，用于知识编辑（第 5.1 节）。然后我们分析了§5.2中的主要知识编辑结果以及情境学习知识编辑的影响因素（§5.3）。</p><h3 id="5-1-Experimental-Setting"><a href="#5-1-Experimental-Setting" class="headerlink" title="5.1 Experimental Setting"></a>5.1 Experimental Setting</h3><p>我们的目标是评估上下文知识编辑与参数更新方法相比的性能。我们还对不同大小的语言模型进行了实验，以探索上下文知识编辑的扩展能力。</p><h4 id="5-1-1-基线"><a href="#5-1-1-基线" class="headerlink" title="5.1.1 基线"></a>5.1.1 基线</h4><p>遵循之前的知识编辑方法，我们还选择 GPT-J (6B) 作为我们的主要评估骨干。比较的基线包括：</p><p><strong>FT</strong> 在描述编辑事实的文本上微调基本模型，而无需通过应用 Adam 提前停止来训练新的模型编辑器。</p><p><strong>MEND</strong> MEND（Mitchell 等人，2022a）通过使用预训练的超网络将权重矩阵分解为rank-1 形式来转换更新事实的微调梯度。</p><p><strong>ROME</strong> ROME（Meng et al., 2022a）学习定位一组特定 MLP 模块的事实检索，并通过直接在 MLP 模块中写入新的键值对来更新知识。</p><p><strong>PROMPT</strong> 探索上下文演示如何影响 IKE 的性能。我们直接使用新事实作为上下文，通过 P(y|x, f ) 来探测 LM，其中 f &#x3D; (x*, y*)。实施细节见§A</p><h4 id="5-1-2-Evaluation-Setup"><a href="#5-1-2-Evaluation-Setup" class="headerlink" title="5.1.2 Evaluation Setup"></a>5.1.2 Evaluation Setup</h4><p><strong>模型</strong> 为了探索 LM 的规模将如何影响上下文知识编辑的有效性，我们在五个类似 GPT 的自回归转换器语言模型上评估了上下文知识编辑，其规模范围从 1.5B 到 175B 参数：</p><ul><li>GPT- 2 XL (1.5B)（Radford 等人，2019），GPT-2 的 15 亿参数版本。</li><li>GPT-NEO (2.7B)（Gao 等人，2021），EleutherAI 发布的类 GPT-2 因果语言模型的 27 亿参数版本。它是在专门为 LLM 训练设计的 Pile 数据集上进行训练的。</li><li>GPT-J (6B)（Wang 和 Komatsuzaki，2021），一种在具有 60 亿个参数的 Pile 上训练的自回归文本生成模型。</li><li>GPT-NEOX (20B)（Black 等人，2022），一个在 Pile 上训练的 200 亿参数自回归语言模型。</li><li>OPT (175B)（Zhang 等人，2022），开放式预训练 Transformer，由 MetaAI 创建，具有 1750 亿个参数。</li></ul><p><strong>基准</strong> 我们主要评估 COUNTERFACT 的基线（Meng et al., 2022a），这是一个具有挑战性的基准，适用于具有困难编辑目标和难以区分编辑范围的类 GPT 因果语言模型。它包含 21, 919 条不同关系和实体的记录。每条记录的目标是将知识三元组（s*，r*，oc）更改为（s*，r*，o*），其中s*和r*由目标提示x*描述。该记录还包含释义提示 P P 作为范围内提示和邻域提示 P N ，即与目标三元组共享同一对象的知识三元组（s′，r*，oc）作为范围外提示。我们关注孟等人。 (2022a) 使用前 2000 条记录作为测试集，其余记录分为训练集。 COUNTERFACT 的详细信息在 §B 中列出。</p><p><strong>指标</strong> 知识编辑的性能从三个方面来衡量（有效性、泛化性和特异性）。</p><ul><li>**功效 **通过功效得分 (ES, E[I[P(o*) &gt; P(oc)]]) 和功效幅度 (EM, E[P(o*) − P( oc）]）。</li><li>**泛化 **通过释义衡量释义提示的译后编辑准确性分数 (PS) 和释义幅度 (PM)。 PS和PM的定义与ES和EM类似。</li><li>**特异性 **通过邻域得分 (NS, E[I[P(oc) &gt; P(o*)]]) 和邻域量级 (NM, E[P(oc) − P(o*)]) 来衡量邻域提示的准确性，因为邻域提示 (s′, r*, oc) 与目标提示共享相同的原始对象，并且这些事实不应被编辑。</li></ul><p>我们也关注孟等人。 (2022a) 将 ES、PS、NS 的调和平均值报告为分数 (S)</p><p><img src="/../imgs/$%7Bfiilename%7D/QTYQT47T.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/QTYQT47T.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;QTYQT47T&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22JKFNHCLD%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%226%22%2C%22position%22%3A%7B%22pageIndex%22%3A5%2C%22rects%22%3A%5B%5B64%2C569.39%2C535%2C784.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%226%22%7D%7D&quot; width=&quot;785&quot; height=&quot;359&quot; src=&quot;attachments/QTYQT47T.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="5-2-Main-Results"><a href="#5-2-Main-Results" class="headerlink" title="5.2 Main Results"></a>5.2 Main Results</h3><p>表2的顶行显示了不同方法的知识编辑结果。我们的研究结果是：（i）所有方法在功效方面都表现良好，正如它们接近的 ES 分数所示。然而，在普遍性和特殊性方面存在显着差异。例如，FT 获得了较高的 ES (99.9) 和 PS (96.4) 分数，但在特异性方面表现不佳。这凸显了知识编辑中平衡泛化和特殊性的挑战。 (ii) 在基线方法中，ROME 在所有三个指标方面总体表现最好，但计算开销较高。由于这一限制，它不适用于诸如 OPT175B 等更迫切需要知识编辑的大型 LM。 (iii) 所提出的方法 IKE 在特异性方面表现出色，但在有效性和泛化方面也表现良好。例如，IKE 在 GPTJ 上获得了与 ROME 相当的总分（89.6 比 91.5），同时不需要任何参数对 LM 的修改。这种计算优势使得在 OPT-175B 等大型 LM 上执行知识编辑成为可能，其中 IKE 比 PROMPT 明显提高了 36.0 个点。这些结果证明了 IKE 在知识编辑方面的有效性、效率和可扩展性。</p><p><img src="/../imgs/$%7Bfiilename%7D/P6MNIS5S.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/P6MNIS5S.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;P6MNIS5S&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22GWHX8CHK%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%226%22%2C%22position%22%3A%7B%22pageIndex%22%3A5%2C%22rects%22%3A%5B%5B303.158%2C339.39%2C531.316%2C561.232%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%226%22%7D%7D&quot; width=&quot;380&quot; height=&quot;369&quot; src=&quot;attachments/P6MNIS5S.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="5-3-Analysis"><a href="#5-3-Analysis" class="headerlink" title="5.3 Analysis"></a>5.3 Analysis</h3><p>在这一部分中，我们讨论不同演示策略的效果、跨尺度模型的 IKE 可扩展性以及知识编辑引入的副作用。</p><h4 id="5-3-1Ablation-on-Demonstration"><a href="#5-3-1Ablation-on-Demonstration" class="headerlink" title="5.3.1Ablation on Demonstration"></a>5.3.1Ablation on Demonstration</h4><p><strong>演示次数</strong> 演示次数是 ICL 性能的影响因素之一 (Brown et al., 2020)。我们研究了演示数量如何影响第二阶段的 IKE 性能</p><p><img src="/../imgs/$%7Bfiilename%7D/HKQ4CHLZ.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/HKQ4CHLZ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;HKQ4CHLZ&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22MUQZEW2N%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%227%22%2C%22position%22%3A%7B%22pageIndex%22%3A6%2C%22rects%22%3A%5B%5B63.947%2C615.706%2C292.895%2C778.732%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%227%22%7D%7D&quot; width=&quot;382&quot; height=&quot;272&quot; src=&quot;attachments/HKQ4CHLZ.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>表 3 中的块。在没有任何演示的情况下，PROMPT 因其低 NS（37.9）而表现出过度泛化，表明它只是学习复制预测。给定一些演示（4 或 8)，IKE 在有效性和泛化性方面比 PROMPT 表现更差，因为它开始区分提示是否在编辑范围内。随着演示次数的增加，IKE逐渐学会平衡通用性和特殊性，实现更好的权衡。</p><p>**演示组织 **先前的研究（Liu et al., 2022; Rubin et al., 2022; Lu et al., 2022）表明，包括演示选择和演示排序（Dong et al., 2023）在内的演示组织对于 ICL 也至关重要。我们的建议遵循刘等人的简单无监督方法。 （2022），根据输入提示和演示之间的余弦相似度从训练语料库中检索和排序演示。在表 3 第三块中的两项消融研究中，我们发现删除选择程序（即随机选择）会导致 NS 分数从 77.0 明显下降到 45.0，这表明正确提示选择的重要性。然而，随机排序带来的性能差异可以忽略不计。我们推测这是因为所选的提示与目标事实高度相关，并且基于 Transformer 的 LM 中的注意力机制可以很好地处理长程依赖性。我们将进一步的改进作为未来的工作。</p><p>**演示格式 **我们进一步检查演示类型的影响，包括复制、更新和保留。如表 3 中的第四个块所示，删除复制演示会导致性能轻微下降，因为即使没有复制演示，LM 也可以轻松复制演示中的内容。相反，更新演示在教导 LM 修改其知识方面发挥着重要作用，删除更新演示后泛化得分要差得多。此外，删除保留演示会导致特异性急剧下降（通过 NM 分数衡量），从 35.2 降至 -47.6。这表明保留演示对于帮助 LM 识别超出范围的事实并维持对这些提示的原始预测至关重要。</p><h4 id="5-3-2IKE-Benefits-from-Model-Scaling"><a href="#5-3-2IKE-Benefits-from-Model-Scaling" class="headerlink" title="5.3.2IKE Benefits from Model Scaling"></a>5.3.2IKE Benefits from Model Scaling</h4><p>我们进一步评估了 COUNTERFACT 上的 IKE，针对不同尺度的五种类似 GPT 的因果语言模型。正如之前的实验表明，所有方法都表现出很高的知识编辑功效，因此我们重点关注大型语言模型的泛化性和特异性，因为这些指标的定义是为了衡量可能对最终用户造成巨大影响的副作用。如表 4 所示，我们发现 IKE 的性能与 LM 的规模正相关，并且最大的 OPT-175B 实现了最强的泛化和特异性结果。这是令人鼓舞的，因为 IKE 的性能可以随着 LM 规模的增加而增强，使其可插入未来更强大的 LM 主干。</p><h4 id="5-3-3Resilience-to-Over-Editing"><a href="#5-3-3Resilience-to-Over-Editing" class="headerlink" title="5.3.3Resilience to Over-Editing"></a>5.3.3Resilience to Over-Editing</h4><p>过度编辑是知识编辑的常见副作用，指在编辑目标事实时对超出范围的事实产生影响。尽管 COUNTERFACT 已经包含由 (s′, r*, oc) 组成的范围外提示，它们与编辑目标共享相同的关系 r 和原始对象 oc： (s*, r*, oc) → (s*, r*, o*），我们采用Dong等人提出的对比知识评估（CKA）对过度编辑进行更全面的评估。 （2022）。具体来说，对于一个三元组（s，r，o），CKA将r替换为其他相似但不相关的关系r′，并比较PM（o | s，r）和PM（o | s，r′）来评估M是否知道事实（s，r，o）。受此启发，我们将(s*,r’,o*)视为相似但不相关的提示，并考虑P(o*|s*,r’)的变化，发现P(o*|s*,r’ ）在注入（s*，r*，o*）后也会增加。为了进一步探索不同方法中的过度编辑，我们考虑 CKA 分数 P(o*|s*, r*)&#x2F;Er′∈RP(o*|s*, r′)。</p><p><img src="/../imgs/$%7Bfiilename%7D/A9BSU2NB.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/A9BSU2NB.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;A9BSU2NB&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22W3GR7IZZ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B61.731%2C622.082%2C298.269%2C782.467%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;394&quot; height=&quot;267&quot; src=&quot;attachments/A9BSU2NB.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><img src="/../imgs/$%7Bfiilename%7D/JRUG4L94.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/JRUG4L94.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;JRUG4L94&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FLB4642KE%22%2C%22annotationKey%22%3A%22V8EL5CWL%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B304.038%2C646.313%2C529.038%2C781.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F8YZC667S%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;375&quot; height=&quot;226&quot; src=&quot;attachments/JRUG4L94.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>CKA评估结果如表5所示。如果CKA得分小于预定义阈值α，则正确事实的困惑度为输给了对比虚假事实的困惑，结果证明这是一次编辑失败。尽管所有基线在编辑功效方面都表现良好，但在更严格的对比评估下它们往往过于概括。 ROME 的平均 CKA 得分最低，错误率最高，这表明它识别与目标提示共享同一主题的范围外提示的能力较差。 IKE 对过度编辑的影响较小。</p><h4 id="5-3-4Maintenance-for-Original-Knowledge"><a href="#5-3-4Maintenance-for-Original-Knowledge" class="headerlink" title="5.3.4Maintenance for Original Knowledge"></a>5.3.4Maintenance for Original Knowledge</h4><p>我们得出的结论是，先前存储在语言模型中的事实知识将在知识编辑过程中被删除或遗忘。我们在表6中考虑编辑前后P(oc|s*, r)的变化。结果表明，所有编辑方法都会导致P(oc|s*, r*)的下降。罗马几乎忘记了所有最初的事实。如果我们想要纠正 LM 的预测，就必须擦除原来的事实知识。然而，如果我们想更新语言模型的预测，例如更新美国总统是从唐纳德·特朗普到乔·拜登的预测（时间感知关系），那么旧知识 2017 年，美国总统是唐纳德·特朗普不应该被忘记。</p><p>    为了评估编辑中这种时间感知知识的遗忘，我们基于 TEMPLAMA (Dhingra et al., 2022) 构建了一个小型基准，以进一步表明 IKE 比 §C 中的其他基准可以导致更少的知识遗忘。</p><h2 id="6-Discussions"><a href="#6-Discussions" class="headerlink" title="6 Discussions"></a>6 Discussions</h2><p>在之前的实验中，我们遵循孟等人之前研究的设置。 （2022a）并主要评估编辑单个事实以进行公平比较的方法。我们的结果表明 IKE 可以获得更好的泛化性和特异性，副作用更少，并且不需要修改参数。尽管如此，为了探讨可行性在将 IKE 应用到现实场景中时，有几个重要问题尚未得到充分探索：(1) IKE 能否扩展以容纳更多的编辑事实？考虑到语言模型的输入长度有限，在上下文中包含大量的编辑事实可能是不可行的。 (2) IKE 能否适应处理不同格式和域的事实和提示？在IKE中，事实和提示的域和格式保持一致。然而，在现实世界中，事实和提示有多种形式。米切尔等人。 (2022b)提出了一种基于检索的方法来编辑多个知识事实。类似地，具有外部存储器来存储事实编辑的 IKE 可以检索正确的事实编辑来构建给定提示的上下文，从而避免永远在上下文中预先添加所有事实编辑。为了验证 IKE 对不同形式的事实或提示的泛化，我们用维基百科中的中性数据替换了事实，或者用生成提示替换了提示，提示 LM 生成与新对象相关的文本。详细讨论可以在§D 中找到。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>在这项工作中，我们研究了上下文学习在大规模语言模型上进行知识编辑的潜力。具体来说，我们设计了提示LM的演示策略，包括三种类型的演示格式和基于检索的演示组织。我们表明，所提出的方法 IKE 在不需要任何参数修改的情况下实现了竞争性知识编辑功效，并保持了良好的泛化和特异性性能。进一步的分析证明了它对于大型 LM 的可扩展性、对过度编辑问题的弹性以及通过多轮编辑维护时间感知知识事实的能力。我们的结果证明 ICL 在 LM 知识编辑方面具有巨大潜力。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识神经元中心之旅：语言无关知识神经元和简并知识神经元的发现</title>
      <link href="/2023/11/02/zhi-shi-shen-jing-yuan-zhong-xin-zhi-lu-yu-yan-wu-guan-zhi-shi-shen-jing-yuan-he-jian-bing-zhi-shi-shen-jing-yuan-de-fa-xian/"/>
      <url>/2023/11/02/zhi-shi-shen-jing-yuan-zhong-xin-zhi-lu-yu-yan-wu-guan-zhi-shi-shen-jing-yuan-he-jian-bing-zhi-shi-shen-jing-yuan-de-fa-xian/</url>
      
        <content type="html"><![CDATA[<h1 id="知识神经元中心之旅：语言无关知识神经元和简并知识神经元的发现"><a href="#知识神经元中心之旅：语言无关知识神经元和简并知识神经元的发现" class="headerlink" title="知识神经元中心之旅：语言无关知识神经元和简并知识神经元的发现"></a>知识神经元中心之旅：语言无关知识神经元和简并知识神经元的发现</h1><h2 id="Abstruct"><a href="#Abstruct" class="headerlink" title="Abstruct"></a>Abstruct</h2><p>预训练语言模型 (PLM) 包含大量事实知识，但这些知识如何存储在参数中仍不清楚。本文深入研究了理解事实知识如何存储在多语言 PLM 中的复杂任务，并介绍了适应架构的多语言集成梯度方法，与现有方法相比，该方法<span style="background-color: #ff666680">成功地更精确地定位了知识神经元，并且在各种架构和语言中更加通用。</span>此外，我们对知识神经元进行了深入的探索，得到了以下两个重要发现：<span style="background-color: #ff666680">（1）语言无关的知识神经元的发现，它以超越语言的形式存储事实知识。我们设计了跨语言知识编辑实验，证明 PLM 可以基于语言无关的神经元完成这项任务；</span> <span style="background-color: #ff666680">（2）退化知识神经元的发现，这是一种新型神经元，表明不同的知识神经元可以存储相同的事实。</span>其<span style="background-color: #ff666680">功能重叠的特性赋予 PLM 强大的事实知识掌握能力。</span>我们设计了事实检查实验，证明<span style="background-color: #ff666680">退化知识神经元可以帮助 PLM 检测错误事实。</span>实验证实了这些发现，揭示了多语言 PLM 中事实知识存储的机制，并为该领域提供了宝贵的见解。源代码将公开以供进一步研究。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h2><p>预训练语言模型 (PLM)（Devlin 等人，2018 年；Radford 等人，2019 年；Shliazhko 等人，2022 年；OpenAI 2023；Touvron 等人，2023 年）因其卓越的性能而彻底改变了自然语言处理领域涵盖广泛的任务。这些模型在维基百科等广泛的语料库上进行训练，被广泛认为封装了大量事实知识（Petroni 等人，2019b；Jiang 等人，2020），但知识如何存储在参数中仍不清楚（Kandpal 等人） .2023）。研究知识存储机制将有助于更深入地理解和掌握 PLM 中的知识（Zhen 等人，2022 年；Zhao 等人，2023 年）。在本文中，我们对知识定位任务（Hase et al. 2023; Andreas 2022）进行了深入研究，该任务旨在确定模型参数中特定事实知识的存储位置，其中此类参数被称为知识神经元（Dai 等人，2022）。</p><p><img src="/../imgs/$%7Bfiilename%7D/35MAP8RY.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/35MAP8RY.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;35MAP8RY&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22KFEQGR8B%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B310.588%2C334.059%2C565.588%2C579.353%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%221%22%7D%7D&quot; width=&quot;425&quot; height=&quot;409&quot; src=&quot;attachments/35MAP8RY.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>最近，一些已建立的方法致力于阐明 PLM 中的知识存储机制。一种策略是基于梯度的方法（Ancona et al. 2019），<span style="background-color: #2ea8e580">它通过使用积分梯度计算每个神经元的归因得分来评估每个神经元的贡献。另一种是因果启发方法，它采用跟踪算法来跟踪模型层之间的因果影响（Cao 等人，2023）。</span>尽管在知识本地化任务中取得了成功，这些方法仍然面临两个主要挑战：<span style="background-color: #2ea8e580">（1）缺乏针对不同 PLM 架构的通用方法：观察到事实知识出现在各种 PLM 架构中，包括自动编码模型（例如， BERT）（Devlin 等人，2018 年）和自回归模型（例如 GPT）（Shliazhko 等人，2022 年）。</span>然而，虽然有些方法适合自编码模型并且在自回归模型中表现不佳（Meng et al. 2022a），但其他方法是专门为自回归模型设计的并且不能很好地适应自编码模型（Li et al. 2022），在跨两种 PLM 架构都表现良好的通用方法中留下了空白。(2)缺乏多层次探索多种语言：实质性知识与语言无关，当前的大型语言模型支持多语言。然而，现有的方法仅关注英语数据集，可能无法提供跨语言知识存储机制的全面见解，限制了得出多语言结论的能力。</p><p>     为了更精确地定位知识神经元，我们遵循基于梯度的方法，提出了一种新颖的知识定位方法，称为架构适应多语言集成梯度（AMIG）。<span style="background-color: #ff666680">首先，针对不同 PLM 架构中缺乏通用方法，我们设计了一种架构适配技术，使得集成梯度算法（Lundstrom、Huang 和 Razaviyayn 2022）中的基线向量在不同 PLM 架构之间普遍兼容。其次，针对多语言探索的缺乏，我们引入了多语言阈值调整技术，针对不同语言调整综合梯度计算中的阈值。</span>多语言数据集上的实验结果表明，与之前最先进的模型相比，我们的方法可以更精确地定位知识神经元。此外，我们还对知识神经元进行了深入的探索，得出了以下两个重要发现。</p><p>**      与语言无关的知识神经元**：我们在多语言 PLM 中发现了一种新型神经元，能够跨语言存储事实知识。我们将它们命名为与语言无关的知识神经元，因为它们的存在超越了特定语言的界限。如图1a所示，<span style="background-color: #ff666680">这些神经元是通过将源自不同语言的知识神经元相交而获得的，封装了跨多种语言一致的知识表示。独立于语言的知识神经元可以帮助跨语言的知识编辑任务：对某些知识的单次编辑可以同时影响所有语言的相应知识。</span>例如，如果我们将事实⟨Tanzania, Capital, Dar es Salaam⟩对应的语言无关神经元编辑为⟨Tanzania, Capital, Dodoma⟩，则该事实在所有语言中都会相应更改。我们设计实验来验证与语言无关的知识神经元的作用。与现有的跨语言知识编辑模型相比，我们的方法的编辑性能更为优越。该实验证明了我们的方法在跨语言知识编辑应用中的潜力。</p><p>      <strong>退化知识神经元</strong>：我们发现了一个有趣的现象，对应于一种全新类型的神经元。<span style="background-color: #ff666680">给定事实及其相应的知识神经元，知识神经元的某些子集表现出独特的属性。即使该子集中的某些元素被抑制，模型仍然可以正确地表达事实；然而，如果子集中的所有元素都被抑制，模型就无法再正确地表达事实。这一现象表明，一些知识神经元存储着相同的事实知识，模型需要激活至少一个神经元才能正确表达事实。</span>它与生物系统中的“简并”现象非常相似（Tononi, Sporns, and Edelman 1999; Mason 2015），因此我们将此类神经元命名为简并知识神经元。与冗余不同，<span style="background-color: #ff666680">简并知识神经元不能简单地删除，因为它们仅部分重叠。一个退化的知识神经元可能存储多条事实知识，删除它对特定知识没有影响，但可能会影响其他知识。</span></p><p>     图1b说明了简并知识神经元的获取过程。具体来说，<span style="background-color: #ff666680">我们首先对知识神经元进行定位，然后对它们进行聚合和过滤以获得简并的知识神经元。</span>对于查询“坦桑尼亚的首都是”，PLM 必须激活至少一个相应的简并知识神经元来预测正确的事实 Dodoma。直观上，<span style="background-color: #ff666680">简并知识神经元的功能重叠特性赋予 PLM 对事实知识的强大理解，确保其对事实的掌握保持稳定且不易出错</span>。受此启发，我们设计了一个实验，使用简并知识神经元进行事实检查。我们的实验表明，<span style="background-color: #5fb23680">简并知识神经元可以帮助 PLM 检测错误事实，从而说明它们的存在增强了 PLM 对事实知识的稳定掌握。</span></p><p>总的来说，主要贡献总结如下：（1）我们提出了一种新颖的知识本地化方法，称为架构适应的多语言集成梯度，它可以有效解决传统方法的两个挑战：缺乏针对不同 PLM 架构的通用方法和缺乏对多种语言的探索，从而实现知识神经元更精确的定位。 （2）我们发现了独立于语言的知识神经元，它们以超越语言障碍的形式存储事实知识。实验结果表明它们有利于跨语言知识编辑任务。 （3）我们发现了简并知识神经元，这是一种具有功能重叠特性的新型神经元，使得模型对事实知识的掌握更加稳健。实验证明它们可以帮助检测不正确的事实。</p><h2 id="2-Methodology"><a href="#2-Methodology" class="headerlink" title="2 Methodology"></a>2 Methodology</h2><p>图 2 示意性地展示了我们提出的框架。它由三个主要模块组成，包括知识神经元定位（模块1）、语言无关知识神经元检测（模块2）和简并知识神经元检测（模块3）。我们详细说明了每个模块。</p><h3 id="2-1KnowLedge-Neuron-Localization"><a href="#2-1KnowLedge-Neuron-Localization" class="headerlink" title="2.1KnowLedge Neuron Localization"></a>2.1KnowLedge Neuron Localization</h3><p>图 2 的模块 1 展示了知识定位模块，该模块旨在查明 PLM 中知识神经元的确切位置。使用填空完形填空任务（Petroni 等人，2019a），我们评估对 PLM 对特定事实的理解。例如，给定一个事实 ⟨Tanzania, Capital, Dodoma⟩ 以及相应的查询“坦桑尼亚的首都是”，Petroni 等人 (2019a) 描述，如果模型能够预测正确答案，则模型知道一个事实。在本研究中，我们通过引入架构适应多语言集成梯度方法来扩展此分析，以定位专门负责处理事实信息的神经元。</p><p><img src="/../imgs/$%7Bfiilename%7D/MXWX28JU.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/MXWX28JU.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;MXWX28JU&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%228TICA8HS%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B49.615%2C585.462%2C563.654%2C764.885%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;857&quot; height=&quot;299&quot; src=&quot;attachments/MXWX28JU.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>从数学上来说，给定一个查询 q，PLM 预测的正确答案的概率可以定义为：</p><p><img src="/../imgs/$%7Bfiilename%7D/WXFG2TDF.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/WXFG2TDF.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;WXFG2TDF&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22HCSPGJUY%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B55.385%2C522%2C295.962%2C544.5%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;401&quot; height=&quot;38&quot; src=&quot;attachments/WXFG2TDF.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 y* 是正确答案，w(l) j 是第 l 层的第 j 个神经元，^ w(l) j 是 w(l) j 分配的值。为了计算每个神经元的归因分数，我们使用积分梯度（Sundararajan、Taly 和 Yan 2017）。考虑一个神经元 w(l) j ，我们可以计算它的归因分数：</p><p><img src="/../imgs/$%7Bfiilename%7D/9PTK8AY8.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/9PTK8AY8.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;9PTK8AY8&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22WI26DVZD%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B50.192%2C407.769%2C302.308%2C456.808%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;420&quot; height=&quot;82&quot; src=&quot;attachments/9PTK8AY8.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 w(l) j 是 w(l) j 的值，w′(l) j 是 w(l) j 的基线向量，并且 ∂ F(w′(l) j +α(w(l)) j −w′(l) j )) ∂ w(l) j 计算梯度。当 α 从 0 变为 1 时，(w′(l) j +α(w(l) j −w′(l) j )) 从 w′(l) j 变为 w(l) j ，因此 Attr (w(l) j )可以通过对梯度进行积分来累积因w(l) j 变化而引起的概率变化。理想的基线向量 w′(l) j 应该缺乏信息（Liu et al. 2022)，当前的方法用零向量对其进行近似。然而，这样的设置没有考虑各种 PLM 架构之间的差异，导致性能不佳。为了缓解这个问题，我们设计了一种架构适应技术来计算各种 PLM 架构的基线向量。</p><p>     首先，为了最小化基线向量中的信息内容，我们遵循Enguehard（2023）的方法，将输入查询q分成m个单词，然后将每个单词分别输入到PLM中以计算神经元的激活分数对应每个词qi。随后，我们精心设计了不同 PLM 架构的基线向量。设qi对应的基线句子为q′ i，q′ i包含m个单词，长度与q一致，记为q′ i &#x3D; (q′ i1 . . . q′ ik . . . q′ im) ， 在哪里：</p><p><img src="/../imgs/$%7Bfiilename%7D/YTVPUQLA.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/YTVPUQLA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;YTVPUQLA&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22BS72ACK6%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B53.654%2C87.577%2C296.538%2C128.538%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;405&quot; height=&quot;68&quot; src=&quot;attachments/YTVPUQLA.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 ⟨mask⟩ 用于屏蔽自动编码模型，⟨eos⟩ 代表自回归模型中的“序列结束”，qk 是查询的第 k 个单词。在此设计中，第 l 层中的第 i 个神经元（用 w(l) j 表示）对应于 qi，其相关基线向量 w’(l) j 对应于 q’ i。然后，我们可以根据方程（2）计算使用 qi 作为输入时每个神经元的归因得分 Attri(w(l) j )。为了计算积分，我们使用黎曼近似：</p><p><img src="/../imgs/$%7Bfiilename%7D/J2V52PJA.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/J2V52PJA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;J2V52PJA&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22SMECCLTE%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B317.885%2C419.308%2C562.5%2C460.846%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;408&quot; height=&quot;69&quot; src=&quot;attachments/J2V52PJA.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 N 是近似步数。然后对每个单词 qi 的归因进行求和并标准化，得出查询的最终归因分数：</p><p><img src="/../imgs/$%7Bfiilename%7D/TJE9KG2X.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/TJE9KG2X.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;TJE9KG2X&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22RUKKVDNU%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B320.192%2C349.5%2C562.5%2C388.731%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;404&quot; height=&quot;65&quot; src=&quot;attachments/TJE9KG2X.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 n 是第 l 层中的神经元数量。最后，<strong>我们可以找到归因分数大于阈值τ的神经元，并将其视为知识神经元</strong>，记为N。</p><h3 id="2-2-Language-Indepent-Knowledge-Neuron-Dectection"><a href="#2-2-Language-Indepent-Knowledge-Neuron-Dectection" class="headerlink" title="2.2 Language-Indepent Knowledge Neuron Dectection"></a>2.2 Language-Indepent Knowledge Neuron Dectection</h3><p><strong>解释</strong> 许多 PLM 支持多语言，并且这些模型中的事实知识的很大一部分是与语言无关的（Xu 等人，2023 年；Wang、Lipton 和 Tsvetkov，2020 年）。这种必要性对于探索多语言 PLM 中事实知识的存储机制变得越来越重要。我们将存储多种语言共有的事实知识的神经元定义为与语言无关的知识神经元，记为 L。为了识别这些类型的知识神经元，我们设计了一种检测算法，如下所示。</p><p><strong>算法</strong> 如图 2 的模块 2 所示，<span style="background-color: #ff666680">给定 K 种语言中具有相同语义的事实三元组，让相应的查询用 qk 表示，其中 k &#x3D; 1, 2, …。 。 。 ，K。对于每个查询，我们使用知识神经元定位模块来获取相应的知识神经元，其中神经元 w(l) i 的属性得分记为攻击 (w(l) i )。多语言PLM对不同语言的敏感度不同，导致不同语言查询的归因分数存在显着差异。</span>因此，很难通过设置统一的阈值来获得所有语言的知识神经元。为了解决这个问题，我们设计了一种多语言阈值调整技术。<span style="background-color: #ff666680">我们为不同的语言设置不同的缩放因子τk，并记录查询qk对应的神经元的最大归因得分，然后确定动态阈值：</span></p><p><img src="/../imgs/$%7Bfiilename%7D/P9A52SBQ.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/P9A52SBQ.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;P9A52SBQ&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22CMF6JKKR%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B51.923%2C615.462%2C295.962%2C635.077%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;407&quot; height=&quot;33&quot; src=&quot;attachments/P9A52SBQ.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>然后，我们使用阈值过滤来识别第 k 种语言的知识神经元 Nk ，如下所示：</p><p><img src="/../imgs/$%7Bfiilename%7D/363QLBKW.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/363QLBKW.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;363QLBKW&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22UBY826H3%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B54.231%2C568.731%2C295.962%2C590.077%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;403&quot; height=&quot;36&quot; src=&quot;attachments/363QLBKW.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>最后，我们计算所有语言的知识神经元的交集：</p><p><img src="/../imgs/$%7Bfiilename%7D/IECZZKEA.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/IECZZKEA.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;IECZZKEA&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22KA6FW74N%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B55.962%2C509.308%2C294.808%2C545.077%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;398&quot; height=&quot;60&quot; src=&quot;attachments/IECZZKEA.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 L 代表独立于语言的知识神经元，编码在所有考虑的语言中一致的事实知识。通过上述算法，我们最终可以得到它们。</p><h3 id="2-3Degenerate-Knowledge-Neuron-Detection"><a href="#2-3Degenerate-Knowledge-Neuron-Detection" class="headerlink" title="2.3Degenerate Knowledge Neuron Detection"></a>2.3Degenerate Knowledge Neuron Detection</h3><p>**解释 **通过进行深入分析，我们发现了一个有趣的现象：<span style="background-color: #ff666680">不同的神经元组负责存储相同的事实知识。例如，对于表示为 ⟨h, r, t⟩ 的特定事实，假设我们定位 10 个标记为 N &#x3D; {1, 2, … 的知识神经元。 。 。 ，10}。如果我们抑制集合 A &#x3D; {1, 2} 或 B &#x3D; {3, 4, 5}（N 的两个子集）的神经元，我们观察到预测概率没有显着下降。相反，同时抑制这两组神经元（即 A∪B）会导致预测概率的大幅损失。这表明 A 组和 B 组都包含相同的事实知识，至少其中一个必须是活跃的，模型才能准确理解事实。</span>此外，<span style="background-color: #5fb23680">这两组神经元并不相互冗余。也就是说，除了事实⟨h，r，t⟩之外，A还可以存储事实⟨h1，r1，t1⟩，而B可以存储⟨h2，r2，t2⟩，从而在PLM中发挥附加作用。</span>鉴于这种行为与生物神经网络中的退化现象相似（Tononi、Sporns 和 Edelman 1999；Mason 2015），我们为这些神经元创造了术语“退化知识神经元”。接下来详细介绍这个概念。算法 正式地，令 N &#x3D; {n1, . 。 。 , nk} 是所有局部知识神经元 1 的集合，我们将退化知识神经元定义为 D &#x3D; {d1D, . 。 。 , dDm}，其中每个 dD i &#x3D; {ni1, . 。 。 ,niv}包含v个知识神经元，并且满足以下条件：</p><p><img src="/../imgs/$%7Bfiilename%7D/SUFF78G3.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/SUFF78G3.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;SUFF78G3&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22BIA5YB3C%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B53.654%2C117%2C297.115%2C163.154%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;406&quot; height=&quot;77&quot; src=&quot;attachments/SUFF78G3.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><img src="/../imgs/$%7Bfiilename%7D/GVDGBVQB.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/GVDGBVQB.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;GVDGBVQB&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22MLUF5LZR%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%224%22%2C%22position%22%3A%7B%22pageIndex%22%3A3%2C%22rects%22%3A%5B%5B313.269%2C513.346%2C565.962%2C745.269%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%224%22%7D%7D&quot; width=&quot;421&quot; height=&quot;386&quot; src=&quot;attachments/GVDGBVQB.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中 Ps(ni) 是并集 Sv j&#x3D;1 nij 的真子集，即 Ps(ni) ⊊ Sv j&#x3D;1 nij。 Prob(X)是当神经元集合X被激活时模型的预测概率，Tlow和Thigh是可接受的预测概率差的预定义阈值。式(9)表明，抑制dD i 的任意真子集，即Ps(ni)，不会导致预测概率显着下降；而等式（10)表明，抑制dD i 中的所有神经元将导致预测概率显着下降。这表明这些神经元存储相同的知识。</p><p>    一般情况下，<span style="background-color: #ff666680">考虑到我们有n个知识神经元，我们需要评估所有可能的子集，找到D的复杂度是O(2n)。为了使问题易于处理，我们通过假设每个 dD i 仅包含两个知识神经元来简化问题。这个假设将问题复杂度降低到 O(n2)。</span></p><p>    为了进一步减少计算量，我们设计了两步过滤过程。如图2的算法1和模块3所示，我们<span style="background-color: #ff666680">首先抑制每个神经元并记录不会导致预测概率显着下降的神经元，这些神经元被视为潜在的简并知识神经元Pd</span>。对于Pd中的元素，进行二次过滤：<span style="background-color: #ff666680">抑制其中的神经元对，如果该操作导致模型的预测概率显着下降，则将该神经元对记录为退化知识神经元dD i </span>。最后我们可以将退化的知识神经元返回为D。</p><h2 id="3-Experiments"><a href="#3-Experiments" class="headerlink" title="3 Experiments"></a>3 Experiments</h2><h3 id="3-1Experimental-Settings"><a href="#3-1Experimental-Settings" class="headerlink" title="3.1Experimental Settings"></a>3.1Experimental Settings</h3><p><strong>模型选择和数据集</strong> 在我们的实验中，我们选择了两种不同的多语言 PLM：m-BERT (Devlin et al. 2018) 和 m-GPT (Shliazhko et al. 2022)。 m-BERT 是一种自动编码模型，针对多种多语言数据集进行了预训练，而 m-GPT 是一种自回归模型，旨在处理 61 种语言的广泛语料库。关于数据集，我们采用 mLAMA (Kassner, Dufter, and Sch utze 2021)，它是原始 LAMA (Petroni et al. 2019a, 2020) 的多语言扩展，用于本地化多语言 PLM 中的知识。</p><p>**评估指标 **我们对这两种方法应用相同的神经元编辑操作，其中检测到的知识神经元被抑制或增强，然后计算 PLM 对相关和不相关事实的预测概率。为了全面比较不同方法的知识定位精度，我们提出了一种新的评估指标来评估整个数据集知识定位的结果：</p><p><img src="/../imgs/$%7Bfiilename%7D/KX4LAIXX.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/KX4LAIXX.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;KX4LAIXX&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FEYHEHWWX%22%2C%22annotationKey%22%3A%22V2QVIJNH%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%225%22%2C%22position%22%3A%7B%22pageIndex%22%3A4%2C%22rects%22%3A%5B%5B54.808%2C575.077%2C295.962%2C609.115%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F77ALXKTW%22%5D%2C%22locator%22%3A%225%22%7D%7D&quot; width=&quot;402&quot; height=&quot;57&quot; src=&quot;attachments/KX4LAIXX.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>其中SRx是编辑成功率，x代表我们抑制或增强神经元的编辑操作。给定一个查询，它本身被认为是相关事实，并且随机选择不同类型的事实作为其不相关事实。 ΔP robrx 和 ΔP robix 分别表示相关事实和不相关事实在操作 x 下预测概率的平均变化。总体而言，<span style="background-color: #ff666680">我们希望相关事实随着知识神经元的变化而变化，而不相关事实保持不变；因此，成功率越高，定位效果越好</span>2。由于我们分别对神经元进行抑制和增强操作，因此将这两种情况的成功率总结为最终的成功率：SR &#x3D; SRenhance + SRsuppress。</p><h3 id="3-2Localization-of-Knowledge-Neurons"><a href="#3-2Localization-of-Knowledge-Neurons" class="headerlink" title="3.2Localization of Knowledge Neurons"></a>3.2Localization of Knowledge Neurons</h3><p>我们使用模块1在英语和中文数据集上的m-BERT和m-GPT模型上进行实验，并以Dai等人（2022）提出的方法作为基线，我们将其表示为B-KN。我们的研究结果如表 1 和图 3 所示，从中我们得出了一些重要的见解。</p><p>      (1) 我们的方法在所有设置下都取得了更好的结果。在表1中，我们使用AMIG来表示我们的方法，表中的结果代表平均成功率SR。在所有设置下，我们的方法都优于 B-KN，特别是对于中国数据集，m-BERT 和 m-GPT 的成功率分别提高了 84.34% 和 44.49%。这表明我们的方法定位的知识神经元更加精确。</p><p>    <span style="background-color: #5fb23680">（2）在m-BERT中，知识神经元主要位于最后层，而在m-GPT中，知识神经元位于前、中、最后层，如图3所示，其中x和y轴代表PLM分别是层数和知识神经元的百分比。这可能是由于自动编码模型（例如 m-BERT）共享编码空间并在最后几层中编码高级特征，而自回归模型（例如 m-GPT）逐渐细化每层的特征来预测下一个单词。</span></p><p>      (3)汉语和英语的知识神经元分布较为相似，但也存在差异。相似之处可能是由于事实具有相同的含义语言之间存在差异，而差异可能是由于语言之间固有的结构和句法差异或预训练语料库质量的差异造成的。</p><h2 id="3-3-Language-Independence-Neurons-and-Cross-Lingual-Knowledge-Editing"><a href="#3-3-Language-Independence-Neurons-and-Cross-Lingual-Knowledge-Editing" class="headerlink" title="3.3 Language-Independence Neurons and Cross-Lingual Knowledge Editing"></a>3.3 Language-Independence Neurons and Cross-Lingual Knowledge Editing</h2><p><strong>语言无关神经元</strong>的定位通过我们对模块 2 的实验，我们捕获了图 3 中的结果。结果表明，<span style="background-color: #ff666680">无论是 m-BERT 还是 m-GPT，语言无关的知识神经元主要集中在最后一两个层。</span><span style="background-color: #5fb23680">这可能是因为独立于语言的事实充当高级特征，而 PLM 只能在最后几层成功地对它们进行编码。</span>跨语言知识编辑实验设置我们基于与语言无关的知识神经元设计跨语言编辑实验。与知识本地化实验的设置类似，我们抑制或者增强语言无关的知识神经元并计算编辑成功率SR。为了证明独立于语言的知识神经元的作用，我们设计了两个比较实验。（1）编辑一种语言的知识神经元，观察另一种语言相应事实的变化。 （2）依次编辑两种语言的知识神经元，观察两种语言对应事实的变化。跨语言知识编辑实验结果我们对表2的分析揭示了两个见解：</p><p><span style="background-color: #ff666680">（1）独立于语言的知识神经元促进跨语言编辑。与仅编辑中文或英文相比，编辑与语言无关的知识神经元在所有设置下都有更高的成功率；在中国数据集中，m-BERT 和 m-GPT 的成功率分别提高了 213.05% 和 277.36%。这意味着用一种语言编辑事实知识并期望其他语言发生相应变化的挑战；然而，利用独立于语言的知识神经元可以实现这一点。</span></p><p><span style="background-color: #ff666680">（2） 单独编辑每种语言并不能保证获得更好的结果。尽管人们可以直观地编辑每种语言以实现跨语言的更改，但我们的实验表明，这种方法不仅依赖更多的计算资源，而且可能表现不佳。与使用语言无关神经元相比，顺序编辑导致 mBERT 和 m-GPT 的成功率分别降低 42.97% 和 58.80%，这可能是由于多次编辑造成的混乱。这强调了语言独立神经元的重要性。</span></p><h3 id="3-4Degenerate-Knowledge-Neurons-and-Fact-Checking-Experiment"><a href="#3-4Degenerate-Knowledge-Neurons-and-Fact-Checking-Experiment" class="headerlink" title="3.4Degenerate Knowledge Neurons and Fact-Checking Experiment"></a>3.4Degenerate Knowledge Neurons and Fact-Checking Experiment</h3><p>多语言PLM中简并知识神经元的识别我们使用模块3设置了一个实验来研究简并知识神经元，结果如图4所示。<span style="background-color: #5fb23680">根据我们的观察，m-BERT和m-GPT中的简并知识神经元表现出分布模式类似于知识神经元。</span>这不仅表明了简并性之间存在很强的相关性。单语言 PLM 中简并知识神经元的识别在我们的单语言 PLM 实验中，我们成功识别了简并知识神经元，并证明它们本质上存在于 PLM 中。关于简并知识神经元的一个可能的问题是：<span style="background-color: #5fb23680">PLM 是否以多种语言存储相同的事实，从而利用多个神经元集来获取相同的信息？为了消除这种观念并证明简并知识神经元的存在与 PLM 中多语言的支持无关，</span>我们将探索扩展到单语言 PLM，特别是 BERT 和 GPT-2。这些简并知识神经元的分布如图 5 所示，进一步证实了我们的结论。事实检查实验设置 PLM 可能会隐藏虚假事实（Edwards 2023；Pitt 2022），而当前的解决方案通常依赖外部数据进行事实检查（Vladika 和 Matthes 2023）。考虑到简并知识神经元功能重叠的性质，我们设计了一个事实检查实验，以在不依赖外部数据的情况下基于简并知识神经元检测错误事实。接下来，我们详细介绍我们的实验设置。</p><p>     首先，mLAMA 数据集被修改以包含错误的事实属性。<span style="background-color: #2ea8e580">对于与某个事实关系名称相关的事实三元组，例如 ⟨Tanzania, Capital, Dodoma⟩ ，我们从相同的关系名称中随机选择一个对象（例如，达累斯萨拉姆）作为错误事实。</span>然后，为了验证我们的发现的实际意义，<span style="background-color: #ff666680">我们将数据集中的每种类型的查询按比例分为两部分。对于每种类型，第一段用于获取简并知识神经元，并识别数量超过 t% 特定阈值的神经元。随后，我们将第二部分中的查询以及相应的正确或错误事实作为输入并计算简并知识神经元的平均激活分数。如果平均激活分数超过预定义的阈值 λ，则该事实被分类为正确；否则，它被归类为 false。</span>我们使用原始PLM直接评估事实的正确性进行比较分析。这种配置可以防止 PLM 使用查询本身的简并知识神经元进行事实检查，从而使实验更加令人信服。我们在表3中将我们的方法表示为“with DKN”。最后，由于当前的事实核查方法必须依赖于外部数据，因此我们使用PLM直接执行事实核查作为我们方法的基线，表示为“wo表 3 中的“DKN”。我们使用 Precision、Recall 和 F1-score 作为评估指标。</p><p>事实核查实验结果 表 3 中的结果使我们得出以下结论。</p><p>（1）<span style="background-color: #ff666680">退化的知识神经元可以帮助 PLM 检测错误的事实。</span>在各种设置下，我们的方法比基线方法更好，特别是对于中国数据集和自回归模型。例如，在 m-GPT 和中文数据集的背景下，我们的方法的 F1 分数与基线相比增加了 167150%。<span style="background-color: #5fb23680">这一实质性改进表明简并知识神经元的存在增强了 PLM 对事实知识的稳定掌握。</span></p><p>（2）<span style="background-color: #5fb23680">使用PLM进行事实检查，他们经常判断一个事实是正确的，从而导致极高的召回率。这与观察结果一致，即如果提出错误的前提，生成语言模型可能会产生不正确的信息</span>（Edwards 2022；Lakshmanan 2022；Metz 2022）。</p><p>（3）<span style="background-color: #5fb23680">自回归模型比自编码模型表现出更高的召回率。</span>这可能是由于自回归设计更注重一致性而不是准确性，并且自动编码在评估中可能更加保守（Zhou et al. 2023）。 (4)简并知识神经元的存在与PLM中多语言的支持无关。在单语言 PLM 中，即 BERT 和 GPT-2，事实检查也可以基于简并知识神经元进行。这一结果进一步证明了简并知识神经元的存在及其有用性。</p><h2 id="4-Related-Work"><a href="#4-Related-Work" class="headerlink" title="4 Related Work"></a>4 Related Work</h2><p>知识定位现有的方法大致分为两类：（1）基于梯度的方法：Dai et al.（2022）首先引入了知识神经元的概念，并通过评估每个神经元的贡献来定位它们（​​Geva et al. 2021）使用积分梯度计算他们的归因得分。 （2）Causal-inspired方法，由Meng等人（2022a）提出，将知识神经元定义为PLM中对预测某些事实知识具有最强因果效应的神经元激活，该方法启发了知识编辑算法的创建例如 ROME（Meng 等人，2022a）、MEMIT（Meng 等人，2022b）和 MEND（Mitchell 等人，2022）。然而，当前的方法缺乏针对不同 PLM 架构和多种语言探索的通用方法。公理归因方法 Sundararajan、Taly 和 Yan（2017）介绍了公理归因方法，强调敏感性和实现不变性作为归因方法的核心公理，从而产生了积分梯度（IG）。后续研究包括Discretized IG (Sanyal and Ren 2021)，它使用插值策略来提高梯度精度； Sequential IG (Enguehard 2023) 专为单词重要性评估而设计；有效 Shapley 值以及 Shapley IG，由 Liu 等人 (2022) 开发，用于提高效率和效果。我们改进了 IG 的基线向量，以最大限度地减少其信息内容。</p><h2 id="5-Conclusion"><a href="#5-Conclusion" class="headerlink" title="5 Conclusion"></a>5 Conclusion</h2><p>     在这项研究中，我们使用适应架构的多语言集成梯度方法探索多语言 PLM 中的事实知识本地化。我们进一步设计了两个模块，导致了语言无关知识神经元和简并知识神经元的两个发现。前者肯定了多语言PLM中的一部分知识以超越语言的形式存在，而后者则引入了一种新型神经元，类似于生物系统中观察到的退化现象，这些神经元可以用来检测不正确的信息。事实。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑大型语言模型：问题、方法和机遇</title>
      <link href="/2023/11/02/bian-ji-da-xing-yu-yan-mo-xing-wen-ti-fang-fa-he-ji-yu/"/>
      <url>/2023/11/02/bian-ji-da-xing-yu-yan-mo-xing-wen-ti-fang-fa-he-ji-yu/</url>
      
        <content type="html"><![CDATA[<h1 id="编辑大型语言模型：问题、方法和机遇"><a href="#编辑大型语言模型：问题、方法和机遇" class="headerlink" title="编辑大型语言模型：问题、方法和机遇"></a>编辑大型语言模型：问题、方法和机遇</h1><h2 id="Abstruct"><a href="#Abstruct" class="headerlink" title="Abstruct"></a>Abstruct</h2><p>尽管有能力培养有能力的LLMs，但维持其相关性和纠正错误的方法仍然难以捉摸。为此，过去几年见证了LLMs编辑技术的激增，其<span style="background-color: #2ea8e580">目标是有效地改变特定领域内LLMs的行为，而不会对其他输入的性能产生负面影响</span>。本文深入探讨了LLMs模型编辑相关的问题、方法和机遇。特别是，我们<span style="background-color: #ff666680">对任务定义和与模型编辑相关的挑战进行了详尽的概述，并对我们目前掌握的最先进的方法进行了深入的实证分析</span>。我们还<span style="background-color: #ff666680">构建了一个新的基准数据集，以促进更稳健的评估并查明现有技术固有的持久问题</span>。我们的目标是为每种编辑技术的有效性和可行性提供有价值的见解，从而帮助社区做出明智的决定，为特定任务或上下文选择最合适的方法。</p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>大型语言模型（LLM）已经表现出理解和生成类人文本的非凡能力（Brown et al., 2020；OpenAI, 2023；Anil et al., 2023；Touvron et al., 2023；Qiao et al., 2022；赵等人，2023）。尽管LLMs的训练非常熟练，但确保其相关性和修复错误的策略仍不清楚。理想情况下，随着世界形势的发展，我们的目标是更新LLMs，避免与训练全新模型相关的计算负担。如图1所示，解决这个问题模型编辑的概念被提出</p><p><img src="/../imgs/$%7Bfiilename%7D/SWBFWKDL.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/SWBFWKDL.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;SWBFWKDL&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%226BF2NSVY%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%221%22%2C%22position%22%3A%7B%22pageIndex%22%3A0%2C%22rects%22%3A%5B%5B300.5%2C490.39%2C533%2C628.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%221%22%7D%7D&quot; width=&quot;388&quot; height=&quot;231&quot; src=&quot;attachments/SWBFWKDL.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>（Sinitsin 等人，2020；De Cao 等人，2021），<span style="background-color: #2ea8e580">能够对模型的行为进行数据有效的改变，特别是在指定的感兴趣领域内，同时确保不会对其他输入产生不利影响。</span>目前，大量关于LLMs模型编辑的工作（De Cao et al., 2021；Meng et al., 2022, 2023；Sinitsin et al., 2020；Huang et al., 2023)在各种编辑任务和设置方面取得了长足的进步。如图 2 所示，<span style="background-color: #2ea8e580">这些工作通过将辅助网络与原始未更改的模型集成或更改导致不良输出的模型参数来操纵特定情况下的模型输出。</span>尽管文献中存在广泛的模型编辑技术，但<span style="background-color: #5fb23680">明显缺乏在统一实验条件下评估这些方法的全面比较分析。缺乏直接比较会削弱我们辨别每种方法相对优缺点的能力，从而阻碍我们理解它们在不同问题领域的适应性。</span></p><p>     为了解决这个问题，本研究致力于建立一个标准的问题定义，并对这些方法进行细致的评估（§2，§3）。我们在规定的条件下进行实验，促进对各自的优缺点进行公正的比较（§4）。<span style="background-color: #2ea8e580">我们最初使用两个流行的模型编辑数据集，ZsRE (Levy et al., 2017) 和 COUNTERFACT (Meng et al., 2022)，以及两个结构上的数据集不同的语言模型，T5（Raffel et al.，2020a）（编码器-解码器）和 GPT-J（Wang 和 Komatsuzaki，2021a）（仅解码器）作为我们的基础模型</span>。我们还评估了较大模型 OPT-13B（Zhang 等人，2022a）和 GPT-NEOX20B（Black 等人，2022）的性能。除了基本编辑设置之外，我们还评估批量和顺序编辑的性能。虽然我们观察到当前的方法在事实模型编辑任务中表现出当大的能力，但<span style="background-color: #2ea8e580">我们重新考虑当前的评估并创建一个更具包容性的评估数据集（§5）：可移植性（强大的泛化能力）、局部性（副作用）和效率（时间）和内存使用情况）</span>。我们发现当前的模型编辑方法在这些层面上有所限制，从而限制了它们的实际应用，未来值得更多的研究。通过系统评估，我们的目标是为每种模型编辑技术的有效性提供有价值的见解，帮助研究人员为特定任务选择合适的方法。</p><h2 id="2-Problem-Definition"><a href="#2-Problem-Definition" class="headerlink" title="2 Problem Definition"></a>2 Problem Definition</h2><p>模型编辑，由 Mitchell 等人阐明。 （2022b），<span style="background-color: #2ea8e580">旨在有效地调整特定编辑描述符（xe，ye）上的初始基础模型（fθ，θ表示模型的参数）行为，而不影响其他样本上的模型行为</span>。最终目标是创建一个编辑模型，表示为 fθe。具体来说，基本模型 fθ 由函数 f : X → Y 表示，该函数将输入 x 与其相应的预测 y 相关联。给定一个由编辑输入 xe 和编辑标签 ye 组成的编辑描述符，使得 fθ(xe) ̸&#x3D; ye，后期编辑模型 fθe 被设计为产生预期输出，其中 fθe(xe) &#x3D; ye。</p><p>     <span style="background-color: #2ea8e580">模型编辑过程通常会影响与编辑示例密切相关的大量输入的预测。这个输入集合称为编辑范围。</span>成功的编辑应该调整编辑范围内示例的模型行为，同时保持范围外示例的性能不变：</p><p><img src="/../imgs/$%7Bfiilename%7D/YCQJYKA2.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/YCQJYKA2.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;YCQJYKA2&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22WCMI8DSD%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%222%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B70.5%2C136.39%2C291.5%2C183.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%222%22%7D%7D&quot; width=&quot;368&quot; height=&quot;78&quot; src=&quot;attachments/YCQJYKA2.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>范围内 I(xe, ye) 通常包含 xe 及其等价邻域 N (xe, ye)，其中包括相关的输入&#x2F;输出对。相反，超出范围的 O(xe, ye) 由与编辑示例无关的输入组成。模型fe应该满足以下三个属性：可靠性、泛化性和局部性。</p><p><strong>可靠性</strong> 先前的工作（Huang et al., 2023；De Cao et al., 2021；Meng et al., 2022）定义了当后期编辑模型 fθe 给出案例 (xe, ye) 的目标答案时的可靠编辑被编辑。可靠性以编辑案例的平均准确度来衡量：</p><p><img src="/../imgs/$%7Bfiilename%7D/Q3XB8E8H.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/Q3XB8E8H.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;Q3XB8E8H&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22WHB9Z2XR%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%222%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B302.5%2C616.89%2C530%2C650.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%222%22%7D%7D&quot; width=&quot;379&quot; height=&quot;56&quot; src=&quot;attachments/Q3XB8E8H.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><strong>泛化</strong> 编辑后模型 fθe 还应该编辑等效邻居 N (xe, ye)（例如改写的句子)。它是通过模型 fθe 在从等价邻域中均匀抽取的示例上的平均精度来评估的：</p><p><img src="/../imgs/$%7Bfiilename%7D/TSPLLYFE.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/TSPLLYFE.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;TSPLLYFE&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22ICM3VKEP%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%222%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B305%2C503.39%2C527%2C538.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%222%22%7D%7D&quot; width=&quot;370&quot; height=&quot;59&quot; src=&quot;attachments/TSPLLYFE.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>**局部性 **在一些工作中，也被称为特异性。编辑应该在本地实现，这意味着编辑后模型 fθe 不应更改范围外 O(xe, ye) 中不相关示例的输出。因此，局部性是通过编辑后模型 fθe 的预测与编辑前 fθ 模型相同的来评估的</p><p><img src="/../imgs/$%7Bfiilename%7D/88F6ZZTR.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/88F6ZZTR.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;88F6ZZTR&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22KH34VUGC%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%222%22%2C%22position%22%3A%7B%22pageIndex%22%3A1%2C%22rects%22%3A%5B%5B306.5%2C364.39%2C527%2C401.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%222%22%7D%7D&quot; width=&quot;368&quot; height=&quot;62&quot; src=&quot;attachments/88F6ZZTR.png&quot; ztype=&quot;zimage&quot;&gt;"></p><h3 id="3-Current-Methods"><a href="#3-Current-Methods" class="headerlink" title="3 Current Methods"></a>3 Current Methods</h3><p>目前LLMs的模型编辑方法可以分为两种主要范式，如图2所示：<span style="background-color: #2ea8e580">修改模型参数或保留模型参数。</span>更多比较见表 6。</p><h3 id="3-1-Methods-for-Preserving-LLMs-Parameters"><a href="#3-1-Methods-for-Preserving-LLMs-Parameters" class="headerlink" title="3.1 Methods for Preserving LLMs Parameters"></a>3.1 Methods for Preserving LLMs Parameters</h3><p>**基于内存的模型 **<span style="background-color: #2ea8e580">这种方法将所有编辑示例显式存储在内存中，并使用检索器为每个新输入提取最相关的编辑事实，以指导模型生成编辑事实。 </span>SERAC（Mitchell 等人，2022b）提出了一种采用独特的反事实模型，同时保持原始模型不变的方法。具体来说，<span style="background-color: #2ea8e580">它采用范围分类器来计算新输入落入存储的编辑示例范围内的可能性。如果输入与内存中任何缓存的编辑相匹配，则反事实模型的预测将基于输入和最可能的编辑。否则，如果输入超出了所有编辑的范围，给出了原始模型的预测。</span>此外，<span style="background-color: #5fb23680">最近的研究表明LLMs拥有强大的情境学习能力。模型本身可以生成与所提供的知识相对应的输出，而不是求助于用新事实训练的额外模型，并给出精炼的知识上下文作为提示。</span><span style="background-color: #2ea8e580">这种方法通过用编辑后的事实提示模型并从编辑记忆中检索编辑演示来编辑语言模型</span>，包括以下工作：MemPrompt (Madaan et al., 2022)、IKE (Zheng et al., 2023) 和MeLLo（Zhong 等人，2023）。</p><p><img src="/../imgs/$%7Bfiilename%7D/Y5M6Y7UX.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/Y5M6Y7UX.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;Y5M6Y7UX&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%226XZYF4BM%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%223%22%2C%22position%22%3A%7B%22pageIndex%22%3A2%2C%22rects%22%3A%5B%5B79%2C517.39%2C515%2C782.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%223%22%7D%7D&quot; width=&quot;727&quot; height=&quot;443&quot; src=&quot;attachments/Y5M6Y7UX.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>**附加参数 **<span style="background-color: #2ea8e580">此范例在语言模型中引入了额外的可训练参数。这些参数在修改后的知识数据集上进行训练，而原始模型参数保持静态。</span> T-Patcher（Huang et al., 2023）在模型前馈网络（FFN）的最后一层针对一个错误集成了一个神经元（补丁），仅在遇到其对应错误时才生效。 CaliNET（Dong et al., 2022）整合了多个神经元以用于多个编辑案例。不同的是，GRACE（Hartvigsen et al., 2022）维护一个离散的密码本作为适配器，随着时间的推移添加和更新元素以编辑模型的预测。</p><h3 id="3-2-Methods-for-Modifying-LLMs-Paramete"><a href="#3-2-Methods-for-Modifying-LLMs-Paramete" class="headerlink" title="3.2 Methods for Modifying LLMs Paramete"></a>3.2 Methods for Modifying LLMs Paramete</h3><p>该范例将更新部分参数 θ，它应用更新 Δ 矩阵来编辑模型。</p><p>**定位然后编辑 **<span style="background-color: #2ea8e580">该范例首先识别与特定知识相对应的参数，并通过直接更新目标参数来修改它们。</span>知识神经元（KN）方法（Dai et al., 2022）<span style="background-color: #2ea8e580">引入了知识归因技术来精确定位体现知识的“知识神经元”（FFN 矩阵中的键值对），然后更新这些神经元。 </span>ROME（Meng et al., 2022）<span style="background-color: #2ea8e580">应用因果中介分析来定位编辑区域。 ROME 不是修改 FFN 中的知识神经元，而是改变整个矩阵。 ROME 将模型编辑视为具有线性等式约束的最小二乘法，并使用拉格朗日乘子来求解。</span>然而，<span style="background-color: #2ea8e580">KN 和 ROME 一次只能编辑一个事实关联。</span>为此，<span style="background-color: #2ea8e580">MEMIT（Meng et al., 2023）对ROME的设置进行了扩展，实现了多病例同步编辑的情况。</span>基于 MEMIT，PMET（Li et al., 2023a）涉及注意力值以获得更好的性能。</p><p><strong>元学习</strong> <span style="background-color: #2ea8e580">元学习方法采用超网络来学习编辑 LLM 所需的 Δ</span>。<span style="background-color: #2ea8e580">知识编辑器（KE）（De Cao et al., 2021）利用超网络（特别是双向 LSTM）来预测每个数据点的权重更新，从而能够在不干扰其他知识的情况下对编辑目标知识进行约束优化</span>。然而，这种方法在编辑LLMs方面存在不足。为了克服这个限制，<span style="background-color: #2ea8e580">模型编辑器网络梯度分解（MEND）（Mitchell et al., 2022a）学习通过采用梯度的低秩分解来变换微调语言模型的梯度，这可以应用于具有更好性能的LLM。</span></p><h2 id="4-Preliminary-Experiments"><a href="#4-Preliminary-Experiments" class="headerlink" title="4 Preliminary Experiments"></a>4 Preliminary Experiments</h2><p>考虑到大量以事实知识为中心的研究和数据集，我们将其用作主要比较基础。我们最初的对照实验使用两个著名的事实知识数据集（表 1）进行，促进了方法的直接比较，突出了它们独特的优势和局限性（Wang 等人，2023b）。</p><h3 id="4-1-Experiment-Setting"><a href="#4-1-Experiment-Setting" class="headerlink" title="4.1 Experiment Setting"></a>4.1 Experiment Setting</h3><p>我们使用两个著名的模型编辑数据集：ZsRE 和 COUNTERFACT，其详细信息请参见附录 B。以前的研究通常使用较小的语言模型 (&lt;1B)，并证明了当前编辑方法在 BERT 等较小模型上的有效性（Devlin 等人， 2019）。然而，这些方法是否适用于更大的模型仍有待探索。因此，考虑到编辑任务和未来的发展，我们专注于基于生成的模型并选择更大的模型：T5-XL（3B）和GPT-J（6B），代表编码器-解码器和仅解码器结构。</p><p>     我们从每种方法类型中选择了有影响力的作品。除了现有的模型编辑技术之外，我们还检查了微调的结果，这是模型更新的基本方法。为了避免重新训练所有层的计算成本，我们采用了Meng等人提出的方法。 (2022)，由 ROME 识别的微调层，我们将其表示为 FT-L。该策略确保与其他直接编辑进行公平比较方法，增强我们分析的有效性。更多详细信息请参见附录 A。</p><h3 id="4-2-Experiment-Results"><a href="#4-2-Experiment-Results" class="headerlink" title="4.2 Experiment Results"></a>4.2 Experiment Results</h3><p>基本模型表 1 <span style="background-color: #ff666680">揭示了 SERAC 和 ROME 在 ZsRE 和 COUNTERFACT 数据集上的卓越性能，SERAC 在多个指标上超过 90%。虽然 MEMIT 缺乏通用性，但它在可靠性和局部性方面表现出色。 KE、CaliNET 和 KN 表现不佳，在较小的模型中表现尚可，但在较大的模型中表现平平。 MEND 在这两个数据集上表现良好，在 T5 上的结果达到了 80% 以上，尽管不如 ROME 和 SERAC 那样令人印象深刻。 T-Patcher 模型的性能因模型架构和大小的不同而有所不同。例如，它在 ZsRE 数据集的 T5-XL 上表现不佳，而在 GPT-J 上表现完美。在 COUNTERFACT 数据集的情况下，T-Patcher 在 T5 上实现了令人满意的可靠性和局部性，但缺乏泛化性。相反，在 GPT-J 上，该模型在可靠性和泛化性方面表现出色，但在局部性方面表现不佳。</span><span style="background-color: #5fb23680">这种不稳定性可归因于模型架构，因为 T-Patcher 在 T5 的最终解码器层添加了一个神经元；</span><span style="background-color: #ff666680">然而，编码器可能仍然保留原始知识。 FT-L 在 PLM 上的表现不如 ROME，即使修改相同的位置。它在 ZsRE 数据集上显示出令人印象深刻的性能，但在 GPT-J 上的 COUNTERFACT 数据集上与 ROME 的可靠性和泛化能力相当。然而，其较低的局部性得分表明对不相关知识领域的潜在影响。 IKE 表现出良好的可靠性，但在局部性方面遇到困难，因为预先设置的提示可能会影响不相关的输入。它的泛化能力也可以提高。情境学习</span></p><p><img src="/../imgs/$%7Bfiilename%7D/B7WY2DBH.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/B7WY2DBH.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;B7WY2DBH&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22AYAJST64%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%225%22%2C%22position%22%3A%7B%22pageIndex%22%3A4%2C%22rects%22%3A%5B%5B67%2C654.39%2C531.5%2C770.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%225%22%7D%7D&quot; width=&quot;774&quot; height=&quot;193&quot; src=&quot;attachments/B7WY2DBH.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>该方法可能会遇到上下文调解失败的问题（Hernandez et al., 2023)，因为预先训练的语言模型可能无法始终生成与提示对齐的文本。</p><p><strong>模型缩放</strong> 由于计算限制，我们使用更大的模型进行实验，在 OPT-13B 和 GPT-NEOX-20B 上测试 IKE、ROME 和 MEMIT。结果（表 2）令人惊讶地<span style="background-color: #ff666680">显示 ROME 和 MEMIT 在 GPT-NEOX-20B 模型上表现良好，但在 OPT-13B 上表现不佳。这是由于这两种方法都依赖于矩阵求逆运算。然而，在 OPT-13B 模型中，矩阵是不可逆的。</span>我们甚至根据经验发现，<span style="background-color: #5fb23680">用最小二乘法逼近解会产生不令人满意的结果。我们认为这是 ROME 和 MEMIT 的局限性，因为它们不能应用于不同的模型。</span> <span style="background-color: #ff666680">MEMIT 由于依赖多层矩阵计算而表现较差，并且对于较大模型，其可靠性和泛化性比 ROME 下降得更多。 IKE 的性能受到模型本身的上下文学习能力的影响。 OPT的结果比GPT-J的结果还要差，这可能归因于OPT本身的上下文学习能力。</span><span style="background-color: #5fb23680">此外，随着模型大小的增加，其泛化和局部性的性能都会下降。</span></p><p><strong>批量编辑</strong> 鉴于许多研究通常将更新限制为几十个事实或仅关注单个编辑案例，我们进行了进一步的批量编辑分析。然而，通常需要同时修改具有多个知识片段的模型。我们重点关注支持批量编辑的方法（FT、SERAC、MEND 和 MEMIT），并在图 3 中展示了它们的性能。值得注意的是，<span style="background-color: #ff666680">MEMIT 支持LLMs的大规模知识编辑，允许以最少的时间和内存进行数百甚至数千个同时编辑成本。其在可靠性和泛化方面的性能在最多 1000 次编辑时仍然保持稳健，但局部性在此级别下降。而 FT-L、SERAC、和MEND还支持批量编辑，它们需要大量内存来处理更多情况，超出了我们当前的能力。因此，我们将测试限制为 100 次编辑。 SERAC 可以完美地进行最多 100 次编辑的批量编辑。 MEND 和 FT-L 在批量编辑中的性能并不那么强，随着编辑数量的增加，模型的性能迅速下降。</span></p><p><img src="/../imgs/$%7Bfiilename%7D/WVMGDVMU.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/WVMGDVMU.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;WVMGDVMU&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22UTUV86Q8%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%225%22%2C%22position%22%3A%7B%22pageIndex%22%3A4%2C%22rects%22%3A%5B%5B303%2C516.89%2C528%2C639.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%225%22%7D%7D&quot; width=&quot;375&quot; height=&quot;204&quot; src=&quot;attachments/WVMGDVMU.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><strong>顺序编辑</strong> 请注意，默认评估过程是更新单个模型知识，评估新模型，然后回滚更新，然后对每个测试点重复该过程。在实际场景中，模型在进行新的编辑时应保留先前的更改。因此，进行连续编辑的能力是模型编辑的一个重要特征（Huang et al., 2023）。我们评估了具有强大的单编辑性能的顺序编辑方法，并在图 4 中报告了结果。<span style="background-color: #ff666680">冻结模型参数的方法（如 SERAC 和 T-Patcher)通常在顺序编辑中表现出稳定的性能。然而，那些改变模型参数的人却很困难</span>。 <span style="background-color: #ff666680">ROME 在 n &#x3D; 10 之前表现良好，然后在 n &#x3D; 100 时下降。MEMIT 的性能也会在超过 100 次编辑后下降，但不如 ROME 大幅下降。同样，MEND 在 n &#x3D; 1 时表现良好，但在 n &#x3D; 10 时表现明显下降。随着编辑过程的继续，这些模型越来越偏离其原始状态，导致性能次优。</span></p><h2 id="5-Comprehensive-Study"><a href="#5-Comprehensive-Study" class="headerlink" title="5 Comprehensive Study"></a>5 Comprehensive Study</h2><p>考虑到上述几点，我们认为以前的评估指标可能无法充分评估模型编辑能力。因此，我们提出对可移植性、局部性和效率进行更全面的评估。</p><h3 id="5-1-Portability-Robust-Generalization"><a href="#5-1-Portability-Robust-Generalization" class="headerlink" title="5.1 Portability - Robust Generalization"></a>5.1 Portability - Robust Generalization</h3><p>几项研究使用通过反向翻译生成的样本来评估泛化性（De Cao 等人，2021）。然而，这些释义的句子通常只涉及微小的措辞变化，并不能反映实质性的事实修改。正如 Jacques Thibodeau (2022) 中所述，验证这些方法是否能够处理编辑对实际应用程序的影响至关重要。因此，我们引入了一种称为可移植性的新评估指标，以衡量模型编辑在将知识转移到相关内容方面的有效性，称为鲁棒泛化。因此我们考虑三个方面：（1）<strong>主语替换</strong>：由于大多数改写的句子保留了主语描述，但更多地改写了关系，我们通过替换来测试泛化能力问题中的主题带有别名或同义词。这测试模型是否可以将编辑的属性推广到同一主题的其他描述。 (2)<strong>反向关系</strong>：当编辑主体和关系的目标时，目标实体的属性也发生变化。我们通过过滤合适的关系（例如一对一）并询问相反的问题来检查目标实体是否也更新来测试模型处理此问题的能力。 （3）<strong>一跳</strong>：修改后的知识应该可以被编辑后的语言模型用于下游任务。例如，如果我们更改“瓦茨·汉弗莱 (Watts Humphrey) 就读哪所大学？”这个问题的答案。从“三一学院”到“密歇根大学”，当被问到“Watts Humphrey 在大学学习期间住在哪个城市？”时，模型应该回答“密歇根州的安娜堡”而不是“爱尔兰的都柏林”。因此，我们构建了一个推理数据集来评估编辑后模型使用编辑知识的能力。</p><p>     我们将一个新部分 P (xe, ye) 合并到现有数据集 ZsRE 中，可移植性计算为应用于 P (xe, ye) 中的推理示例时编辑模型 (fθe) 的平均准确度：</p><p><img src="/../imgs/$%7Bfiilename%7D/AKCEUPGK.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/AKCEUPGK.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;AKCEUPGK&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22J5ARE9LF%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%226%22%2C%22position%22%3A%7B%22pageIndex%22%3A5%2C%22rects%22%3A%5B%5B306.5%2C154.39%2C526.5%2C190.39%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%226%22%7D%7D&quot; width=&quot;367&quot; height=&quot;60&quot; src=&quot;attachments/AKCEUPGK.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><em><em>数据集构建 *<em>对于一跳数据集<span style="background-color: #ff666680">，在原始编辑中，我们将主题 s 的答案从 o 更改为 o</em>。然后，我们提示模型生成链接的三元组 (o*, r</em>, o′*)。随后，GPT-4 根据这个三元组和 s 创建一个问题和答案。尤其，如果模型可以回答这个新问题，意味着它具有三元组 (o</em>, r*, o′*) 的预先存在的知识。我们通过要求模型从 o* 和 r* 预测 o’* 来过滤未知的三元组。如果成功，则推断该模型具有先验知识。最后，人类评估者验证三元组的准确性和问题的流畅性</span>。其他详细信息，例如我们使用的演示和数据集构建的其他部分，可以在附录 B 中找到。</p><p>**结果 **我们根据新提出的评估指标和数据集进行实验，结果如表3所示。如表所示，<span style="background-color: #ff666680">当前模型编辑方法在可移植性方面的性能有些欠佳。尽管 SERAC 在之前的指标上显示出无可挑剔的结果，但在所有三个可移植性方面的准确度均低于 20%。 SERAC的瓶颈在于分类器的准确性和附加模型的能力。对于主题替换场景，包括SERAC、MEND、ROME和MEMIT，只能适应特定的主题实体表达，而不能泛化到主题实体的概念。然而，FT-L、IKE 和 T-patcher 在面对替换主题时表现出了出色的性能。</span>关于反向关系，我们的结果表明，<span style="background-color: #ff666680">当前的编辑方法主要编辑单向关系，IKE 是一个明显的例外，在 GPT-J 和 GPT-NEOX-20B 上都达到了 90% 以上。其他方法改变主体实体的属性，同时保持客体实体不受影响</span>。在一跳推理环境中，<span style="background-color: #ff666680">大多数编辑方法都难以将改变的知识转移到相关事实。</span>出乎意料的是，<span style="background-color: #5fb23680">ROME、MEMIT和IKE在可移植性方面表现出相对值得称赞的表现（超过50%）。他们不仅能够编辑原始案件，而且能够在某些方面修改与案件相关的事实</span>。综上所述，在我们的评估中，IKE 在三个场景中都表现出了相对较好的性能。然而，很明显，当前的模型编辑技术在管理编辑的后果方面继续面临挑战，即确保知识的变化在相关上下文中连贯一致地反映。事实上，这一领域需要在未来的研究中进一步调查和创新。</p><h3 id="5-2-Locality-Side-Effect-of-Model-Editing"><a href="#5-2-Locality-Side-Effect-of-Model-Editing" class="headerlink" title="5.2 Locality - Side Effect of Model Editing"></a>5.2 Locality - Side Effect of Model Editing</h3><p>在上一节中，COUNTERFACT 和 ZsRE 从以下方面评估模型编辑的局部性：COUNTERFACT 使用与目标知识相同分布的三元组，而 ZsRE 使用来自不同自然问题数据集的问题。值得注意的是，一些方法（例如 T-Patcher）在这两个数据集上表现出不同的性能。这凸显出模型编辑对语言模型的影响是多方面的，需要进行彻底、全面的评估才能充分理解其效果。为了彻底检查模型编辑的潜在副作用，我们提出了三个不同层面的评估：（1）其他关系：尽管Meng等人。 (2022)引入了本质的概念，但他们没有明确评价它。我们认为，已更新的主题的其他属性在编辑后应保持不变。 (2)分散邻里的注意力：HoelscherObermaier等人。 （2023a）发现，如果我们将编辑后的案例连接在其他不相关的输入之前，模型往往会受到编辑后的事实的影响，并继续产生与编辑后的案例一致的结果。 (3) 其他任务：基于 Skill Neuron 的断言（Wang 等人，2022），即大语言模型（LLM）中的前馈网络拥有特定于任务的知识能力，我们引入了一个新的挑战来评估模型编辑是否可能对性能产生负面影响关于其他任务。数据集构建的详细信息请参见附录 B.3。</p><p><img src="/../imgs/$%7Bfiilename%7D/ND8H464M.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/ND8H464M.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;ND8H464M&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22DX678K73%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%227%22%2C%22position%22%3A%7B%22pageIndex%22%3A6%2C%22rects%22%3A%5B%5B297.5%2C600.89%2C529%2C776.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%227%22%7D%7D&quot; width=&quot;386&quot; height=&quot;293&quot; src=&quot;attachments/ND8H464M.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p><strong>结果</strong> 表 4 列出了我们的结果。值得注意的是，当前的编辑方法在其他属性方面表现出色，表明它们仅修改目标特征而不影响其他属性。<span style="background-color: #5fb23680">然而，它们在 Distract-Neighbor 设置中通常表现不佳，</span>如与表 1 中的结果相比性能下降所反映的那样。IKE 是一个例外，它的性能保持相对稳定，因为它继承了以下事实：</p><p><img src="/../imgs/$%7Bfiilename%7D/EQ2WM2DI.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/EQ2WM2DI.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;EQ2WM2DI&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22S55AHZG9%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B62.727%2C578.708%2C296.591%2C783.254%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;390&quot; height=&quot;341&quot; src=&quot;attachments/EQ2WM2DI.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>完全需要在输入之前连接编辑后的事实。对于常识推理任务，参数保留方法在很大程度上保持了其在其他任务上的性能。相反，改变参数的方法往往会对性能产生负面影响，MEMIT 除外。尽管参数发生了变化，MEMIT 在常识性任务中仍然保持着强劲的性能，展示了其值得称赞的局部性。</p><h3 id="5-3-Efficiency"><a href="#5-3-Efficiency" class="headerlink" title="5.3 Efficiency"></a>5.3 Efficiency</h3><p>模型编辑应最大限度地减少进行编辑所需的时间和内存，而不影响模型的性能。</p><p>时间分析表5说明了不同模型编辑技术从提供编辑案例到获得发布后编辑模型所需的时间。我们观察到，一旦超网络经过训练，KE 和 MEND 就会以相当快的速度执行编辑过程。同样，SERAC 还可以快速编辑知识，在经过训练的分类器和反事实模型的情况下，在大约 5 秒内完成该过程。然而，这些方法需要数小时至数天的额外训练和额外的数据集。在我们的实验中，在 ZsRE 数据集上训练 MEND 需要超过 7 个小时，在 3× V100 上训练 SERAC 需要超过 36 个小时。另一方面，ROME 和 MEMIT 需要预先计算维基文本的协方差统计数据。然而，这种计算非常耗时，可能需要数小时至数天才能完成。相比之下，其他方法（例如 KN、CaliNET 和 T-Patcher）可能更快，因为它们不需要任何预计算或预训练。然而，KN 和 CaliNET 在较大模型上的性能</p><p><img src="/../imgs/$%7Bfiilename%7D/K9ABI2KM.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/K9ABI2KM.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="\&lt;img alt=&quot;&quot; data-attachment-key=&quot;K9ABI2KM&quot; data-annotation=&quot;%7B%22attachmentURI%22%3A%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2F9227ERUC%22%2C%22annotationKey%22%3A%22GC2LNVEQ%22%2C%22color%22%3A%22%23ffd400%22%2C%22pageLabel%22%3A%228%22%2C%22position%22%3A%7B%22pageIndex%22%3A7%2C%22rects%22%3A%5B%5B302.045%2C605.981%2C532.5%2C781.89%5D%5D%7D%2C%22citationItem%22%3A%7B%22uris%22%3A%5B%22http%3A%2F%2Fzotero.org%2Fusers%2Flocal%2FiUeV0SQs%2Fitems%2FCU5SMQAC%22%5D%2C%22locator%22%3A%228%22%7D%7D&quot; width=&quot;384&quot; height=&quot;293&quot; src=&quot;attachments/K9ABI2KM.png&quot; ztype=&quot;zimage&quot;&gt;"></p><p>不能令人满意，T-Patcher 是最慢的，因为需要针对每个相应的错误进行单独的神经元训练。考虑到时间方面，需要一种更加省时的模型编辑方法。</p><p><strong>内存分析</strong> 图 5 显示了每种模型编辑方法的内存 VRAM 使用情况。从该图中，我们观察到大多数方法消耗的内存量相似，但 MEND 除外，它需要超过 60GB 的内存用于训练。引入额外训练的方法（例如 MEND 和 SERAC）会导致额外的计算开销，从而显着增加内存消耗。</p><h2 id="6-Relationship-with-Relevant-Works"><a href="#6-Relationship-with-Relevant-Works" class="headerlink" title="6 Relationship with Relevant Works"></a>6 Relationship with Relevant Works</h2><h3 id="6-1Knowledge-in-LLMs"><a href="#6-1Knowledge-in-LLMs" class="headerlink" title="6.1Knowledge in LLMs"></a>6.1Knowledge in LLMs</h3><p>多种模型编辑方法旨在了解 PLM 中存储的知识如何精确且直接地改变模型参数。现有工作研究了 PLM 如何存储知识的原则（Geva 等人，2021、2022；Haviv 等人，2023；Hao 等人，2021；Hernandez 等人，2023；Yao 等人， 2023；Cao et al., 2023；Lamparth and Reuel, 2023；Cheng et al., 2023；Li et al., 2023b；Chen et al., 2023；Ju and Zhang, 2023），这些都有助于模型编辑过程。此外，一些模型编辑技术与知识增强相似（Zhang et al., 2019；Lewis et al., 2020；Zhang et al., 2022b；Yasunaga et al., 2021；Yao et al., 2022；Pan et al. ., 2023）方法，因为更新模型的知识也可以被视为将知识灌输到模型中。</p><h3 id="6-2Lifelong-Learning-and-Unlearning"><a href="#6-2Lifelong-Learning-and-Unlearning" class="headerlink" title="6.2Lifelong Learning and Unlearning"></a>6.2Lifelong Learning and Unlearning</h3><p>模型编辑包括终身学习和忘却，允许自适应地添加、修改和删除知识。持续学习（Biesialska et al., 2020）可以提高模型跨任务和领域的适应性，已在 PLM 中的模型编辑中显示出有效性（Zhu et al., 2020）。此外，模型忘记敏感知识并与机器遗忘概念保持一致至关重要（Hase 等人，2023；Wu 等人，2022；Tarun 等人，2021；Gandikota 等人，2023）。</p><h3 id="6-3Security-and-Privacy-for-LLMs"><a href="#6-3Security-and-Privacy-for-LLMs" class="headerlink" title="6.3Security and Privacy for LLMs"></a>6.3Security and Privacy for LLMs</h3><p>过去的研究（Carlini 等人，2020；Shen 等人，2023）表明，LLMs可以根据某些提示生成不可靠或个人的样本。删除大型语言模型 (LLM) 中存储的潜在有害信息和隐私信息的任务对于增强基于 LLM 的应用程序的隐私和安全性至关重要（Sun 等人，2023）。模型编辑可以抑制有害语言的生成（Geva et al., 2022；Hu et al., 2023），可以帮助解决这些问题。</p><h2 id="7-Conclusion"><a href="#7-Conclusion" class="headerlink" title="7 Conclusion"></a>7 Conclusion</h2><p>我们系统地分析了编辑大语言模型（LLM）的方法。我们的目标是通过检查现有编辑技术的特征、优势和局限性，帮助研究人员更好地理解现有编辑技术。我们的分析显示了很大的改进空间，特别是在可移植性、局部性和效率方面。改进的LLMs编辑可以帮助他们更好地适应用户不断变化的需求和价值观。我们希望我们的工作能够促进开放问题和进一步研究的进展。</p>]]></content>
      
      
      <categories>
          
          <category> NLP顶会 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EMNLP2023 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记V2.0</title>
      <link href="/2023/11/02/suan-fa-bi-ji-v2.0/"/>
      <url>/2023/11/02/suan-fa-bi-ji-v2.0/</url>
      
        <content type="html"><![CDATA[<img src="../imgs/$%7Bfiilename%7D/image-20230714101300230.png" class="lazyload placeholder" data-srcset="../imgs/$%7Bfiilename%7D/image-20230714101300230.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714101300230" style="zoom:150%;" /><h2 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h2><h3 id="1-1快速排序"><a href="#1-1快速排序" class="headerlink" title="1.1快速排序"></a>1.1快速排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 没有数或者只有一个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>; <span class="comment">// 没有数或者只有一个数</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626174234450.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626174234450.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626174234450"></p><h3 id="1-2归并排序"><a href="#1-2归并排序" class="headerlink" title="1.2归并排序"></a>1.2归并排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(q, mid + <span class="number">1</span>, r);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">else</span> tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; q[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3整数二分算法"><a href="#1-3整数二分算法" class="headerlink" title="1.3整数二分算法"></a>1.3整数二分算法</h3><h4 id="1-3-1模板"><a href="#1-3-1模板" class="headerlink" title="1.3.1模板"></a>1.3.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">/**/</span></span><br><span class="line">    <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r]被划分为[l, mid]和[mid + 1, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 区间[l, r]被划分为[l, mid - 1]和[mid, r]时使用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bsearch_2</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>技巧：</li><li>假设有一个总区间，经由我们的 check 函数判断后，可分成两部分，这边以o作 true，…..作 false 示意较好识别</li><li>如果我们的目标是下面这个v，那麽就必须使用模板 1</li><li>…………….vooooooooo</li><li>假设经由 check 划分后，整个区间的属性与目标v如下，则我们必须使用模板 2</li><li>oooooooov……………….</li></ul><h4 id="1-3-2例题"><a href="#1-3-2例题" class="headerlink" title="1.3.2例题"></a>1.3.2例题</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711102910501.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711102910501.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711102910501"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711103015554.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711103015554.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711103015554"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n数组中数的个数，m询问的个数</span></span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 我们二分查找的是下标，而下标的范围是0~n-1</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl; <span class="comment">// 二分确定的不是答案，返回找不到</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// 找到了左端点，先输出即可</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>; <span class="comment">// 再次初始化查找右端点</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">                <span class="type">int</span> mid = r + l + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4浮点数二分算法"><a href="#1-4浮点数二分算法" class="headerlink" title="1.4浮点数二分算法"></a>1.4浮点数二分算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">double</span> x)</span> </span>&#123;<span class="comment">/*...*/</span>&#125; <span class="comment">//检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">bsearch_3</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>; <span class="comment">// eps表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)&#123;</span><br><span class="line">        <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5高精度加法"><a href="#1-5高精度加法" class="headerlink" title="1.5高精度加法"></a>1.5高精度加法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() &lt; B.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B, A);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6高精度减法"><a href="#1-6高精度减法" class="headerlink" title="1.6高精度减法"></a>1.6高精度减法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B，满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7高精度乘以低精度"><a href="#1-7高精度乘以低精度" class="headerlink" title="1.7高精度乘以低精度"></a>1.7高精度乘以低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A * b, A &gt;= 0, b &gt;= 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8高精度除以低精度"><a href="#1-8高精度除以低精度" class="headerlink" title="1.8高精度除以低精度"></a>1.8高精度除以低精度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> b, <span class="type">int</span> &amp;r)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9一维前缀和"><a href="#1-9一维前缀和" class="headerlink" title="1.9一维前缀和"></a>1.9一维前缀和</h3><p>下标从1开始，S0 &#x3D; 0， 方便处理边界，如求[1, 10] &#x3D; S10 - S0 &#x3D; S10 - 0 &#x3D; S10</p><p>原数组：a1, a2, …, an</p><p>前缀和数组：Si &#x3D; a1 + a2 + … + ai</p><p>如何求Si</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>; i &lt;= n; s[i] = s[i - <span class="number">1</span>] + a[i];</span><br></pre></td></tr></table></figure><p>Si的作用：快速求原数组中的一段数的和，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[l, r] = S[r] - S[l - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], S[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀和初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) S[i] = S[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// m个询问</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>] + a[<span class="number">2</span>] + ... a[i]</span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-10二维前缀和"><a href="#1-10二维前缀和" class="headerlink" title="1.10二维前缀和"></a>1.10二维前缀和</h3><p>快速计算子矩阵的和，原矩阵是aij， Sij代表以Sij这个点为界限的左上角的矩阵的和</p><p>求内部子矩阵的和时，子矩阵的左上角为x1, y1, 右下角是x2, y2;</p><p>w  &#x3D; S(x2, y2) - S(x2, y1 - 1) - S(x1 - 1, y2) + S(x1 - 1, y1 - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 矩阵的长和宽</span></span><br><span class="line"><span class="type">int</span> q; <span class="comment">// q个询问</span></span><br><span class="line"><span class="type">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前缀和初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )&#123;</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">       <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i, j] = 第i行j列格子左上部分所有元素的和</span><br><span class="line">以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-11一维差分"><a href="#1-11一维差分" class="headerlink" title="1.11一维差分"></a>1.11一维差分</h3><p>原数组是a1, a2, …, an</p><p>构造b数组b1, b2, …, bn；使得ai &#x3D; b1 + b2 + b3 + … + bi，使得a数组是b数组的前缀和</p><p>构造方法：b1 &#x3D; a1; b2 &#x3D; a2 - a1；b3 &#x3D; a3 - a2; … ; bn &#x3D; an - an - 1;</p><p>b称为a的差分，a称为b的前缀和</p><p>对b求前缀和，就可以在O(n)的时间内求出a数组</p><p>差分主要用来快速处理这样一种操作：给定区间[l, r]， 对于这个区间的所有数全部加上C，用差分可以使用O(1)的时间完成这个操作；如果还想求出操作后的a数组，就可以扫描一遍b数组，然后求前缀和即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>  N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 区间[l, r] 内全部加上c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[l] += c;</span><br><span class="line">    b[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sacnf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">insert</span>(i, i, a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// m个操作</span></span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再求原来的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) b[i] += b[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给区间[l, r]中的每个数加上c: B[l] += c, B[r + <span class="number">1</span>] -= c</span><br></pre></td></tr></table></figure><h3 id="1-12二维差分"><a href="#1-12二维差分" class="headerlink" title="1.12二维差分"></a>1.12二维差分</h3><h4 id="1-12-1模板"><a href="#1-12-1模板" class="headerlink" title="1.12.1模板"></a>1.12.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c</span><br><span class="line">S[x1, y1] += c, S[x2 + <span class="number">1</span>, y1] -= c, S[x1, y2 + <span class="number">1</span>] -= c, S[x2 + <span class="number">1</span>, y2 + <span class="number">1</span>] += c</span><br></pre></td></tr></table></figure><h4 id="1-12-2差分矩阵"><a href="#1-12-2差分矩阵" class="headerlink" title="1.12.2差分矩阵"></a>1.12.2差分矩阵</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711160430739.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711160430739.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711160430739"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711160520755.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711160520755.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711160520755"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711160533435.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711160533435.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711160533435"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, q; <span class="comment">// n矩阵长，m矩阵宽，q询问的个数</span></span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q -- )&#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-13位运算"><a href="#1-13位运算" class="headerlink" title="1.13位运算"></a>1.13位运算</h3><h4 id="1-13-1模板"><a href="#1-13-1模板" class="headerlink" title="1.13.1模板"></a>1.13.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">求n的第k位数字：n &gt;&gt; k &amp; <span class="number">1</span></span><br><span class="line">返回n的最后一位<span class="number">1</span>：<span class="built_in">lowbit</span>(n) = n &amp; -n</span><br></pre></td></tr></table></figure><h4 id="1-13-2例题"><a href="#1-13-2例题" class="headerlink" title="1.13.2例题"></a>1.13.2例题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">3</span>; k &gt;= <span class="number">0</span>; k -- )&#123;</span><br><span class="line">        cout &lt;&lt; ((n &gt;&gt; k) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-13-3Lowbit"><a href="#1-13-3Lowbit" class="headerlink" title="1.13.3Lowbit"></a>1.13.3Lowbit</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回x的最后一位1</span></span><br><span class="line">x = <span class="number">1010</span>, <span class="built_in">lowbit</span>(x) = <span class="number">10</span></span><br><span class="line">实现：x&amp;-x</span><br><span class="line">c++ 中，-x=~x+<span class="number">1</span></span><br><span class="line">x &amp; -x = x &amp; (~x + <span class="number">1</span>)</span><br><span class="line">作用：统计x中<span class="number">1</span>的个数：每次把<span class="number">1</span>去掉，最后返回即可</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) x -= <span class="built_in">lowbit</span>(x), res ++ ; <span class="comment">// 每次减去x的最后一位1</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14双指针算法"><a href="#1-14双指针算法" class="headerlink" title="1.14双指针算法"></a>1.14双指针算法</h3><h4 id="1-14-1模板"><a href="#1-14-1模板" class="headerlink" title="1.14.1模板"></a>1.14.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; i &amp;&amp; <span class="built_in">check</span>(i, j)) j ++;</span><br><span class="line">    <span class="comment">// 具体问题的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line">常见问题分类：</span><br><span class="line">    （<span class="number">1</span>）对于一个序列，用两个指针维护一段区间</span><br><span class="line">    （<span class="number">2</span>）对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作</span><br></pre></td></tr></table></figure><h4 id="1-14-2最长连续不重复子序列"><a href="#1-14-2最长连续不重复子序列" class="headerlink" title="1.14.2最长连续不重复子序列"></a>1.14.2最长连续不重复子序列</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711164424826.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711164424826.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711164424826"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711164524639.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711164524639.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711164524639"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711165512867.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711165512867.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711165512867"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        s[q[i]] ++ ;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; i &amp;&amp; s[q[i]] &gt; <span class="number">1</span>) s[q[j ++ ]] -- ;</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-14-3数组元素的目标和"><a href="#1-14-3数组元素的目标和" class="headerlink" title="1.14.3数组元素的目标和"></a>1.14.3数组元素的目标和</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711170214118.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711170214118.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711170214118"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230711170227595.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230711170227595.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230711170227595"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;agorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N], n, m, x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="comment">// 因为保证一定有解</span></span><br><span class="line">        <span class="keyword">while</span> (a[i] + b[j] &gt; x) j -- ;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[j] == x)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, j);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15离散化"><a href="#1-15离散化" class="headerlink" title="1.15离散化"></a>1.15离散化</h3><h4 id="1-15-1模板"><a href="#1-15-1模板" class="headerlink" title="1.15.1模板"></a>1.15.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()) <span class="comment">// 将所有值进行排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>()); <span class="comment">// 去除重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 找到第一个大于等于x的值</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1，2，...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-15-2区间和"><a href="#1-15-2区间和" class="headerlink" title="1.15.2区间和"></a>1.15.2区间和</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712104629899.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712104629899.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712104629899"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712104957623.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712104957623.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712104957623"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712105020352.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712105020352.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712105020352"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询10万， 插入10万，查询需要两个坐标，插入需要1个坐标，共30万</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// </span></span><br><span class="line"><span class="type">int</span> a[N],s[N]; <span class="comment">// 存的数 前缀和</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存需要离散化的值</span></span><br><span class="line">vector&lt;PII&gt; adds, query; <span class="comment">// 定义两种操作，插入和查询</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求x离散化后的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid; <span class="comment">// 找到的是大于x的最小的数</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        adds.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.<span class="built_in">push_back</span>(x); <span class="comment">// 加入到待离散化的数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">        </span><br><span class="line">        alls.<span class="built_in">push_back</span>(l); <span class="comment">// 查询的端点区间也需要离散化</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first); </span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16区间合并"><a href="#1-16区间合并" class="headerlink" title="1.16区间合并"></a>1.16区间合并</h3><h4 id="1-16-1模板"><a href="#1-16-1模板" class="headerlink" title="1.16.1模板"></a>1.16.1模板</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712153738206.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712153738206.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712153738206"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)&#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-16-2区间合并题目"><a href="#1-16-2区间合并题目" class="headerlink" title="1.16.2区间合并题目"></a>1.16.2区间合并题目</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712154001724.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712154001724.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712154001724"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712154123198.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712154123198.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712154123198"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712154612796.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712154612796.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712154612796"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712154821464.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712154821464.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712154821464"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">uisng <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp; segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123; </span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)&#123; <span class="comment">// 维护的区间严格在枚举的区间的左边</span></span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">// 不存在交集，直接加到答案里面去</span></span><br><span class="line">        st = seg.first, ed = seg.second; <span class="comment">// 更新当前所维护的区间</span></span><br><span class="line">        &#125;<span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); <span class="comment">// 有交集，那么更新右端点即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">// 防止一开始segs里面是空的</span></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二章-数据结构"><a href="#第二章-数据结构" class="headerlink" title="第二章 数据结构"></a>第二章 数据结构</h2><h3 id="2-1单链表"><a href="#2-1单链表" class="headerlink" title="2.1单链表"></a>2.1单链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头节点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2双链表"><a href="#2-2双链表" class="headerlink" title="2.2双链表"></a>2.2双链表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3栈"><a href="#2-3栈" class="headerlink" title="2.3栈"></a>2.3栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt 表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空，如果 tt &gt; 0 , 则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4队列"><a href="#2-4队列" class="headerlink" title="2.4队列"></a>2.4队列</h3><h4 id="2-4-1普通队列"><a href="#2-4-1普通队列" class="headerlink" title="2.4.1普通队列"></a>2.4.1普通队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh &lt;= tt, 则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-2循环队列"><a href="#2-4-2循环队列" class="headerlink" title="2.4.2循环队列"></a>2.4.2循环队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh表示队头，tt表示队尾的后一个位置</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[tt ++ ] = x;</span><br><span class="line"><span class="keyword">if</span> (tt == N) tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"><span class="keyword">if</span> (hh == N) hh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空，如果hh != tt, 则表示不为空</span></span><br><span class="line"><span class="keyword">if</span> (hh != tt)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5单调栈"><a href="#2-5单调栈" class="headerlink" title="2.5单调栈"></a>2.5单调栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边理他最近的比他大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6单调队列"><a href="#2-6单调队列" class="headerlink" title="2.6单调队列"></a>2.6单调队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ; <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt]), i) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7KMP"><a href="#2-7KMP" class="headerlink" title="2.7KMP"></a>2.7KMP</h3><h4 id="2-7-1模板"><a href="#2-7-1模板" class="headerlink" title="2.7.1模板"></a>2.7.1模板</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712160811922.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712160811922.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712160811922"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712161216107.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712161216107.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712161216107"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712161535453.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712161535453.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712161535453"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[i];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)&#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配之后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-7-2KMP字符串"><a href="#2-7-2KMP字符串" class="headerlink" title="2.7.2KMP字符串"></a>2.7.2KMP字符串</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712160615068.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712160615068.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712160615068"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 求next数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// KMP匹配过程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )&#123; <span class="comment">//i j错开一位，i是j + 1进行匹配的</span></span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j]; <span class="comment">// 如果没有返回起点，并且i和j + q不匹配的了，那就往前退</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ; <span class="comment">// 匹配成功了，移到下一位</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">            j = ne[j]; <span class="comment">// 匹配到最后一位想要继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-8Trie树"><a href="#2-8Trie树" class="headerlink" title="2.8Trie树"></a>2.8Trie树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根结点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnr[]存储每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9并查集"><a href="#2-9并查集" class="headerlink" title="2.9并查集"></a>2.9并查集</h3><h4 id="2-9-1模板"><a href="#2-9-1模板" class="headerlink" title="2.9.1模板"></a>2.9.1模板</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712171836155.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712171836155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712171836155"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712172137055.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712172137055.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712172137055"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712172113638.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712172113638.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712172113638"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712172215273.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712172215273.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712172215273"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）朴素并查集：</span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 存储每个节点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并a和b所在的两个集合</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）维护size的并查集</span><br><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"><span class="comment">// p[]存储每个点的祖宗节点，size[]只有祖宗节点的有意义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合</span></span><br><span class="line">size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line"></span><br><span class="line">（<span class="number">3</span>）维护到祖宗节点距离的并查集：</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">// p[]存储每个点的祖宗节点，d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的便宜量</span></span><br></pre></td></tr></table></figure><h4 id="2-9-2合并集合"><a href="#2-9-2合并集合" class="headerlink" title="2.9.2合并集合"></a>2.9.2合并集合</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712172428536.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712172428536.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712172428536"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230712172501814.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230712172501814.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712172501814"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstirng&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 点的数量和操作的数量</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 返回x的祖宗节点+路径压缩</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op, &amp;a, &amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-10堆"><a href="#2-10堆" class="headerlink" title="2.10堆"></a>2.10堆</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值，h[1]是堆顶，x的左儿子是2x，右儿子是2x+1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><h3 id="2-11一般哈希"><a href="#2-11一般哈希" class="headerlink" title="2.11一般哈希"></a>2.11一般哈希</h3><h4 id="2-11-1模板"><a href="#2-11-1模板" class="headerlink" title="2.11.1模板"></a>2.11.1模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）拉链法</span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）开放寻址法</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回应该插入的位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)&#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-11-2模拟散列表"><a href="#2-11-2模拟散列表" class="headerlink" title="2.11.2模拟散列表"></a>2.11.2模拟散列表</h4><img src="../imgs/$%7Bfiilename%7D/image-20230712223354863.png" class="lazyload placeholder" data-srcset="../imgs/$%7Bfiilename%7D/image-20230712223354863.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230712223354863" style="zoom:150%;" /><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713133117553.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713133117553.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713133117553"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713133758783.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713133758783.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713133758783"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拉链法</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    e[idx] = x, ne[idx] = h[k], h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-12字符串哈希"><a href="#2-12字符串哈希" class="headerlink" title="2.12字符串哈希"></a>2.12字符串哈希</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成p进制数，p的经验值是<span class="number">131</span>或<span class="number">13331</span>， 取这两个值冲突概率较低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值，p[k]存储p^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * p + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算字串str[1 ~ r]的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,  <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-13C-STL简介"><a href="#2-13C-STL简介" class="headerlink" title="2.13C ++ STL简介"></a>2.13C ++ STL简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">vector, 边长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>() 返回元素的个数</span><br><span class="line">    <span class="built_in">empty</span>() 返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>() 清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); it ++ )</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first 第一个元素</span><br><span class="line">    second 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line">    </span><br><span class="line">string 字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>() 返回字符串的长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度)) 返回字串</span><br><span class="line">    <span class="built_in">c_str</span>() 返回字符串数组的起始地址</span><br><span class="line">    </span><br><span class="line">queue 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>() 向队尾处插入一个元素</span><br><span class="line">    <span class="built_in">front</span>() 返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>() 弹出队头元素</span><br><span class="line">    </span><br><span class="line">priority_queue 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()</span><br><span class="line">    <span class="built_in">top</span>()</span><br><span class="line">    <span class="built_in">pop</span>()</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">stack 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>() 向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>() 返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>() 弹出栈顶元素</span><br><span class="line">    </span><br><span class="line">dequeue 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度<span class="built_in">O</span>(logn)</span><br><span class="line">    </span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">    <span class="title">insert</span><span class="params">()</span> 插入一个数</span></span><br><span class="line"><span class="function">    <span class="title">find</span><span class="params">()</span> 查找一个数</span></span><br><span class="line"><span class="function">    <span class="title">count</span><span class="params">()</span> 返回某一个数的个数</span></span><br><span class="line"><span class="function">    <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    （1）输入是一个数x，删除所有x <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">    （2）输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">    <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">lower_bound</span><span class="params">(x)</span> 返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    <span class="title">upper_bound</span><span class="params">(x)</span> 返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">map/multimap</span></span><br><span class="line"><span class="function">    <span class="title">insert</span><span class="params">()</span> <span class="comment">// 插入的数是一个pair</span></span></span><br><span class="line"><span class="function">    <span class="title">erase</span><span class="params">()</span> 输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">    <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    [] 注意multimap不支持此操作。时间复杂度是<span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">    <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap，哈希表</span></span><br><span class="line"><span class="function">    和上面的类似，增删改查的时间复杂度是<span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持<span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>, 迭代器的++， --</span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">bitset 压位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">count</span>() 返回有多少个<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">any</span>() 判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>() 判断是否全为<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">set</span>() 把所有位置为<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v) 将第k位变为v</span><br><span class="line">    <span class="built_in">reset</span>() 把所有位变为<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>() 等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="第三章-搜索与图论"><a href="#第三章-搜索与图论" class="headerlink" title="第三章 搜索与图论"></a>第三章 搜索与图论</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713134301330.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713134301330.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713134301330"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713134718087.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713134718087.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713134718087"><img src="/../imgs/$%7Bfiilename%7D/image-20230713134718359.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713134718359.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713134718359"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713143827714.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713143827714.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713143827714"></p><h3 id="3-1树与图的存储"><a href="#3-1树与图的存储" class="headerlink" title="3.1树与图的存储"></a>3.1树与图的存储</h3><p>树是一种特殊的图，与图的存储方式相同。</p><p>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</p><p>因此我们可以只考虑有向图的存储。</p><p>（1）邻接矩阵：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g[a][b] 存储边a-&gt;b</span><br></pre></td></tr></table></figure><p>（2）邻接表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k, 开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><h3 id="3-2树与图的遍历"><a href="#3-2树与图的遍历" class="headerlink" title="3.2树与图的遍历"></a>3.2树与图的遍历</h3><p> 时间复杂度O(n + m)， n表示点数，m表示边数</p><h4 id="3-2-1深度优先遍历"><a href="#3-2-1深度优先遍历" class="headerlink" title="3.2.1深度优先遍历"></a>3.2.1深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-1-1树的重心："><a href="#3-2-1-1树的重心：" class="headerlink" title="3.2.1.1树的重心："></a>3.2.1.1树的重心：</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713215615857.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713215615857.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713215615857"></p><p>  <img src="/../imgs/$%7Bfiilename%7D/image-20230713215659352.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713215659352.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713215659352"></p><p>思路是DFS。从任意一个点出发进行DFS，同时计算如果删去之，所得剩余最大连通块节点个数。先搜集其所有未访问的子树的节点个数，每次搜集到一棵子树之后，就得到了该子树的节点个数（”当前“的意思是如果删去当前节点，所得最大连通块节点个数），搜集完所有子树之后，再用总结点个数减去所有子树节点和再减去当前节点自己，就得到了当前节点父亲的那棵子树节点个数，这样就得到了最大子树的节点个数。如果其小于等于<br>$$<br>⌊ n &#x2F; 2 ⌋<br>$$<br>，说明当前点是重心（证明参考<a href="https://blog.csdn.net/qq_46105170/article/details/125841504%EF%BC%89%EF%BC%8C%E7%AD%94%E6%A1%88%E5%B7%B2%E7%BB%8F%E6%B1%82%E5%87%BA%EF%BC%8C%E5%B0%86%E8%BF%99%E4%B8%AA%E4%BF%A1%E6%81%AF%E8%BF%94%E5%9B%9E%E7%BB%99%E4%B8%8A%E4%B8%80%E5%B1%82%EF%BC%9B%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E5%AD%90%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0%E7%BB%99%E4%B8%8A%E4%B8%80%E5%B1%82%E3%80%82">https://blog.csdn.net/qq_46105170/article/details/125841504），答案已经求出，将这个信息返回给上一层；否则返回当前节点子树的节点个数给上一层。</a></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713220534251.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713220534251.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713220534251"></p><p><strong>在深度优先遍历的过程中可以求出每个点的子树的点的数量</strong></p><p><strong>而当前节点上面的连通块的点的数量就是总的点数n减去当前点所有子树的点之和后得到的数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">2</span> * N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;e[idx] = b, ne[idx] = h[a], h[a] = idx ++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以u为根的子树的点的数量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">st[u] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum = <span class="number">1</span>, res = <span class="number">0</span>; <span class="comment">// 当前点的数量，每一个连通块点数量的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j); <span class="comment">// 当前子树的大小</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, s); <span class="comment">// 当前子树也相当于一个连通块，需要比较</span></span><br><span class="line">            sum += s; <span class="comment">// 当前子树是以u为根的子树的点的数量的一部分，需要加和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 外层的那个剩余的部分</span></span><br><span class="line">    res = <span class="built_in">max</span>(res, n - sum);</span><br><span class="line">    </span><br><span class="line">    ans = <span class="built_in">min</span>(ans, res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-1-2排列数字"><a href="#3-2-1-2排列数字" class="headerlink" title="3.2.1.2排列数字"></a>3.2.1.2排列数字</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713144024647.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713144024647.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713144024647"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713144357886.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713144357886.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713144357886"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713144546091.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713144546091.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713144546091"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            path[u] = <span class="number">0</span>;</span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-1-3n-皇后问题（全排列搜索顺序）"><a href="#3-2-1-3n-皇后问题（全排列搜索顺序）" class="headerlink" title="3.2.1.3n-皇后问题（全排列搜索顺序）"></a>3.2.1.3n-皇后问题（全排列搜索顺序）</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713145220168.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713145220168.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713145220168"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713145443661.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713145443661.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713145443661"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713145920292.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713145920292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713145920292"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713210201471.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713210201471.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713210201471"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N]; <span class="comment">// 一种方案</span></span><br><span class="line"><span class="type">bool</span> col[N], dg[N], udg[N]; <span class="comment">// 行 对角线 反对角线</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == n)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">puts</span>(g[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[n - u + i])&#123;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[u + i] = udg[n - u + i] = <span class="literal">false</span>;</span><br><span class="line">            g[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-1-4n-皇后问题（逐个格子进行枚举搜索）"><a href="#3-2-1-4n-皇后问题（逐个格子进行枚举搜索）" class="headerlink" title="3.2.1.4n-皇后问题（逐个格子进行枚举搜索）"></a>3.2.1.4n-皇后问题（逐个格子进行枚举搜索）</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713150557472.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713150557472.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713150557472"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> row[N], col[N], dg[N], udg[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == n) y = <span class="number">0</span>, x ++ ; <span class="comment">// 当前行的格子全部枚举完了，横坐标置为0，纵坐标跳到下一行</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x == n)&#123; <span class="comment">// 全部格子枚举完了</span></span><br><span class="line">        <span class="keyword">if</span> (s == n)&#123; <span class="comment">// 皇后的个数等于n了，找到了一组解</span></span><br><span class="line">            <span class="keyword">for</span> (inr i = <span class="number">0</span>; i &lt; n; i ++ ) puts[g[i]];</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个格子有下面两种处理方式</span></span><br><span class="line">    <span class="comment">//  不放皇后</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s); <span class="comment">// 不放皇后，递归到下一个格子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放皇后，需要判断:这一行没有、这一列没有、对角线没有、反对角线也没有皇后，才可以放</span></span><br><span class="line">    <span class="keyword">if</span> (!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x + y] &amp;&amp; !udg[x - y + n])&#123;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x, y + <span class="number">1</span>, s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x + y] = udg[x - y + n] = <span class="literal">false</span>;</span><br><span class="line">        g[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j ++ )</span><br><span class="line">            g[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2宽度优先遍历"><a href="#3-2-2宽度优先遍历" class="headerlink" title="3.2.2宽度优先遍历"></a>3.2.2宽度优先遍历</h4><h5 id="3-2-2-1模板"><a href="#3-2-2-1模板" class="headerlink" title="3.2.2.1模板"></a>3.2.2.1模板</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713134508379.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713134508379.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713134508379"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-2图中点的层次"><a href="#3-2-2-2图中点的层次" class="headerlink" title="3.2.2.2图中点的层次"></a>3.2.2.2图中点的层次</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230628102606480.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230628102606480.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230628102606480"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230628102620699.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230628102620699.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230628102620699"></p><p>本题是图的存储+BFS的结合</p><p>图的存储用邻接表</p><p>图的权值是1的时候，<strong>重边和环不用考虑</strong>。</p><p>所有长度都是1，表示可以用BFS来求最短路，否则应该用迪杰斯特拉等算法来求图中的最短路径。</p><p>BFS需要记录的是<strong>出发点到当前点的距离</strong>，就是d数组，每次d要增加1。</p><p>一定要注意数组的初始化！！！！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h); <span class="comment">//数组的整体初始化为-1，这是链表结束循环的边界，缺少会TLE</span></span><br><span class="line"><span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="keyword">sizeof</span> d); <span class="comment">//表示没有走过。</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>, M = N &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line"><span class="type">int</span> j = e[i];</span><br><span class="line"><span class="keyword">if</span> (d[j] == <span class="number">-1</span>)&#123;</span><br><span class="line">d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++ )&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="built_in">add</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-3走迷宫"><a href="#3-2-2-3走迷宫" class="headerlink" title="3.2.2.3走迷宫"></a>3.2.2.3走迷宫</h5><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713210104059.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713210104059.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713210104059"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713212936702.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713212936702.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713212936702"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713211916396.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713211916396.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713211916396"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713211940060.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713211940060.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713211940060"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713213921010.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713213921010.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713213921010"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713212306990.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713212306990.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713212306990"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 存储迷宫</span></span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">// 存储每个点到起始点的距离</span></span><br><span class="line">PII q[N * N], Prev[N][N]; <span class="comment">// 队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>; <span class="comment">// 队头hh 队尾tt</span></span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 把起始点加入队列准备扩展</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d); <span class="comment">// 表示没有走过</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 代表【0，0】已经走过并且距离起始点的距离是0</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++ ];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i ++ )&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                Prev[x][y] = t;</span><br><span class="line">                q[ ++ tt] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用Prev数组往前推</span></span><br><span class="line">    <span class="type">int</span> x = n - <span class="number">1</span>, y = m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x || y)&#123; <span class="comment">// x y不同时为0，也就是不是起始点的时候</span></span><br><span class="line">        cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">auto</span> t = Prev[x][y];</span><br><span class="line">        x = t.first, y = t.second;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m ; j ++ )</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713215135813.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713215135813.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713215135813"></p><h3 id="3-3完全二叉树"><a href="#3-3完全二叉树" class="headerlink" title="3.3完全二叉树"></a>3.3完全二叉树</h3><p><img src="/../imgs/$%7Bfiilename%7D/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWxrYWxp77yB,size_20,color_FFFFFF,t_70,g_se,x_16.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQWxrYWxp77yB,size_20,color_FFFFFF,t_70,g_se,x_16.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"><img src="/../imgs/$%7Bfiilename%7D/7f1566770dd04ea0a518af0288821d85.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/7f1566770dd04ea0a518af0288821d85.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; q[i];</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_ = <span class="number">-1e18</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    完全二叉树 每层的开头为 2 ^ (n - 1)结尾则是2^n - 1</span></span><br><span class="line"><span class="comment">    计算每层的数值只需要两个positioner分别指向开头和结尾</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= i * <span class="number">2</span> - <span class="number">1</span> &amp;&amp; j &lt;= n; j ++ )&#123;</span><br><span class="line">            s += q[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; max_)&#123;</span><br><span class="line">            max_ = s;</span><br><span class="line">            res = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        depth ++ ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230713223821697.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230713223821697.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230713223821697"></p><h3 id="3-4堆优化版Dijkstra"><a href="#3-4堆优化版Dijkstra" class="headerlink" title="3.4堆优化版Dijkstra"></a>3.4堆优化版Dijkstra</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(mlogn) , n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储所有点到1号的距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// firatu存储距离，second存储节点的编号</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heep.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-4-4Dijkstra求最短路（朴素）"><a href="#3-4-4Dijkstra求最短路（朴素）" class="headerlink" title="3.4.4Dijkstra求最短路（朴素）"></a>3.4.4Dijkstra求最短路（朴素）</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714084320881.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714084320881.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714084320881"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714084933741.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714084933741.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714084933741"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-5Dijkstra求最短路（堆优化）"><a href="#3-4-5Dijkstra求最短路（堆优化）" class="headerlink" title="3.4.5Dijkstra求最短路（堆优化）"></a>3.4.5Dijkstra求最短路（堆优化）</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714090044519.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714090044519.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714090044519"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[N], w[N], ne[N], idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 到1号点的距离是0</span></span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;); <span class="comment">// 1号点的距离已经知道了，我们需要用它来更新其他点，距离是0，编号是1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> = heap.<span class="built_in">top</span>(); <span class="comment">// 每次找到距离最短的点</span></span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>; <span class="comment">// 这个点已经出现过，是一个冗余备份，我们跳过即可</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i]; <span class="comment">// j存储当前点的编号</span></span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance  + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5Bellman-Ford算法"><a href="#3-5Bellman-Ford算法" class="headerlink" title="3.5Bellman-Ford算法"></a>3.5Bellman-Ford算法</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714091922464.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714091922464.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714091922464"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714092003479.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714092003479.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714092003479"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714092054831.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714092054831.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714092054831"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(nm)，n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// dist[x] 存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123; <span class="comment">// 边， a表示出点，b表示入点，w表示边权</span></span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果第n次迭代任然会松弛三角不等式，就说明存在一条长度是n + 1的最短路径，由抽屉原理，路径中至少存在两个相同的点， 说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)&#123;</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-1有边数限制的最短路"><a href="#3-5-1有边数限制的最短路" class="headerlink" title="3.5.1有边数限制的最短路"></a>3.5.1有边数限制的最短路</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714092300179.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714092300179.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714092300179"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714094157178.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714094157178.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714094157178"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714094339219.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714094339219.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714094339219"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> dist[N], backup[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i ++ )&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup, dist, <span class="keyword">sizeof</span> dist);</span><br><span class="line">        <span class="keyword">for</span> (tin j = <span class="number">0</span>; j &lt; m; j ++ )&#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + w); <span class="comment">// 只用上一次的结果，来更新当前的距离</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;m);</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="number">-1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6spfa算法（队列优化的Bellman-Ford算法）"><a href="#3-6spfa算法（队列优化的Bellman-Ford算法）" class="headerlink" title="3.6spfa算法（队列优化的Bellman_Ford算法）"></a>3.6spfa算法（队列优化的Bellman_Ford算法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度平均情况下O(m), 最坏情况下O(nm)，n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> <span class="number">0x3f</span>);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123; <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7spfa判断图中是否存在负环"><a href="#3-7spfa判断图中是否存在负环" class="headerlink" title="3.7spfa判断图中是否存在负环"></a>3.7spfa判断图中是否存在负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(nm)，n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx; <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N]; <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true， 否则返回false</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n + 1个点，由抽屉原理一定有两个点相同，所以存在环</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (!st[j])&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8floyd算法"><a href="#3-8floyd算法" class="headerlink" title="3.8floyd算法"></a>3.8floyd算法</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714094546069.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714094546069.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714094546069"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度是O(n^3)，n表示点数</span></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">        <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-1Floyd求最短路"><a href="#3-8-1Floyd求最短路" class="headerlink" title="3.8.1Floyd求最短路"></a>3.8.1Floyd求最短路</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714094848386.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714094848386.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714094848386"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714094945525.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714094945525.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714094945525"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>, INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;w);</span><br><span class="line">        </span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b], w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Q -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (d[a][b] &gt; INF / <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9朴素版prim"><a href="#3-9朴素版prim" class="headerlink" title="3.9朴素版prim"></a>3.9朴素版prim</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714104327061.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714104327061.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714104327061"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714104601241.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714104601241.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714104601241"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度是O(n^2 + m), n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n; <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N]; <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">int</span> <span class="type">bool</span> st[N]; <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF（0x3f3f3f3f），否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-1Prim算法求最小生成树"><a href="#3-9-1Prim算法求最小生成树" class="headerlink" title="3.9.1Prim算法求最小生成树"></a>3.9.1Prim算法求最小生成树</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714104631106.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714104631106.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714104631106"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714104642384.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714104642384.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714104642384"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714105027044.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714105027044.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714105027044"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstirng&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t === INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10Kruskal算法"><a href="#3-10Kruskal算法" class="headerlink" title="3.10Kruskal算法"></a>3.10Kruskal算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(mlogm)，n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N]; <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> W &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">// 并查集核心操作</span></span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i; <span class="comment">// 初始化并查集</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)&#123; <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第四章-数学知识"><a href="#第四章-数学知识" class="headerlink" title="第四章 数学知识"></a>第四章 数学知识</h2><h3 id="4-1试除法判定质数"><a href="#4-1试除法判定质数" class="headerlink" title="4.1试除法判定质数"></a>4.1试除法判定质数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 第一个质数从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123; <span class="comment">// 枚举到sqrt(x)即可</span></span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="comment">// 如果出现了1和它本身以外的约数，那么判断不是质数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">is_prime</span>(i)) cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626105508292.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626105508292.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626105508292"></p><h3 id="4-2试除法分解质因数"><a href="#4-2试除法分解质因数" class="headerlink" title="4.2试除法分解质因数"></a>4.2试除法分解质因数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">divide</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626110204816.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626110204816.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626110204816"></p><h3 id="4-3朴素筛法求素数"><a href="#4-3朴素筛法求素数" class="headerlink" title="4.3朴素筛法求素数"></a>4.3朴素筛法求素数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有的素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有的素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)&#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i ++ ) cout &lt;&lt; primes[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626111023572.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626111023572.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626111023572"></p><h3 id="4-4线性筛法求素数"><a href="#4-4线性筛法求素数" class="headerlink" title="4.4线性筛法求素数"></a>4.4线性筛法求素数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primses[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; primes[i] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5试除法求所有约数"><a href="#4-5试除法求所有约数" class="headerlink" title="4.5试除法求所有约数"></a>4.5试除法求所有约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    res = <span class="built_in">get_divisors</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : res) cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626131038212.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626131038212.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626131038212"></p><h3 id="4-6约数个数之和"><a href="#4-6约数个数之和" class="headerlink" title="4.6约数个数之和"></a>4.6约数个数之和</h3><h4 id="4-6-1如果数N可以表示为"><a href="#4-6-1如果数N可以表示为" class="headerlink" title="4.6.1如果数N可以表示为"></a>4.6.1如果数N可以表示为</h4><p>$$<br>N &#x3D; p_1^{c_1} \times p_2^{c_2} \times \cdots \times p_k^{c_k}<br>$$</p><h4 id="4-6-2约数的个数为"><a href="#4-6-2约数的个数为" class="headerlink" title="4.6.2约数的个数为"></a>4.6.2约数的个数为</h4><p>$$<br>(c_1 + 1) \times (c_2 + 1) \times \cdots \times (c_k + 1)<br>$$</p><h4 id="4-6-3约数之和为"><a href="#4-6-3约数之和为" class="headerlink" title="4.6.3约数之和为"></a>4.6.3约数之和为</h4><p>$$<br>(1+p_1+p_1^2+\cdots+p_1^{c_1})\times(1+p_2+p_2^2+\cdots+p_2^{c_2})\times\cdots\times(1+p_k+p_k^2+\cdots+p_k^{c_k})<br>$$</p><h3 id="4-7欧几里得算法"><a href="#4-7欧几里得算法" class="headerlink" title="4.7欧几里得算法"></a>4.7欧几里得算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8求欧拉函数"><a href="#4-8求欧拉函数" class="headerlink" title="4.8求欧拉函数"></a>4.8求欧拉函数</h3><p><img src="/../imgs/$%7Bfiilename%7D/7ffb5224c5bb426bab912fab2ea1abed.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/7ffb5224c5bb426bab912fab2ea1abed.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i ; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">phi</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) res = res / x * (x - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">phi</span>(n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626154857952.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626154857952.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626154857952"></p><h4 id="4-8-1欧拉函数"><a href="#4-8-1欧拉函数" class="headerlink" title="4.8.1欧拉函数"></a>4.8.1欧拉函数</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714153036633.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714153036633.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714153036633"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = a;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= a / i; i ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (a % i == <span class="number">0</span>)&#123; <span class="comment">// i是a的一个质因子</span></span><br><span class="line">                res = res / i * (i - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (a % i == <span class="number">0</span>) a /= i; <span class="comment">// a就把这个质因子除干净</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; <span class="number">1</span>) res = res / a * (a - <span class="number">1</span>); <span class="comment">// 说明a还有一个大于1的质因子</span></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9筛法求欧拉函数"><a href="#4-9筛法求欧拉函数" class="headerlink" title="4.9筛法求欧拉函数"></a>4.9筛法求欧拉函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N]; <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> primes[N], cnt; <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">int</span> euler[N]; <span class="comment">// 存储每个数的欧拉函数</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">//st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_eulers</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    euler[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i])&#123;</span><br><span class="line">            primes[cnt ++ ] = i;</span><br><span class="line">            euler[i] = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )&#123;</span><br><span class="line">            <span class="type">int</span> t = primes[j] * i;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                euler[t] = euler[i] * primes[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            euler[t] = euler[i] * (primes[j] - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_eulers</span>(n);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; euler[n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10快速幂"><a href="#4-10快速幂" class="headerlink" title="4.10快速幂"></a>4.10快速幂</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">求 m^k mod p, 时间复杂度 <span class="built_in">O</span>(logk)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; <span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">qmi</span>(<span class="number">2</span>, <span class="number">1156165</span>, <span class="number">3</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20230626160720800.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230626160720800.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230626160720800"></p><h3 id="4-11高斯消元"><a href="#4-11高斯消元" class="headerlink" title="4.11高斯消元"></a>4.11高斯消元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// a[N][N]是增广矩阵</span><br></pre></td></tr></table></figure><h2 id="第五章-动态规划"><a href="#第五章-动态规划" class="headerlink" title="第五章 动态规划"></a>第五章 动态规划</h2><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715101300789.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715101300789.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715101300789"></p><h3 id="5-1-01背包问题"><a href="#5-1-01背包问题" class="headerlink" title="5.1 01背包问题"></a>5.1 01背包问题</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715101323752.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715101323752.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715101323752"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715101359488.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715101359488.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715101359488"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715102014617.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715102014617.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715102014617"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715102348063.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715102348063.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715102348063"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715102401605.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715102401605.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715102401605"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715102417407.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715102417407.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715102417407"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m; <span class="comment">// 物品个数，背包容量</span></span><br><span class="line"><span class="type">int</span> v[N], w[N]; <span class="comment">// 物品体积 物品价值</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">// 状态属性</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f[0][0~m], 表示考虑前0件物品，总体积不超过m的所有选法中的最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 枚举所有的物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )&#123; <span class="comment">// 枚举所有体积</span></span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j]; <span class="comment">// 左边的情况一定存在</span></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - v[i]] + w[i]); <span class="comment">// 右边的情况不一定存在，只有当剩余的背包容量大于体积v[i]时才成立</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl; <span class="comment">// 代表从前n件物品中，总体积不超过m的所有选法中价值最大的那一个，就是答案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2完全背包问题"><a href="#5-2完全背包问题" class="headerlink" title="5.2完全背包问题"></a>5.2完全背包问题</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715103935916.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715103935916.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715103935916"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715104035145.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715104035145.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715104035145"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k * v[i] &lt;= j; k ++ )</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3多重背包问题I"><a href="#5-3多重背包问题I" class="headerlink" title="5.3多重背包问题I"></a>5.3多重背包问题I</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715104553501.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715104553501.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715104553501"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N], s[N]; </span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[i] &amp;&amp; k * v[i] &lt;= j; k ++ )</span><br><span class="line">               f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4多重背包问题"><a href="#5-4多重背包问题" class="headerlink" title="5.4多重背包问题||"></a>5.4多重背包问题||</h3><h3 id="5-5分组背包"><a href="#5-5分组背包" class="headerlink" title="5.5分组背包"></a>5.5分组背包</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230715105506817.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230715105506817.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230715105506817"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N][N], w[N][N], s[N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i ++ )&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s[i]; j ++ )</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="comment">// 从前往后枚举每一组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= <span class="number">0</span>; j -- ) <span class="comment">// 从大到小枚举体积</span></span><br><span class="line">            <span class="keyword">if</span> (v[i][k] &lt;= j)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - v[i][k]] + w[i][k]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第六章-贪心"><a href="#第六章-贪心" class="headerlink" title="第六章 贪心"></a>第六章 贪心</h2><h2 id="第七章-时空复杂度分析"><a href="#第七章-时空复杂度分析" class="headerlink" title="第七章 时空复杂度分析"></a>第七章 时空复杂度分析</h2><h2 id="第八章-动态规划——从集合角度考虑DP问题"><a href="#第八章-动态规划——从集合角度考虑DP问题" class="headerlink" title="第八章 动态规划——从集合角度考虑DP问题"></a>第八章 动态规划——从集合角度考虑DP问题</h2><h2 id="第九章-搜索"><a href="#第九章-搜索" class="headerlink" title="第九章 搜索"></a>第九章 搜索</h2><h2 id="第十章-图论"><a href="#第十章-图论" class="headerlink" title="第十章 图论"></a>第十章 图论</h2><h3 id="11-6最近公共祖先"><a href="#11-6最近公共祖先" class="headerlink" title="11.6最近公共祖先"></a>11.6最近公共祖先</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714155642200.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714155642200.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714155642200"></p><h4 id="11-6-1向上标记法"><a href="#11-6-1向上标记法" class="headerlink" title="11.6.1向上标记法"></a>11.6.1向上标记法</h4><h4 id="11-6-2倍增法"><a href="#11-6-2倍增法" class="headerlink" title="11.6.2倍增法"></a>11.6.2倍增法</h4><p><img src="C:\Users\YL.YL.000\AppData\Roaming\Typora\typora-user-images\image-20230714161445674.png" class="lazyload placeholder" data-srcset="C:\Users\YL.YL.000\AppData\Roaming\Typora\typora-user-images\image-20230714161445674.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714161445674"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714160130664.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714160130664.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714160130664"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714160506300.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714160506300.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714160506300"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714160551385.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714160551385.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714160551385"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714160903965.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714160903965.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714160903965"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714161031308.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714161031308.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714161031308"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230714161346146.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230714161346146.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230714161346146"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40010</span>, M = N * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;</span><br><span class="line"><span class="type">int</span> depth[N], fa[N][<span class="number">16</span>];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> root)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(depth, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> depth); <span class="comment">// 初始时，dist初始化为正无穷</span></span><br><span class="line">    depth[<span class="number">0</span>] = <span class="number">0</span>, depth[root] = <span class="number">1</span>; <span class="comment">// 其中0号点是哨兵，我们定义为0， 根结点是1</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root; <span class="comment">// 根结点先加入到队列中去</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)&#123; <span class="comment">// 宽搜求这两个数组</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])[</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (depth[j] &gt; depth[t] + <span class="number">1</span>)&#123;</span><br><span class="line">                depth[j] = depth[t] + <span class="number">1</span>;</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">                fa[j][<span class="number">0</span>] = t;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">15</span>; k ++ )</span><br><span class="line">                    fa[j][k] = fa[fa[j][k - <span class="number">1</span>]][k - <span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth[a] &gt; depth[b]) <span class="built_in">swap</span>(a, b); <span class="comment">// 如果a在b的上面，则交换</span></span><br><span class="line">    <span class="comment">// 跳到同一层，从高往低跳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )&#123;</span><br><span class="line">        <span class="keyword">if</span> (depth[fa[a][k]] &gt;= depth[b]) <span class="comment">// 跳了之后，在b的下面或者是同一层</span></span><br><span class="line">         a = fa[a][k]; <span class="comment">// 那么说明a是可以跳的   </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b) <span class="keyword">return</span> a; <span class="comment">// 说明a或者b就是公共祖先</span></span><br><span class="line">    <span class="comment">// 否则同时往上跳</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">15</span>; k &gt;= <span class="number">0</span>; k -- )&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[a][k])&#123; <span class="comment">// 说明还没有跳到公众祖先上面</span></span><br><span class="line">            a = fa[a][k];</span><br><span class="line">            b = fa[b][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>; <span class="comment">// 定义根结点</span></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">-1</span>) root = a; <span class="comment">// b是-1，则a是根结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">lca</span>(a, b);</span><br><span class="line">    <span class="keyword">if</span> (p == a) <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p == b) <span class="built_in">puts</span>(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第十一章-高级数据结构"><a href="#第十一章-高级数据结构" class="headerlink" title="第十一章 高级数据结构"></a>第十一章 高级数据结构</h2><h2 id="第十二章-数学知识"><a href="#第十二章-数学知识" class="headerlink" title="第十二章 数学知识"></a>第十二章 数学知识</h2><h2 id="第十三章-基础算法"><a href="#第十三章-基础算法" class="headerlink" title="第十三章 基础算法"></a>第十三章 基础算法</h2><h2 id="第十七章-图论"><a href="#第十七章-图论" class="headerlink" title="第十七章 图论"></a>第十七章 图论</h2><h2 id="第十八章-数据结构"><a href="#第十八章-数据结构" class="headerlink" title="第十八章 数据结构"></a>第十八章 数据结构</h2><h2 id="第十九章-动态规划"><a href="#第十九章-动态规划" class="headerlink" title="第十九章 动态规划"></a>第十九章 动态规划</h2><h2 id="第二十章-计算几何"><a href="#第二十章-计算几何" class="headerlink" title="第二十章 计算几何"></a>第二十章 计算几何</h2><h2 id="第二十一章-数学"><a href="#第二十一章-数学" class="headerlink" title="第二十一章 数学"></a>第二十一章 数学</h2><h2 id="第二十二章-搜索"><a href="#第二十二章-搜索" class="headerlink" title="第二十二章 搜索"></a>第二十二章 搜索</h2><h2 id="第二十三章-基础算法"><a href="#第二十三章-基础算法" class="headerlink" title="第二十三章 基础算法"></a>第二十三章 基础算法</h2><h2 id="附录：练习题目"><a href="#附录：练习题目" class="headerlink" title="附录：练习题目"></a>附录：练习题目</h2><h3 id="1-数的进制转换"><a href="#1-数的进制转换" class="headerlink" title="1.数的进制转换"></a>1.数的进制转换</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20230918210019940.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230918210019940.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230918210019940"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20230918210038825.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20230918210038825.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230918210038825"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T -- )&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        string a_line, b_line;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; a_line;</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; number;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : a_line)&#123;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) number.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) number.<span class="built_in">push_back</span>(c - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) number.<span class="built_in">push_back</span>(c - <span class="string">&#x27;a&#x27;</span> + <span class="number">36</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">while</span> (number.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = number.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )&#123;</span><br><span class="line">                number[i] += r * a;</span><br><span class="line">                r = number[i] % b;</span><br><span class="line">                number[i] /= b;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(r);</span><br><span class="line">            <span class="keyword">while</span> (number.<span class="built_in">size</span>() &amp;&amp; number.<span class="built_in">back</span>() == <span class="number">0</span>) number.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : res)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x &lt;= <span class="number">9</span>) b_line += <span class="built_in">char</span>(x + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">10</span> &amp;&amp; x &lt;= <span class="number">35</span>) b_line += <span class="built_in">char</span>(x - <span class="number">10</span> + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= <span class="number">36</span>) b_line += <span class="built_in">char</span>(x - <span class="number">36</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a_line &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b_line &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-两数之和"><a href="#2-两数之和" class="headerlink" title="2.两数之和"></a>2.两数之和</h3><p><img src="/../imgs/$%7Bfiilename%7D/image-20231003120818866.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231003120818866.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231003120818866"></p><p>暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j ++ )</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两遍哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; a; <span class="comment">//建立hash表存放数组元素</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>; <span class="comment">// 存放结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )</span><br><span class="line">            a.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(nums[i], i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">            <span class="keyword">if</span> (a.<span class="built_in">count</span>(target - nums[i]) &gt; <span class="number">0</span> &amp;&amp; (target - nums[i] != i))&#123;</span><br><span class="line">            <span class="comment">// 判断是否找到目标元素且目标元素不能是本身</span></span><br><span class="line">                b[<span class="number">0</span>] = i;</span><br><span class="line">                b[<span class="number">1</span>] = a[target - nums[i]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-LeetCode暑期刷题打卡2019——Week1-二分专题"><a href="#3-LeetCode暑期刷题打卡2019——Week1-二分专题" class="headerlink" title="3.LeetCode暑期刷题打卡2019——Week1 二分专题"></a>3.LeetCode暑期刷题打卡2019——Week1 二分专题</h3><p> <img src="/../imgs/$%7Bfiilename%7D/image-20231006164115446.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231006164115446.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231006164115446"></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231005175834656.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231005175834656.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231005175834656"></p><h4 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69.x的平方根"></a>69.x的平方根</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (<span class="type">long</span> <span class="type">long</span>)r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &lt;= x / mid) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35.搜索插入位置"></a>35.搜索插入位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>() || nums.<span class="built_in">back</span>() &lt; target) <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34.在排序数组中查找元素的第一个和最后一个位置"></a>34.在排序数组中查找元素的第一个和最后一个位置</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[r] != target) <span class="keyword">return</span> &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> start = l;</span><br><span class="line">        </span><br><span class="line">        l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> end = l;</span><br><span class="line">        <span class="keyword">return</span> &#123;start, end&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74.搜索二维矩阵"></a>74.搜索二维矩阵</h4><p><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/">https://leetcode.cn/problems/search-a-2d-matrix/description/</a></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231006171258900.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231006171258900.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231006171258900"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>() || matrix[<span class="number">0</span>].<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>(), m = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n * m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (matrix[mid / m][mid % m] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (matrix[r / m][r % m] != target) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153.寻找旋转排序数组中的最小值"></a>153.寻找旋转排序数组中的最小值</h4><p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/</a></p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231006175506598.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231006175506598.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231006175506598"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums.<span class="built_in">back</span>()) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> nums[r];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33.搜索旋转排序数组"></a>33.搜索旋转排序数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 找到最小值</span></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= nums.<span class="built_in">back</span>()) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums.<span class="built_in">back</span>()) r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = <span class="number">0</span>, r -- ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (nums[l] == target) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278.第一个错误的版本"></a>278.第一个错误的版本</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231007121158409.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231007121158409.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231007121158409"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isBadVersion</span><span class="params">(<span class="type">int</span> version)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (<span class="type">long</span> <span class="type">long</span>)l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isBadVersion</span>(mid)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162.寻找峰值"></a>162.寻找峰值</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231007122324601.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231007122324601.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231007122324601"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findPeakElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[mid + <span class="number">1</span>]) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287.寻找重复数"></a>287.寻找重复数</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231007123507855.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231007123507855.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231007123507855"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> : nums)</span><br><span class="line">                <span class="keyword">if</span> (x &gt;= l &amp;&amp; x &lt;= mid)</span><br><span class="line">                    cnt ++ ;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; mid - l + <span class="number">1</span>) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="275-H指数-II"><a href="#275-H指数-II" class="headerlink" title="275.H指数 II"></a>275.H指数 II</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231007124847737.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231007124847737.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231007124847737"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[nums.<span class="built_in">size</span>() - mid] &gt;= mid) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="19-删掉倒数第n个结点"><a href="#19-删掉倒数第n个结点" class="headerlink" title="19.删掉倒数第n个结点"></a>19.删掉倒数第n个结点</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231008122936284.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231008122936284.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231008122936284"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> first = dummy, second = dummy;</span><br><span class="line">        <span class="keyword">while</span> (n -- ) first = first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (first-&gt;next) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        second-&gt;next = second-&gt;next-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="237-删除链表中的结点"><a href="#237-删除链表中的结点" class="headerlink" title="237.删除链表中的结点"></a>237.删除链表中的结点</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231008124029728.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231008124029728.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231008124029728"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next = node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../imgs/$%7Bfiilename%7D/image-20231008124424262.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231008124424262.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231008124424262"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span> </span>&#123;</span><br><span class="line">        *(ndoe) = *(node-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="83-从排序列表中删除重复项"><a href="#83-从排序列表中删除重复项" class="headerlink" title="83.从排序列表中删除重复项"></a>83.从排序列表中删除重复项</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231008125047131.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231008125047131.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231008125047131"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="61-旋转链表"><a href="#61-旋转链表" class="headerlink" title="61.旋转链表"></a>61.旋转链表</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231008130135631.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231008130135631.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231008130135631"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n ++ ;</span><br><span class="line">        </span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">auto</span> first = head, second = head;</span><br><span class="line">        <span class="keyword">while</span> (k -- ) first = first-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (first-&gt;next) &#123;</span><br><span class="line">            first = first-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        first-&gt;next = head;</span><br><span class="line">        head = second-&gt;next;</span><br><span class="line">        second-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="24-交换链表中相邻的两个节点，最后返回头结点"><a href="#24-交换链表中相邻的两个节点，最后返回头结点" class="headerlink" title="24.交换链表中相邻的两个节点，最后返回头结点"></a>24.交换链表中相邻的两个节点，最后返回头结点</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231010170145640.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231010170145640.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231010170145640"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Soultion</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode * <span class="title">swapPairs</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = dummy; p-&gt;next &amp;&amp; p-&gt;next-&gt;next;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> a = p-&gt;next, b = a-&gt;next;</span><br><span class="line">            p-&gt;next = b;</span><br><span class="line">            a-&gt;next = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            p = a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="206-翻转链表I"><a href="#206-翻转链表I" class="headerlink" title="206.翻转链表I"></a>206.翻转链表I</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231012162804775.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231012162804775.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231012162804775"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> a = head, b = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = b-&gt;next;</span><br><span class="line">            b-&gt;next = a;</span><br><span class="line">            a = b, b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="92-翻转链表II"><a href="#92-翻转链表II" class="headerlink" title="92.翻转链表II"></a>92.翻转链表II</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231012164154538.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231012164154538.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231012164154538"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == n) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">// 定义虚拟节点</span></span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">// 找到b和d的位置</span></span><br><span class="line">        <span class="keyword">auto</span> a = dummy, d = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i ++ ) a = a-&gt;next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) d = d-&gt;next;</span><br><span class="line">        <span class="comment">// 进行翻转</span></span><br><span class="line">        <span class="keyword">auto</span> b = a-&gt;next, c = d-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = b, q = b-&gt;next; q != c) &#123;</span><br><span class="line">            <span class="keyword">auto</span> o = q-&gt;next;</span><br><span class="line">            q-&gt;next = p;</span><br><span class="line">            p = q, q = o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改变指针</span></span><br><span class="line">        b-&gt;next = c;</span><br><span class="line">        a-&gt;next = d;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="160-两个链表的交点"><a href="#160-两个链表的交点" class="headerlink" title="160.两个链表的交点"></a>160.两个链表的交点</h4><p> <img src="/../imgs/$%7Bfiilename%7D/image-20231013103531999.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231013103531999.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231013103531999"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = headA, q = headB;</span><br><span class="line">        <span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p) p = p-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> p = headB;</span><br><span class="line">            <span class="keyword">if</span> (q) q = q-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> q = headA;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="142-链表循环II"><a href="#142-链表循环II" class="headerlink" title="142.链表循环II"></a>142.链表循环II</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231013105006617.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231013105006617.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231013105006617"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (slow) slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148.排序链表"></a>148.排序链表</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231013111051991.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231013111051991.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231013111051991"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) n ++ ;</span><br><span class="line">        <span class="keyword">auto</span> dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> cur = dummy;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + i &lt; n; j += i * <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> left = cur-&gt;next, right = cur-&gt;next;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k ++ ) right = right-&gt;next;</span><br><span class="line">                <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i &amp;&amp; r &lt; i &amp;&amp; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (left-&gt;val &lt;= right-&gt;val) &#123;</span><br><span class="line">                        cur-&gt;next = left;</span><br><span class="line">                        cur = left;</span><br><span class="line">                        left = left-&gt;next;</span><br><span class="line">                        l ++ ;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur-&gt;next = right;</span><br><span class="line">                        cur = right;</span><br><span class="line">                        right = right-&gt;next;</span><br><span class="line">                        r ++ ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (l &lt; i) &#123;</span><br><span class="line">                    cur-&gt;next = left;</span><br><span class="line">                    cur = left;</span><br><span class="line">                    left = left-&gt;next;</span><br><span class="line">                    l ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (r &lt; i &amp;&amp; right) &#123;</span><br><span class="line">                    cur-&gt;next = right;</span><br><span class="line">                    cur = right;</span><br><span class="line">                    right = right-&gt;next;</span><br><span class="line">                    r ++ ;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                cur-&gt;next = righ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="98-判断二叉搜索树"><a href="#98-判断二叉搜索树" class="headerlink" title="98.判断二叉搜索树"></a>98.判断二叉搜索树</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231013205512787.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231013205512787.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231013205512787"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isVaildBST</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root, INT_MIN, INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *root, <span class="type">long</span> <span class="type">long</span> minv, <span class="type">long</span> <span class="type">long</span> maxv)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &lt; minv || root-&gt;val &gt; maxv) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, miv, root-&gt;val - <span class="number">1ll</span>) &amp;&amp; <span class="built_in">dfs</span>(root-&gt;right, root-&gt;val + <span class="number">1ll</span>, maxv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94.二叉树的中序遍历"></a>94.二叉树的中序遍历</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231016165351420.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231016165351420.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231016165351420"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (p || stk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (p)&#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(p);</span><br><span class="line">                p = p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            p = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(p-&gt;val);</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="101-镜像二叉树"><a href="#101-镜像二叉树" class="headerlink" title="101.镜像二叉树"></a>101.镜像二叉树</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231016170430801.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231016170430801.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231016170430801"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空节点是特殊的镜像二叉树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> !p &amp;&amp; !q; <span class="comment">// 只有当左右子树同时为空时才为对称二叉树</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">dfs</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">dfs</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代法</span></span><br><span class="line"><span class="comment">// 左边：左中右遍历；右边：右中左遍历，同时检查是否相等</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt; left, right;</span><br><span class="line">        <span class="keyword">auto</span> l = root-&gt;left, r = root-&gt;right;</span><br><span class="line">        <span class="keyword">while</span> (l || r || left.<span class="built_in">size</span>() || right.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span> (l &amp;&amp; r)&#123;</span><br><span class="line">                left.<span class="built_in">push</span>(l), l = l-&gt;left;</span><br><span class="line">                right.<span class="built_in">push</span>(r), r = r-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (l || r) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            l = left.<span class="built_in">top</span>(), left.<span class="built_in">pop</span>();</span><br><span class="line">            r = right.<span class="built_in">top</span>(),right.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (l-&gt;val != r-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            l = l-&gt;right, r = r-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="105-通过前序和中序构建二叉树"><a href="#105-通过前序和中序构建二叉树" class="headerlink" title="105.通过前序和中序构建二叉树"></a>105.通过前序和中序构建二叉树</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231016172631457.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231016172631457.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231016172631457"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) pos[inorder[i]] = i;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode *<span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;preorder, vector&lt;<span class="type">int</span>&gt; &amp;inorder, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> il, <span class="type">int</span> ir)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pl &gt; pr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> val = preorder[pl];</span><br><span class="line">        <span class="comment">// 前序遍历的起点、终点；中序遍历的起点、终点</span></span><br><span class="line">        <span class="type">int</span> k = pos[val]; <span class="comment">//  前序遍历点在中序遍历中的位置</span></span><br><span class="line">        <span class="type">int</span> len = k - il; <span class="comment">// 左子树长度</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs</span>(preorder, inorder, pl + <span class="number">1</span>, pl + len, il, k - <span class="number">1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs</span>(preorder, inorder, pl + len + <span class="number">1</span>, pr, k + <span class="number">1</span>, ir);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="102-层序遍历"><a href="#102-层序遍历" class="headerlink" title="102.层序遍历"></a>102.层序遍历</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231018115145544.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231018115145544.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231018115145544"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode *root)&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>(); <span class="comment">// 当前这一层点的个数</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; level; <span class="comment">//当前遍历的结果</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i ++ )&#123;</span><br><span class="line">                <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                level.<span class="built_in">push_back</span>(t-&gt;val);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (t-&gt;right) q.<span class="built_in">push</span>(t.right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            res.<span class="built_in">push_back</span>(level);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="236-求两个点的最近公共祖先"><a href="#236-求两个点的最近公共祖先" class="headerlink" title="236.求两个点的最近公共祖先"></a>236.求两个点的最近公共祖先</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231018121107994.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231018121107994.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231018121107994"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果以root为根的子树中包含q和q,则返回他们的最近公共祖先</span></span><br><span class="line">        <span class="comment">// 如果只包含p, 则返回p</span></span><br><span class="line">        <span class="comment">// 如果只包含q, 则返回q</span></span><br><span class="line">        <span class="comment">// 如果都不包含，则返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (!root || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!left) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span> (!right) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543.二叉树的直径"></a>543.二叉树的直径</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231018121937947.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231018121937947.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231018121937947"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left + <span class="number">1</span>, right + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="124-二叉树最大路径和"><a href="#124-二叉树最大路径和" class="headerlink" title="124.二叉树最大路径和"></a>124.二叉树最大路径和</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231023123720347.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231023123720347.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231023123720347"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回从root向下走的最大值</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前为空，则不存在</span></span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分别求从左子树向下走的最大值和从右子树向下走的最大值</span></span><br><span class="line">        <span class="keyword">auto</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">auto</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        <span class="comment">// 答案是从当前答案、左子树+右子树+当前值中的最大值</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right + root-&gt;val);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回分为：向左走、向右走、不走，0就没有必要返回了，返回0宁可不要</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="number">0</span>, root-&gt;val + <span class="built_in">max</span>(left, right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="173-二叉树迭代器"><a href="#173-二叉树迭代器" class="headerlink" title="173.二叉树迭代器"></a>173.二叉树迭代器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(1) 空间复杂度O(h), 即可用栈来模拟中序便利的过程，栈的最大长度和树的高度成正比</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    stack&lt;TreeNode*&gt; stk;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BSTIterator</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="comment">// 初始化时，将树的最左边那条链插入到栈中</span></span><br><span class="line">        <span class="keyword">while</span> (root)&#123;</span><br><span class="line">            <span class="comment">// 每一次把根节点插入</span></span><br><span class="line">            stk.<span class="built_in">push</span>(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每次调用返回中序遍历的下一个节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每次取next就是取栈顶元素</span></span><br><span class="line">        <span class="keyword">auto</span> p = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 每次遍历完一个点的时候，就需要将右子树加入栈</span></span><br><span class="line">        <span class="comment">// 首先保存答案，因为最后要返回答案</span></span><br><span class="line">        <span class="type">int</span> res = p-&gt;val;</span><br><span class="line">        <span class="comment">// 先指向右子树</span></span><br><span class="line">        p = p-&gt;right;</span><br><span class="line">        <span class="comment">// 将右子树加进来，就是将最左边的一条链加进来</span></span><br><span class="line">        <span class="keyword">while</span> (p)&#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 询问是否有下一个节点</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当我们遍历完所有点的时候，我们的栈就是空的</span></span><br><span class="line">        <span class="keyword">return</span> !stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="297-序列化和反序列化二叉树"><a href="#297-序列化和反序列化二叉树" class="headerlink" title="297.序列化和反序列化二叉树"></a>297.序列化和反序列化二叉树</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231023172821434.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231023172821434.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp"></p><p>仅有前序遍历的话，是不能唯一确定一颗二叉树</p><p>前序遍历 + 中序遍历&#x2F;后序遍历 + 中序遍历，就可以唯一确定一颗二叉树</p><p>但是如果前序、中序、后序遍历序列中包含了空节点，那么也可以唯一确定二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 序列化：二叉树转字符串</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">dfs1</span>(root, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(TreeNode* root, string &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为空</span></span><br><span class="line">        <span class="keyword">if</span> (!root)&#123;</span><br><span class="line">            res += <span class="string">&quot;+,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则，先遍历根节点，先加上当前节点的值，加上逗号</span></span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="comment">// 遍历完根节点，就遍历左子树和右子树</span></span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;left, res);</span><br><span class="line">        <span class="built_in">dfs1</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反序列化：字符串转二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 需要一个指针，指向当前构建到哪个字符了</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(data, u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回根节点的指针</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs2</span><span class="params">(string &amp;data, <span class="type">int</span> &amp;u)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 如果当前字符是#，那就跳过2个位置</span></span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">            u += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前节点不空，那就先求出当前节点的值</span></span><br><span class="line">        <span class="comment">// 节点中的值可能是负数，那就需要特判</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> is_minus = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (data[u] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            is_minus = <span class="literal">true</span>;</span><br><span class="line">            u ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只要指针没有碰到逗号，就一直做</span></span><br><span class="line">        <span class="keyword">while</span> (data[u] != <span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 计算值</span></span><br><span class="line">            t = t * <span class="number">10</span> + data[u] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            u ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后还有加加，是为了跳过逗号</span></span><br><span class="line">        u ++ ;</span><br><span class="line">        <span class="comment">// 是否是负数</span></span><br><span class="line">        <span class="keyword">if</span> (is_minus) t = -t;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建根节点，之后是根左右的顺序</span></span><br><span class="line">        <span class="keyword">auto</span> root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(t);</span><br><span class="line">        root-&gt;left = <span class="built_in">dfs2</span>(data, u);</span><br><span class="line">        root-&gt;right = <span class="built_in">dfs2</span>(data, u);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="38-计数然后说"><a href="#38-计数然后说" class="headerlink" title="38.计数然后说"></a>38.计数然后说</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231028162130923.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231028162130923.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231028162130923"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">countAndSay</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        string s = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="comment">// 产生第n行，递推n-1次即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )&#123;</span><br><span class="line">            <span class="comment">// 先定义上一行的字符串，是空的</span></span><br><span class="line">            string ns;</span><br><span class="line">            <span class="comment">// 然后遍历当前这一行中所有连续的段，从前往后枚举每一个位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; s.<span class="built_in">size</span>(); j ++ )&#123;</span><br><span class="line">                <span class="type">int</span> k = j;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[k] == s[j]) k ++ ;</span><br><span class="line">                ns += <span class="built_in">to_string</span>(k - j) + s[i];</span><br><span class="line">                j = k - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s = ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49.Group Anagrams"></a>49.Group Anagrams</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231028173306477.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231028173306477.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231028173306477"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs)&#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : strs)&#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="comment">// 乱序字符串的本质是排序后都是一样的</span></span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            <span class="comment">// 将排序后一样的字符串作为key，原来的字符串作为值，这样就做到了分组的效果</span></span><br><span class="line">            hash[key].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> item : hash) res.<span class="built_in">push_back</span>(item.second);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151.Reverse Words in a String"></a>151.Reverse Words in a String</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231028174559408.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231028174559408.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231028174559408"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">            <span class="comment">// 过滤所有的空格</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>) i ++ ;</span><br><span class="line">            <span class="keyword">if</span> (i == s.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 找到一段连续的非空格</span></span><br><span class="line">            <span class="type">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] != <span class="string">&#x27; &#x27;</span>) j ++ ;</span><br><span class="line">            <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i, s.begin + j);</span><br><span class="line">            <span class="comment">// 若k不是0，则先需要隔开一个空格</span></span><br><span class="line">            <span class="keyword">if</span> (k) s[k ++ ] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="comment">// 复制过程</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j) s[k ++ ] = s[i ++ ];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// k后多余的部分删去</span></span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + k, s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="comment">// 最后再翻转一遍</span></span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165.Compare Version Numbers"></a>165.Compare Version Numbers</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231029174603357.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231029174603357.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231029174603357"></p><p>如何找到字符串中的数字？</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231029174803221.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231029174803221.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231029174803221"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">compareVersion</span><span class="params">(string s1, string s2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 定义两个指针，分别从0开始</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 两个指针只要有一个不空，就一直做</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1.<span class="built_in">size</span>() || j &lt; s2.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = i, y = j;</span><br><span class="line">            <span class="keyword">while</span> (x &lt; s1.<span class="built_in">size</span>() &amp;&amp; s1[x] != <span class="string">&#x27;.&#x27;</span>) x ++ ;</span><br><span class="line">            <span class="keyword">while</span> (y &lt; s2.<span class="built_in">size</span>() &amp;&amp; s2[y] != <span class="string">&#x27;.&#x27;</span>) y ++ ;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 特判一些，可能为0</span></span><br><span class="line">            <span class="type">int</span> a = i == x ? <span class="number">0</span> : <span class="built_in">atoi</span>(s1.<span class="built_in">substr</span>(i, x - i).<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="type">int</span> b = j == y ? <span class="number">0</span> : <span class="built_in">atoi</span>(s2.<span class="built_in">substr</span>(j, y - j).<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="comment">// 返回答案</span></span><br><span class="line">            <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 跳过&#x27;.&#x27;</span></span><br><span class="line">            i = x + <span class="number">1</span>, j = y + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="929-Unique-Email-Addresses"><a href="#929-Unique-Email-Addresses" class="headerlink" title="929.Unique Email Addresses"></a>929.Unique Email Addresses</h4><p>先处理邮箱字符串</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231029180528078.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231029180528078.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231029180528078"></p><p>后使用哈希表数出不同的邮箱的种类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numUniqueEmails</span><span class="params">(vector&lt;string&gt;&amp; emails)</span></span>&#123;</span><br><span class="line">        unordered_set&lt;string&gt; hash;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> email : emails)&#123;</span><br><span class="line">            <span class="type">int</span> at = email.<span class="built_in">find</span>(<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">            string name;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> c : email.<span class="built_in">substr</span>(<span class="number">0</span>, at));</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>) name += c;</span><br><span class="line">            string doumain = email.<span class="built_in">substr</span>(at + <span class="number">1</span>);</span><br><span class="line">            hash.<span class="built_in">insert</span>(name + <span class="string">&#x27;@&#x27;</span> + doumain);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hash.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5.Longest Palindromic Substring"></a>5.Longest Palindromic Substring</h4><p>返回最长回文串</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231030115604158.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231030115604158.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231030115604158"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 遍历字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">            <span class="type">int</span> j, k; <span class="comment">// j 往左走，k 往右走</span></span><br><span class="line">            <span class="comment">// 回文串长度是奇数</span></span><br><span class="line">            <span class="keyword">for</span> (j = i, k = i; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]; j --, k ++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; k - j + <span class="number">1</span>)</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(j, k - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 回文串长度是偶数</span></span><br><span class="line">            <span class="keyword">for</span> (j = i, k = i + <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; k &lt; s.<span class="built_in">size</span>() &amp;&amp; s[j] == s[k]; j --, k ++ )&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">size</span>() &lt; k - j + <span class="number">1</span>)</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(j, k - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-ZigZag-Conversion"><a href="#6-ZigZag-Conversion" class="headerlink" title="6.ZigZag Conversion"></a>6.ZigZag Conversion</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231030123419546.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231030123419546.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231030123419546"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 特判，后面有i == n - 1的判断</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 枚举行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// i = 0 或者 i == n - 1就是公差是2 * (n - 1)的等差数列</span></span><br><span class="line">            <span class="keyword">if</span> (!i || i == n - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * (n - <span class="number">1</span>)) res += s[j];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 两个等差数列交错</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i, k = <span class="number">2</span> * (n - <span class="number">1</span>) - i; j &lt; s.<span class="built_in">size</span>() || k &lt; s.<span class="built_in">size</span>(); j += <span class="number">2</span> * (n - <span class="number">1</span>), k += <span class="number">2</span> * (n - <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; s.<span class="built_in">size</span>()) res += s[j];</span><br><span class="line">                    <span class="keyword">if</span> (k &lt; s.<span class="built_in">size</span>()) res += s[k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3.Longest Substring Without Repeating Characters"></a>3.Longest Substring Without Repeating Characters</h4><p>最长的没有包含重复字符的字符串</p><p>使用哈希表存储两个指针间出现没有重复字母的次数</p><p><img src="/../imgs/$%7Bfiilename%7D/image-20231030125523748.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231030125523748.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231030125523748"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ )&#123;</span><br><span class="line">            <span class="comment">// 绿颜色的指针向后走的时候，会加进来一个新的字母</span></span><br><span class="line">            hash[s[i]] ++ ;</span><br><span class="line">            <span class="comment">// 如果加完之后，两个指针间有重复字母，那么这个字母一定是s[i]</span></span><br><span class="line">            <span class="comment">// 有重复，那么将s[i]从Hash中删去，并让j后移</span></span><br><span class="line">            <span class="keyword">while</span> (hash[s[i]] &gt; <span class="number">1</span>) hsah[s[j ++ ]] -- ;</span><br><span class="line">            res = <span class="built_in">max</span>(i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="208-Implement-Tire-Prefix-Tree"><a href="#208-Implement-Tire-Prefix-Tree" class="headerlink" title="208.Implement Tire (Prefix Tree)"></a>208.Implement Tire (Prefix Tree)</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231104124714764-1699073237598-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231104124714764-1699073237598-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231104124714764"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Tire树节点一般用结构体表示</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="comment">// 有没有以这个节点为结尾的单词</span></span><br><span class="line">        <span class="type">bool</span> is_end;</span><br><span class="line">        <span class="comment">// 最多26个儿子</span></span><br><span class="line">        Node *son[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="built_in">Node</span>() &#123;</span><br><span class="line">            is_end = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i ++ ) son[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="comment">// 先创建根节点</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie*/</span> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 就从根节点开始遍历</span></span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="comment">// 从前往后遍历每一个字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">            <span class="comment">// 首先存储这个字母的编号</span></span><br><span class="line">            <span class="type">int</span> u = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 判断儿子是否存在，不存在就创建</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;son[u] == <span class="literal">NULL</span>) p-&gt;son[u] = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">            <span class="comment">// p走到儿子上去</span></span><br><span class="line">            p = p-&gt;son[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后标记一下，现在有了以p结尾的单词</span></span><br><span class="line">        p-&gt;is_end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询也是一样，从前往后遍历这个单词</span></span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : word) &#123;</span><br><span class="line">            <span class="comment">// 求一下当前的编号</span></span><br><span class="line">            <span class="type">int</span> u = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果当前儿子不存在的话，说明当前路径不存在，也就是说该单词不存在</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;son[u] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 否则p继续向下走即可</span></span><br><span class="line">            p = p-&gt;son[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后进行判断是否有单词结束标记</span></span><br><span class="line">        <span class="keyword">return</span> p-&gt;is_end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix*/</span> </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查询也是一样，从前往后遍历这个单词</span></span><br><span class="line">        <span class="keyword">auto</span> p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : prefix) &#123;</span><br><span class="line">            <span class="comment">// 求一下当前的编号</span></span><br><span class="line">            <span class="type">int</span> u = c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果当前儿子不存在的话，说明当前路径不存在，也就是说该单词不存在</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;son[u] == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 否则p继续向下走即可</span></span><br><span class="line">            p = p-&gt;son[u];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找前缀，直接返回即可</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="273-Iteger-to-English-Words"><a href="#273-Iteger-to-English-Words" class="headerlink" title="273.Iteger to English Words"></a>273.Iteger to English Words</h4><p><img src="/../imgs/$%7Bfiilename%7D/image-20231105121019454-1699157421627-1.png" class="lazyload placeholder" data-srcset="/../imgs/$%7Bfiilename%7D/image-20231105121019454-1699157421627-1.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231105121019454"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    string small[<span class="number">20</span>] = &#123;<span class="string">&quot;Zero&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    string decade[<span class="number">10</span>] = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thrity&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;FIfty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line">    string big[<span class="number">4</span>] = &#123;<span class="string">&quot;Billion&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function">string <span class="title">numberToWords</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先判断num为0的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> (!num) <span class="keyword">return</span> small[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 开始枚举</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">100000000</span>, j = <span class="number">0</span>; i &gt; <span class="number">0</span>; i /= <span class="number">1000</span>, j ++ ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= i) &#123;</span><br><span class="line">                res += <span class="built_in">get_part</span>(num / i) + big[j] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="comment">// 做完以后去除最大的三位</span></span><br><span class="line">                num %= i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后如果会多出很多空格，需要删除</span></span><br><span class="line">        <span class="keyword">while</span> (res.<span class="built_in">back</span>() == <span class="string">&#x27; &#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 输入1000以内的数，然后输出它</span></span><br><span class="line">    <span class="function">string <span class="title">get_part</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="comment">// 如果大于等于100</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="comment">// 先把百位输出</span></span><br><span class="line">            res += small[num / <span class="number">100</span>] + <span class="string">&quot; Hundred &quot;</span>;</span><br><span class="line">            <span class="comment">// 取出十位加个位数字，百位去除了</span></span><br><span class="line">            num %= <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时如等于0了，就不需要再做了</span></span><br><span class="line">        <span class="keyword">if</span> (!num) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 如果小于20，可以直接取small</span></span><br><span class="line">        <span class="keyword">if</span> (num &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">            <span class="comment">// 先输出十位</span></span><br><span class="line">            res += decade[num / <span class="number">10</span>] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="comment">// 拿出个位，去除百位和十位</span></span><br><span class="line">            num %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时如等于0了，就不需要再做了</span></span><br><span class="line">        <span class="keyword">if</span> (!num) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">// 最后加上小于20后的数字即可</span></span><br><span class="line">        res += small[num] + <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 软件开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++算法题目 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
